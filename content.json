{"pages":[{"title":"关于我","text":"个人简介 你好！我是 LeeHua，一名热爱技术的小年轻，业余喜欢捣鼓大数据、后端开发、操作系统等技术。在不断学习和实践中，提升自己，用技术为自己服务。 我擅长的技术： 语言：Java、Python 技术方向：大数据开发、后端开发 博客信息 本博客使用 Hexo 静态博客 搭建，托管在 GitHub，主题选择的是 Icarus主题，并且对其做了一些定制，使其更加简洁、现代且富有实用性。 建站初衷 记录技术，分享成长，激励他人 —— 我建这个博客的初心就是将我的学习心得、编程经验和技术分享给更多的人。通过写博客，我不仅能加深自己的理解，也能帮助别人少走弯路。 为什么我写博客： 知识总结：通过写博客巩固和加深自己对技术的理解。 技术分享：记录自己在学习和项目中的心得，分享给他人。 自我提升：锻炼总结和表达能力，同时检视自己的学习成果。 时间轴记录 时间 事件 2018年8月31日 就读某所本科院校 2018年9月 第一次接触编程语言：C语言 2019年2月 学习并入门 Python 2019年6月 开始接触并参与博客园的写作 2020年4月 搭建个人博客，使用 Hexo 实现静态网站 2021年7月-8月 在某公司担任数仓开发实习生 2022年1月-2023年8月 在某公司担任 Java 后端开发工程师，此后一直从事相关工作 2023年9月 入职某单位偏文岗位，主职工作不再是开发 个人兴趣 除了编程，我也有很多兴趣爱好，以下是一些我的个人兴趣： 健身：保持规律的锻炼，享受挑战自我。 旅行：探索世界各地的风景和文化，是我不断汲取灵感的源泉。 联系方式 你可以通过以下方式与我联系： GitHub：osys Email：lyh9420@icloud.com 未来展望 我希望未来能够在技术的深度与广度上不断突破，尤其是在大数据、人工智能等领域实现更多的创新。与此同时，我也希望能通过技术改变自己，为个人生活带来便利。 在代码程序上，没有bug可以审判我～哈哈哈","link":"/about/"}],"posts":[{"title":"Java并发编程实战","text":"目录结构Java并发编程实战：第1章 简介 Java并发编程实战：第2章 线程安全性 Java并发编程实战：第3章 对象的共享 Java并发编程实战：第4章 组合对象 Java并发编程实战：第5章 构建块 Java并发编程实战：第1-5章 总结 Java并发编程实战：第6章 任务执行 Java并发编程实战：第6章 总结 Java并发编程实战：第7章 取消和关闭 Java并发编程实战：第7章 总结 Java并发编程实战：第8章 应用线程池 Java并发编程实战：第8章 总结 Java并发编程实战：第9章 GUI应用程序 Java并发编程实战：第9章 总结 Java并发编程实战：第10章 活跃度,性能和测试 Java并发编程实战：第10章 总结 Java并发编程实战：第11章 性能可伸缩性 Java并发编程实战：第11章 总结 Java并发编程实战：第12章 测试并发程序 Java并发编程实战：第12章 总结 Java并发编程实战：第13章 显式锁 Java并发编程实战：第13章 总结 Java并发编程实战：第14章 构建自定义的同步工具 Java并发编程实战：第14章 总结 Java并发编程实战：第15章 原子变量与非阻塞同步机制 Java并发编程实战：第15章 总结 Java并发编程实战：第16章 存储模型 Java并发编程实战：第16章 总结 总结代码JavaConcurrency","link":"/posts/661c.html"},{"title":"Java并发编程实战：第1-5章 总结","text":"所有并发问题都归结为如何协调访问并发状态，可变状态越少，保证线程安全就越容易。 尽量将域声明为 final 类型，除非它们的需要是可变的。 不可变对象极大地减轻了并发编程的压力．它们简单而且安金，可以在没有锁或者防御性复制的情况下自由地共享。 封装使管理复杂度变得更可行。 用锁来守护每一个可变变量。对同一不变约束中的所有变量，都使用相同的锁。 在运行复合操作期间持有锁。 在非同步的多线程情况下，访问可变变量的程序是存在隐患的。 在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的（文档化）","link":"/posts/d008.html"},{"title":"Java并发编程实战：第10章 总结","text":"死锁：静态的锁顺序死锁、动态的锁顺序死锁、协作对象之间发生的死锁、资源死锁。 在发生死锁时，可以通过线程转储 — 如使用命令 jcmd PID号 Thread.print 输出线程和锁信息，分析死锁原因。 活跃度危险除了死锁问题，还有饥饿(starvation)、弱响应性、活锁(livelock)","link":"/posts/782e.html"},{"title":"Java并发编程实战：第11章 总结","text":"性能可伸缩性: 多线程能充分的发挥出闲置的处理能力，使现有任务正在运行的情况下立刻开始着手处理新的任务，提高系统的响应性。 Amdahl 定律: N 表示处理器数量，F表示串行化任务的比重。 $$ Speedup \\leq 1 \\div [F + \\big(1 - F\\big)\\div N ] $$ 操作系统会为每个就绪的任务分配一个特定的时间在CPU中运行，使用完时间片后由一个 时间计数器 发出时钟中断请求，停止任务。停止前一个任务后，操作系统会从就绪队列队首中取出一个新的任务，分配执行时间，到该CPU中运行任务。 在 CPU 上对进程或者线程进行切换，切换过程中的信息被保存在进程控制块。当一个新的线程被切换进CPU时，它所需要的数据可能不在当前CPU的本地缓存中，因此上下文切换可能导致一些缓存缺失，因而线程在首次调度运行时会更加缓慢。 锁的粗化(lock coarsening)，把邻近的同步代码块用相同的锁合并起来。 成熟的 JVM 可以使用 逸出分析(escape analysis) 来识别本地对象的引用(即找出不会被发布到堆的本地对象引用) 串行化 会损害可伸缩性，上下文切换 会损害性能。 可以通过分拆锁(lock spliting)和分离锁(lock striping)来减小锁的粒度。 ReadWriteLock 实行了一个 多读者-单写者(multiple-reader, single-write)加锁规则：只要没有更改，那么多个读者可以并发访问共享资源，但是写者必须独占获得锁。 程序的可伸缩性是由必须连续执行的代码比例决定的。提升可伸缩性：减少用于获取锁的时间，减小锁的粒度，减少锁的占用时间，或者用非独占锁或非阻塞锁来取代独占锁。","link":"/posts/842a.html"},{"title":"Java并发编程实战：第12章 总结","text":"本章主要说明的是，如何测试并发程序。 分别从测试正确性、测试性能上说明如何编写测试程序。 在测试过程中，为了确保结果的准确性，除了要多次测试外，还要避免性能测试陷阱。","link":"/posts/c025.html"},{"title":"Java并发编程实战：第13章 总结","text":"显式的 Lock 与内部锁 synchronized 相比提供了一些扩展的特性，包括处理不可用的锁时更好的灵活性，以及对队列行为更好的控制。 ReentrantLock 与 synchronized各有优缺点。 读-写锁允许多个读者并发访问被守护的对象，当访问多为读取数据结构的时候，它具有改进可伸缩性的潜力。","link":"/posts/3c21.html"},{"title":"Java并发编程实战：第13章 显式锁","text":"1. Lock 和 ReentrantLockLock 接口： 12345678public interface Lock { void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();} Lock 提供了无条件的、可轮询的、定时的、可中断的锁获取操作，所有加锁和解锁的方法都是显式的。 Lock 的实现必须提供具有与内部加锁相同的内存可见性的语义。 ReentrantLock 实现了 Lock 接口，提供了与内置锁 synchronized 相同的互斥和内存可见性保证。获得 ReentrantLock 的锁与进入 synchronized 块有着相同的内存语义，释放 ReentrantLock 锁与退出 synchronized 块有相同的内存语义。 synchronized 内置锁局限性： 不能中断那些正在等待获取锁的线程。 在请求锁失败情况下，会无限等待。 Lock 锁必须在 finally 中释放。如果 Lock 锁守护的代码在 try 块之外跑出了异常，它将永远不会被释放。ReentrantLock 不能完全替代 synchronized，忘记释放 Lock 是非常危险的，因为当程序的控制权离开了守护的块时，不会自动清除锁。 1.1 可轮询的和可定时的锁请求 可定时的与可轮询的锁获取模式是由 tryLock() 方法实现的，与无条件的锁获取模式相比，它具有更完善的错误恢复机制。 在内置锁中，死锁是一个严重的问题，恢复程序的唯一方法是重新启动程序，而防止死锁的唯一方法就是在构造过程时避免不一致的锁顺序。 可定时的与可轮询的锁提供了另一种选择：避免死锁的发生。 ​ 在第10章，有这样一个例子：转账 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.util.concurrent.atomic.AtomicInteger;public class DynamicOrderDeadlock { // Warning: 容易产生死锁 public static void transferMoney(Account fromAccount, Account toAccount, DollarAmount amount) throws InsufficientFundsException { // 获得【借出钱】锁 synchronized (fromAccount) { // 获得【去借钱】锁 synchronized (toAccount) { // 如果【借出钱】的人账户 amount 没这么多钱，那么就抛出【资金不足】Exception if (fromAccount.getBalance().compareTo(amount) &lt; 0) { throw new InsufficientFundsException(); } else { // 资金充足，交易完成 fromAccount.debit(amount); toAccount.credit(amount); } } } } static class DollarAmount implements Comparable&lt;DollarAmount&gt; { private int amount = 0; public DollarAmount(int amount) { this.amount = amount; } /** 增加 */ public DollarAmount add(DollarAmount d) { this.amount = this.amount + d.amount; return this; } /** 减少 */ public DollarAmount subtract(DollarAmount d) { this.amount = this.amount - d.amount; return this; } /** -1, 0, 1 ---- 小于，等于，大于 */ public int compareTo(DollarAmount dollarAmount) { return Integer.compare(this.amount, dollarAmount.amount); } public int getAmount() { return amount; } } static class Account { private DollarAmount balance; private final int acctNo; private static final AtomicInteger sequence = new AtomicInteger(); public Account() { acctNo = sequence.incrementAndGet(); } /** 将钱借出 */ void debit(DollarAmount d) { balance = balance.subtract(d); } /** 去借钱 */ void credit(DollarAmount d) { balance = balance.add(d); } DollarAmount getBalance() { return balance; } public void setBalance(DollarAmount balance) { this.balance = balance; } int getAcctNo() { return acctNo; } } static class InsufficientFundsException extends Exception { }} 对于使用内置锁 synchronized 的 transferMoney() 方法： 如果【线程A】获取了 Account1 的锁，向 Account2 转账。 而【线程B】又获取了 Account2 的锁，向 Account1 转账。 那么就会出现【线程A】等待 Account2 的锁，【线程B】等待 Account1 的锁 —- 线程死锁 轮询锁：通过 tryLock 来避免锁顺序死锁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.util.Random;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import static java.util.concurrent.TimeUnit.NANOSECONDS;public class DeadlockAvoidance { private static Random rnd = new Random(); public boolean transferMoney(Account fromAccount, Account toAccount, DollarAmount amount, long timeout, TimeUnit unit) throws InsufficientFundsException, InterruptedException { long fixedDelay = getFixedDelayComponentNanos(timeout, unit); long randMod = getRandomDelayModulusNanos(timeout, unit); long stopTime = System.nanoTime() + unit.toNanos(timeout); while (true) { // 尝试获得【借出钱】锁 if (fromAccount.lock.tryLock()) { try { // 尝试获得【去借钱】锁 if (toAccount.lock.tryLock()) { try { // 如果【借出钱】的人账户 amount 没这么多钱，那么就抛出【资金不足】Exception if (fromAccount.getBalance().compareTo(amount) &lt; 0) { throw new InsufficientFundsException(); } else { // 资金充足，交易完成 fromAccount.debit(amount); toAccount.credit(amount); return true; } } finally { // 释放【去借钱】锁 toAccount.lock.unlock(); } } } finally { // 释放【借出钱】锁 fromAccount.lock.unlock(); } } if (System.nanoTime() &lt; stopTime) { return false; } NANOSECONDS.sleep(fixedDelay + rnd.nextLong() % randMod); } } private static final int DELAY_FIXED = 1; private static final int DELAY_RANDOM = 2; /** 固定延迟 */ static long getFixedDelayComponentNanos(long timeout, TimeUnit unit) { return DELAY_FIXED; } /** 随机延迟 */ static long getRandomDelayModulusNanos(long timeout, TimeUnit unit) { return DELAY_RANDOM; } static class DollarAmount implements Comparable&lt;DollarAmount&gt; { public int compareTo(DollarAmount other) { return 0; } DollarAmount(int dollars) { } } class Account { public Lock lock; void debit(DollarAmount d) { } void credit(DollarAmount d) { } DollarAmount getBalance() { return null; } } class InsufficientFundsException extends Exception { }} 定时锁 1234567891011121314151617181920212223242526272829303132import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import static java.util.concurrent.TimeUnit.NANOSECONDS;public class TimedLocking { private Lock lock = new ReentrantLock(); public boolean trySendOnSharedLine(String message, long timeout, TimeUnit unit) throws InterruptedException { long nanosToLock = unit.toNanos(timeout) - estimatedNanosToSend(message); // 规定时间内获取不到 lock，return false if (!lock.tryLock(nanosToLock, NANOSECONDS)) { return false; } try { return sendOnSharedLine(message); } finally { lock.unlock(); } } private boolean sendOnSharedLine(String message) { /* send something */ return true; } long estimatedNanosToSend(String message) { return message.length(); }} 1.2 可中断的锁获取操作 正如定时锁的获得操作允许在限时活动内部使用独古锁，可中断的锁获取操作允许在可取消的活动中使用。 lockInterruptible() 方法能够在获得锁的同时保持对中断的响应，并且由于它包含在Lock中，因此无需创建其他类型的不可中断阻塞机制。 1234567891011121314151617181920212223import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** 可中断的锁获取请求 */public class InterruptibleLocking { private Lock lock = new ReentrantLock(); public boolean sendOnSharedLine(String message) throws InterruptedException { lock.lockInterruptibly(); try { return cancellableSendOnSharedLine(message); } finally { lock.unlock(); } } private boolean cancellableSendOnSharedLine(String message) throws InterruptedException { /* send something */ return true; }} 1.3 非块结构的锁 在内置锁(synchronized)中，锁的获取和释放都是基于使用内置锁的代码块的，并不用考虑内置锁对代码块的控制权是如何退出的。 虽然自动释放锁简化了程序的分析，并且避免了潜在的代码错误造成的麻烦，但是有时候需要更灵活的加锁规则。Lock就是这样一个可定制化的锁。 2. 对性能的考量 显式锁 ReentrantLock 要比内置锁 synchronized 提供更好的竞争性能。 对于锁守护的程序而言，发生锁竞争时，程序的性能是可伸缩性的关键。 :label:可伸缩性指的是：当增加计算资源的时候（比如增加额外 CPU 数量、内存、存储器、TO 带宽)，吞吐量和生产量能够相应地得以改进。 如果很多资源都花费在锁的管理和调度上，那么留给程序的就会越少。 锁的实现越好，那么上下文切换会更少，在共享内存总线上发起的内存同步通信也会更少。 3. 公平性ReentrantLock 构造函数： 123456789101112/** 创建ReentrantLock的实例。这相当于使用ReentrantLock(false) */public ReentrantLock() { sync = new NonfairSync();}/** * 使用给定的公平策略创建ReentrantLock的实例 * @param fair 如果此锁应使用公平排序策略，则为true */public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync();} 在公平的锁上，线程将按照它们发出请求的顺序来获得锁(对于公平锁而言，可轮询的tryLock总会闯入) 在非公平的锁上，则允许”插队“：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁。 公平的锁，在线程挂起和线程恢复时(上下文切换)，存在的开销，会极大的降低程序性能。 非公平的锁，允许线程在其它线程的恢复阶段进入加锁代码块。 如果持有锁的时间相对较长，或者请求锁的平均时间将额较长，那么推荐使用公平锁。 内置锁 synchronized 没有提供确定的公平性保证。 4. 在 synchronized 和 ReentrantLock 之间进行选择 ReentrantLock ReentrantLock 功能性方面更全面，具有更强的扩展性 ReentrantLock 提供了 Condition，对线程的等待和唤醒等操作更加灵活。一个 ReentrantLock 能够有多个 Condition 实例。 1234/** 返回与此Lock实例一起使用的Condition实例 */public Condition newCondition() { return sync.newCondition();} ReentrantLock 可以控制线程得到锁的顺序(公平锁、非公平锁) – fair ReentrantLock 可以查看锁的状态、等待锁的线程数。可以响应中断(lockInterruptibly)。 ReentrantLock 提供了可轮询的锁请求(tryLock) 在获取 ReentrantLock 时，可以设置超时时间。 ReentrantLock是显式锁，需要手动释放锁，忘记释放后果非常严重。 synchronized synchronized 是在JVM层面上实现的，能够通过一些监控工具监控synchronized的锁定。 synchronized 能够在代码块执行完成或异常退出时自动释放锁。 被 synchronized 保护的代码块，一旦被线程获取锁，如果不释放，别的线程要获取该锁，会一直长时间的等待，不能被中断。 5. 读-写锁一个资源可以被多个读操作访问，或者被一个写操作访问，读-写 两者不能同时进行。ReadWriteLock 实现的加锁策略允许多个同时存在的读者，但是只允许一个写者。 读写锁的可选实现： 释放优先。写入锁释放后，应该优先选择读线程，写线程，还是最先发出请求的线程 读线程插队。锁由读线程持有，写线程在等待，再来一个读线程，是继续让读线程访问，还是让写线程访问 重入性。读取锁和写入锁是否可重入 降级。将写入锁降级为读取锁 升级。将读取锁升级为写入锁 用读写锁包裝的 Map 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.Map;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class ReadWriteMap &lt;K,V&gt; { private final Map&lt;K, V&gt; map; private final ReadWriteLock lock = new ReentrantReadWriteLock(); private final Lock readLock = lock.readLock(); private final Lock writeLock = lock.writeLock(); public ReadWriteMap(Map&lt;K, V&gt; map) { this.map = map; } public V put(K key, V value) { writeLock.lock(); try { return map.put(key, value); } finally { writeLock.unlock(); } } public V remove(Object key) { writeLock.lock(); try { return map.remove(key); } finally { writeLock.unlock(); } } public void putAll(Map&lt;? extends K, ? extends V&gt; m) { writeLock.lock(); try { map.putAll(m); } finally { writeLock.unlock(); } } public void clear() { writeLock.lock(); try { map.clear(); } finally { writeLock.unlock(); } } public V get(Object key) { readLock.lock(); try { return map.get(key); } finally { readLock.unlock(); } } public int size() { readLock.lock(); try { return map.size(); } finally { readLock.unlock(); } } public boolean isEmpty() { readLock.lock(); try { return map.isEmpty(); } finally { readLock.unlock(); } } public boolean containsKey(Object key) { readLock.lock(); try { return map.containsKey(key); } finally { readLock.unlock(); } } public boolean containsValue(Object value) { readLock.lock(); try { return map.containsValue(value); } finally { readLock.unlock(); } }}","link":"/posts/46d8.html"},{"title":"Java并发编程实战：第14章 总结","text":"使用 Object 超类中的 wait()、notify()、notifyAll()等方法管理条件队列 如果说 Lock 是显式的 Synchroinzed，那么也可以认为 Condition 也是一种显式的条件队列 —- Condition 提供了类似 wait()、notify()、notifyAll() 且更全面的方法 AbstractQueuedSynchronizer(AQS)：提供一个框架来实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关的同步器（信号量、事件等） ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 和 FutureTask 都是基于 AQS 构建的 显式的 Condition 是与显式的 Lock 是紧密地绑定到一起的，相比于内部条件队列，它还提供了一个可扩展的特征集，包括“多 wait 每 lock”，可中断或不可中断的条件等待，公平或非公平的队列，以及基于最终时限的等待。","link":"/posts/483b.html"},{"title":"Java并发编程实战：第15章 总结","text":"比较并交换(compare-and-swap)：当多个线程试图使用比较并交换(CAS)，同时更新相同的变量时，其中一个线程会胜出，并且更新变量的值，而其它的线程都会失败。失败的线程允许尝试再次比较并交换操作。一个线程在竞争 CAS 时失败，不会被阻塞，它可以决定是否重试，这样的灵活性大大减少了锁相关的活跃度风险。 原子变量类，提供了广义的 volatile 变量，以支持原子的、条件的读-写-改操作。原子变量是“更佳的volatile” 原子变量比锁更精巧，更轻量，并且在多处理器系统中，对实现高性能的并发代码非常关键。在使用原子变量取代锁的算法中，线程更不易出现延迟，如果它们遇到竟争，也更容易恢复。 锁与原子化随竞争度的不同，性能发生的改变阐明了各自的优势和劣势。在中低程度的竞争下，原子化提供更好的可伸缩性；在高强度的竞争下，锁能够更好地帮助我们避免竞争。 非阻塞(nonblocking)算法：一个线程的失败或挂起不应该影响其他线程的失败或挂起 锁自由(lock-frce)算法：如果算法的每一步骤中都有一些线程能够继续执行，那么这样的算法称为锁自由算法。 本章还介绍了非阻塞链表、非阻塞栈两个经典例子。","link":"/posts/b43f.html"},{"title":"Java并发编程实战：第16章 存储模型","text":"1. 什么是存储模型，要它何用1value = 100 在多线程环境中，要获取到 value 的正确值，需要用到同步。 编译器生成指令的次序，可以不同于源代码的所暗示的”显然”版本，而且编译器还会把变量存储在寄存器，而不是内存中； 处理器可以乱序或者并发的执行指令； 缓存会改变写入提交到主内存的变量的次序； 存储在处理器本地缓存中的值，对于其它处理器并不可见。 这些因素都会妨碍一个线程看到一个变量的最新值，而且会引起内存活动在不同线程在表现出不同的发生次序。 指令重排序是的程序在计算性能上得到了很大的提升。在多线程环境中，为了维护正确的顺序性不得不产生很大的性能开销。因为在大部分时间里，同步的应用程序中的线程都在做属于自己的工作，额外的线程间协调只会降低程序的运行效率，不会带来任何好处。只有当多个线程要共享数据时，才必须协调它们的活动；协调是通过使用同步完成的，JVM依赖于程序明确地指出何时需要协调线程的活动。JMM规定了JVM必须遵循一组最小保证，这组保证规定了对变量的写入操作在何时将对其他线程可见。 1.1 平台的存储模型每个处理器都拥有自己的缓存，并且定期地与主内存进行协调，在不同的处理器架构中提供了不同级别的缓存一致性，即允许不同的处理器在任意时刻从同一个存储位置上看到不同的值。JVM通过在适当的位置上插入内存栅栏来屏蔽在JMM与底层平台内存模型之间的差异。Java程序不需要指定内存栅栏的位置，而只需通过正确地使用同步来找出何时将访问共享状态。 1.2 重排序各种能够引起操作延迟或者错续执行的不同原因，都可以归结为一类重拌序(reordering)。 没有充分同步的程序 123456789101112131415161718192021222324public class PossibleReordering { static int x = 0, y = 0; static int a = 0, b = 0; public static void main(String[] args) throws InterruptedException { Thread one = new Thread(new Runnable() { public void run() { a = 1; x = b; } }); Thread other = new Thread(new Runnable() { public void run() { b = 1; y = a; } }); one.start(); other.start(); one.join(); other.join(); System.out.println(&quot;(&quot; + x + &quot;,&quot; + y + &quot;)&quot;); }} 线程A可以在B开始前完成，B也可以在A开始前完成。可能会打印出 (1,0)、(0,1)、(1,1)。这只是一个极为简单的程序，不过可能的结果却有好几个。内存级的重排序会让程序的行为变得不可预期。没有同步，推断执行次序的难度令人望而却步。同步抑制了编译器、运行时和硬件对存储操作的各种方式的重排序，否则这些重排序将会破坏 JMM 提供的可见性保证。 1.3 java 存储模型的简介 Java 存储模型的定义是通过动作(actions)的形式进行描述的，所调动作，包括变量的读和写、监视器加锁和释放锁、线程的启动和拼接(join)。 JMM为程序中所有的操作定义了一个偏序关系，称为Happens-Before，使在正确同步的程序中不存在数据竞争（缺乏Happens-Before关系，那么JVM可以对它们任意地重排序）。 Happens-Before 的法则包括： 程序顺序规则。如果程序中操作A在操作B之前，那么在线程中A操作将在B操作之前执行 监视器锁规则。在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行。（显式锁和内置锁在加锁和解锁等操作上有着相同的内存语义） volatile变量规则。对volatile变量的写入操作必须在对该变量的读操作之前执行。（原子变量与volatile变量在读操作和写操作上有着相同的语义） 线程启动规则。在线程上对Thread.start的调用必须在该线程中执行任何操作之前执行 线程结束规则。线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从Thread.join中成功返回，或者在调用Thread.isAlive时返回false 中断规则。当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt调用之前执行（通过抛出InterruptException，或者调用isInterrupted和interrupted） 终结器规则。对象的构造函数必须在启动该对象的终结器之前执行完成 传递性。如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行。 两个线程同步使用一个公共锁时： 线程A内部的所有动作都是依照“程序次序法则” 进行排序的。线程B的内部动作也一样。因为A释放了锁 M，B随后获得了锁M，A中的所有释放锁之前的动作，也就因此排到了B中请求到锁后动作的前面。 2. 发布造成不正确发布的真正原因：”发布一个共享对象”与”另一个线程访问该对象”之间缺少一种 Happens-Before 的关系。 2.1 不安全的发布在缺少 happens-before 关系的情况下，存在重排序的可能性。 在没有充分同步的情况下就发布一个对象，会导致另外的线程看到一个部分创建对象。新对象的初始化涉及到写入变量(新对象的域)。引用的发布涉及到写入另一个变量(新对象的引用)，那么写入新对鞋的引用与写入对象域可以被重排序。 不安全的惰性初始化 12345678910111213141516import net.jcip.annotations.NotThreadSafe;@NotThreadSafepublic class UnsafeLazyInitialization { private static Resource resource; public static Resource getInstance() { if (resource == null) { resource = new Resource(); // 不安全的发布 } return resource; } static class Resource { }} 假设第一次调用 getInstance 的是线程A。它会看到 resource 是 null，接着初始化一个新的 Resource，然后设置 resource 引用这个新实例。随后线程B调用 getInstance，它可能看到 resource 已经有了一个非空的值，于是就使用这个已经创建的 Resource。发布对象时存在数据竞争，因此B并不能保证可以看到 Resource 的正确状态。 除了不可变对象以外，使用被另一个线程初始化的对象，是不安全的，除非对象的发布是 happens-before 于对象的消费线程使用它。 2.2 安全发布BlockingQueue的同步机制保证put在take后执行，A线程放入对象能保证B线程取出时是安全的。 借助于类库中现在的同步容器、使用锁保护共享变量、或都使用共享的volatile类型变量，都可以保证对该变量的读取和写入是按照happens-before排序的。 happens-before事实上可以比安全发布承诺更强的可见性与排序性。 2.3 安全初始化技巧 主动初始化 12345678910111213import net.jcip.annotations.ThreadSafe;@ThreadSafepublic class EagerInitialization { private static Resource resource = new Resource(); public static Resource getResource() { return resource; } static class Resource { }} 惰性初始化 holder 类技巧 123456789101112131415import net.jcip.annotations.ThreadSafe;@ThreadSafepublic class ResourceFactory { private static class ResourceHolder { public static Resource resource = new Resource(); } public static Resource getResource() { return ResourceHolder.resource; } static class Resource { }} 2.4 双检查锁(double-checked locking) 双检查锁反模式 1234567891011121314151617181920import net.jcip.annotations.NotThreadSafe;@NotThreadSafepublic class DoubleCheckedLocking { private static Resource resource; public static Resource getInstance() { if (resource == null) { synchronized (DoubleCheckedLocking.class) { if (resource == null) resource = new Resource(); } } return resource; } static class Resource { }} 3. 初始化安全性 如果能确保初始化过程的安全性，被正确构造的不可变对象在没有同步的情况下也能安全地在多个线程之间共享 如果不能确保初始化的安全性，一些本应为不可变对象的值将会发生改变 初始化安全性只能保证通过final域可达的值从构造过程完成时可见性。对于通过非final域可达的值，或者在构成过程完成后可能改变的值，必须采用同步来确保可见性.","link":"/posts/e71d.html"},{"title":"Java并发编程实战：第16章 总结","text":"Java 存储模型明确地规定了在什么时机下，操作存储器的线程的动作可以保证被另外的动作看到。 规范还规定了要保证操作是按照一种偏序关系进行排序。这种关系称为 happens-before，它是规定在独立存储器和同步操作的级别之上的。 如果缺少充足的同步，线程在访问共享数据时就会发生非常无法预期的事情.","link":"/posts/f030.html"},{"title":"Java并发编程实战：第1章 简介","text":"下载资源 jar；https://repo1.maven.org/maven2/org/lucee/jcip-annotations/1.0.0/jcip-annotations-1.0.0.jar 添加 jar 到程序中 1. 线程不安全多个线程中的操作执行顺序是不可预测的 非线程安全的序列生成器 123456789101112@NotThreadSafeclass UnsafeSequence { private int value; public UnsafeSequence(int value) { this.value = value; } public int next() { return this.value++; }} 创建3个线程进行测试： 123456789101112131415161718192021222324252627282930public class UnsafeSequenceDemo { public static void main(String[] args) { UnsafeSequence unsafeSequence = new UnsafeSequence(100); MyThread thread = new MyThread(unsafeSequence); Thread myThread1 = new Thread(thread, &quot;线程1&quot;); Thread myThread2 = new Thread(thread, &quot;线程2&quot;); Thread myThread3 = new Thread(thread, &quot;线程3&quot;); myThread1.start(); myThread2.start(); myThread3.start(); }}class MyThread implements Runnable { private UnsafeSequence unsafeSequence; public MyThread(UnsafeSequence unsafeSequence) { this.unsafeSequence = unsafeSequence; } @Override public void run() { // print System.out.println(Thread.currentThread().getName() + &quot;------------------ &quot; + unsafeSequence.next() + &quot; ------------------&quot;); }} output: 123线程2------------------ 100 ------------------线程1------------------ 100 ------------------线程3------------------ 101 ------------------ 原因分析，可能情况： 线程2 启动，value=100 进行输出 100 线程1 启动，value=100 进行输出 100 线程2 value++，value=101 线程3 启动，value=101 进行输出 101 线程1、线程3 也进行 value++，value=103 2. 线程安全线程安全的数值序列生成器 12345678910111213@ThreadSafeclass Sequence { @GuardedBy(&quot;this&quot;) private int value; public Sequence(int value) { this.value = value; } public synchronized int next() { return this.value++; }} 创建3个线程进行测试： 1234567891011121314151617181920212223242526272829public class SequenceDemo { public static void main(String[] args) { Sequence sequence = new Sequence(100); MeThread thread = new MeThread(sequence); Thread meThread1 = new Thread(thread, &quot;线程1&quot;); Thread meThread2 = new Thread(thread, &quot;线程2&quot;); Thread meThread3 = new Thread(thread, &quot;线程3&quot;); meThread1.start(); meThread2.start(); meThread3.start(); }}class MeThread implements Runnable { private Sequence sequence; public MeThread(Sequence sequence) { this.sequence = sequence; } @Override public void run() { // print System.out.println(Thread.currentThread().getName() + &quot;------------------ &quot; + sequence.next() + &quot; ------------------&quot;); }} output： 123线程1------------------ 100 ------------------线程2------------------ 101 ------------------线程3------------------ 102 ------------------","link":"/posts/5adb.html"},{"title":"Java并发编程实战：第6章 总结","text":"围绕任务的执行来构造应用程序，可以简化开发，便于同步。 Executor框架有助于我们在任务的提交与任务的执行策略之间进行解耦，同时还支持很多不同类型的执行策略。 为执行任务而创建线程时，可以考虑使用Executor取代以前的方法。 把应用程序分解为不同的任务，需要明确任务边界。如服务端接口，任务边界可能是用户（一用户，一任务）。","link":"/posts/d7d5.html"},{"title":"Java并发编程实战：第7章 总结","text":"任务、线程、服务以及应用程序在生命周期结束时的问题，可能会导致向它们引入复杂的设计和实现。 Java 没有提供具有明显优势的机制来取消活动或者终结线程。 Java 提供了协作的中断机制，能够用来帮助取消，但是这将取决你如何构建取消的协议，并是否能一致地使用该协议。 使用 FutureTask 和 Executor 框架可以简化构建可取消的任务和服务。","link":"/posts/2bd1.html"},{"title":"Java并发编程实战：第8章 总结","text":"对于并发执行的任务，Executor 框架是强大且灵活的。 ThreadPoolExecutor 提供了大量可调节的选项，比如创建和关闭线程的策略，处理队列任务的策略，处理过剩任务的策略，并且提供了几个钩子函数用于扩展它的行为。 钩子函数：terminated()、afteExecute()、beforeExecute() ThreadPoolExecutor 和大多数强大的框架一样，草率地将一些设定组合在一起，并不能很好地工作：一些类型的任务需要特定的执行第略，而一些调节参数组合在一起后可能产生意外的结果。 中止(Abort)策略 抛弃最旧的(Discard-Oldest)策略 调用者运行(Caller-Runs)策略","link":"/posts/3fe1.html"},{"title":"Java并发编程实战：第9章 GUI应用程序","text":"1. GUI 应用程序 几乎所有的GUI工具集都是单线程化的子系统，意味着所有GUI的活动都被限制在一个单独的线程中。 我们应该避免在事件线程中执行耗时操作，以免UI失去响应。 Swing 的数据结构不是线程安全的，所以在使用它时必须小心的把他们限制在事件线程中。 2. 为什么 GUI 是单线程化的 早期的 GUI 应用程序是单线程化的，GUI事件在 “主事件循环” 进行处理。 现代的GUI框架使用了一个略微不同的模型：模型创建了一个专门的线程，事件派发线程(event dispatch thread， EDT) 来处理 GUI 事件。 2.1 顺序时间处理 GUI 应用程序总要去处理精细的事件，比如点击鼠标、按下键盘或者定时器到时等等。 因为只有唯一的一个线程在处理 GUI 任务，所以它会依次处理 GUI 任务。 依次执行任务有些问题是避免不了的。如果一个任务执行要花费的时间长，其他任务也要等到它结束。 2.2 Swing 中的线程限制 所有的 Swing 组件（比如 JButton 和 JTable) 和数据模型（比如 TableModel 和 TreeModel）都被限制于事件线程中，所以任何访问它们的代码必须在事件线程中运行。 GUI 对象不用同步，仅仅依靠线程限制来保持一致性。 优点：运行于事件线程的任务，在访问表现对象(presentation objects）时不必担心同步的问题。 缺点：完全无法从事件线程之外的地方访问表现对象。 Swing 的单线程规则：Swing 的组件和模型只能在事件分派线程中被创建、修改和请求。 有非常少量的的 Swing 方法可以安全地被任意线程调用： 12345SwingUtilities.isEventDispatchThread();SwingUtilities.invokeLater();SwingUtities.invokeAndWait(); 2. 短期的 GUI 任务 在 GUI 应用程序中，事件起源于事件线程，冒泡似的传递到达应用程序提供的监听器，监听器进而可能会执行一些影响表现模型的运算。 为了简单起见，短期的任务可以把全部动作留在事件线程中完成；而对于耗时的任务，则应该将一些工作负荷分压到另一个线程中。 使用 Executor 实现的 SwingUtilities 123456789101112131415161718192021222324252627282930313233343536import java.lang.reflect.InvocationTargetException;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.ThreadFactory;public class SwingUtilities { private static final ExecutorService exec = Executors.newSingleThreadExecutor(new SwingThreadFactory()); private static volatile Thread swingThread; private static class SwingThreadFactory implements ThreadFactory { public Thread newThread(Runnable r) { swingThread = new Thread(r); return swingThread; } } public static boolean isEventDispatchThread() { return Thread.currentThread() == swingThread; } public static void invokeLater(Runnable task) { exec.execute(task); } public static void invokeAndWait(Runnable task) throws InterruptedException, InvocationTargetException { Future&lt;?&gt; f = exec.submit(task); try { f.get(); } catch (ExecutionException e) { throw new InvocationTargetException(e); } }} 构建于 SwingUtilities 之伤的 Executor 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.List;import java.util.concurrent.AbstractExecutorService;import java.util.concurrent.TimeUnit;public class GuiExecutor extends AbstractExecutorService { // Singleton 包含一个私有的构造函數和一个公共的工厂 private static final GuiExecutor instance = new GuiExecutor(); private GuiExecutor() { } public static GuiExecutor instance() { return instance; } public void execute(Runnable r) { if (SwingUtilities.isEventDispatchThread()) { r.run(); } else { SwingUtilities.invokeLater(r); } } public void shutdown() { throw new UnsupportedOperationException(); } public List&lt;Runnable&gt; shutdownNow() { throw new UnsupportedOperationException(); } public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException { throw new UnsupportedOperationException(); } public boolean isShutdown() { return false; } public boolean isTerminated() { return false; }} 简单的时间监听器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import javax.swing.JButton;import javax.swing.JLabel;import java.awt.Color;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.util.Random;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class ListenerExamples { private static final ExecutorService EXEC = Executors.newCachedThreadPool(); private final JButton colorButton = new JButton(&quot;Change color&quot;); private final Random random = new Random(); private void backgroundRandom() { // 用于接收动作事件的监听器 colorButton.addActionListener(new ActionListener() { // 发生动作时调用 public void actionPerformed(ActionEvent e) { colorButton.setBackground(new Color(random.nextInt())); } }); } private final JButton computeButton = new JButton(&quot;Big computation&quot;); private void longRunningTask() { // 用于接收动作事件的监听器 computeButton.addActionListener(new ActionListener() { // 发生动作时调用 public void actionPerformed(ActionEvent e) { EXEC.execute(new Runnable() { public void run() { /* 耗时运算 */ } }); } }); } private final JButton button = new JButton(&quot;Do&quot;); private final JLabel label = new JLabel(&quot;idle&quot;); /** 提供用户反馈的耗时任务 */ private void longRunningTaskWithFeedback() { // 用于接收动作事件的监听器 button.addActionListener(new ActionListener() { // 发生动作时调用 public void actionPerformed(ActionEvent e) { button.setEnabled(false); label.setText(&quot;busy&quot;); EXEC.execute(new Runnable() { public void run() { try { /* 耗时运算 */ } finally { GuiExecutor.instance().execute(new Runnable() { public void run() { button.setEnabled(true); label.setText(&quot;idle&quot;); } }); } } }); } }); } private final JButton startButton = new JButton(&quot;Start&quot;); private final JButton cancelButton = new JButton(&quot;Cancel&quot;); private Future&lt;?&gt; runningTask = null; /** 取消耗时任务 */ private void taskWithCancellation() { // 用于接收动作事件的监听器 startButton.addActionListener(new ActionListener() { // 发生动作时调用 public void actionPerformed(ActionEvent e) { if (runningTask != null) { runningTask = EXEC.submit(new Runnable() { public void run() { while (moreWork()) { if (Thread.currentThread().isInterrupted()) { cleanUpPartialWork(); break; } doSomeWork(); } } private boolean moreWork() { return false; } private void cleanUpPartialWork() { } private void doSomeWork() { /* do something */ } }); } ; } }); // 用于接收动作事件的监听器 cancelButton.addActionListener(new ActionListener() { // 发生动作时调用 public void actionPerformed(ActionEvent event) { if (runningTask != null) { runningTask.cancel(true); } } }); } /** 在 BackgroundTask 中启动一个耗时的、可取消的任务 */ private void runInBackground(final Runnable task) { // 用于接收动作事件的监听器 startButton.addActionListener(new ActionListener() { // 发生动作时调用 public void actionPerformed(ActionEvent e) { class CancelListener implements ActionListener { BackgroundTask&lt;?&gt; task; public void actionPerformed(ActionEvent event) { if (task != null) { task.cancel(true); } } } final CancelListener listener = new CancelListener(); listener.task = new BackgroundTask&lt;Void&gt;() { public Void compute() { while (moreWork() &amp;&amp; !isCancelled()) { doSomeWork(); } return null; } private boolean moreWork() { return false; } private void doSomeWork() { } public void onCompletion(boolean cancelled, String s, Throwable exception) { cancelButton.removeActionListener(listener); label.setText(&quot;done&quot;); } }; cancelButton.addActionListener(listener); EXEC.execute(task); } }); }} 这里用到了 【3. 共享数据模型】 中的 Demo 3. 共享数据模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.concurrent.Callable;import java.util.concurrent.CancellationException;import java.util.concurrent.ExecutionException;import java.util.concurrent.Future;import java.util.concurrent.FutureTask;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;public abstract class BackgroundTask &lt;V&gt; implements Runnable, Future&lt;V&gt; { private final FutureTask&lt;V&gt; computation = new Computation(); /** 计算 task */ private class Computation extends FutureTask&lt;V&gt; { public Computation() { // 创建一个 task，该 FutureTask.get() 返回 BackgroundTask.compute() 方法的计算结果 super(new Callable&lt;V&gt;() { public V call() throws Exception { return BackgroundTask.this.compute(); } }); } /** 当此任务转换到状态 isDone 时调用 */ protected final void done() { // GuiExecutor 实例获取计算结果 GuiExecutor.instance().execute(new Runnable() { public void run() { V value = null; Throwable thrown = null; boolean cancelled = false; try { value = BackgroundTask.this.get(); } catch (ExecutionException e) { thrown = e.getCause(); } catch (CancellationException e) { cancelled = true; } catch (InterruptedException consumed) { } finally { // 在事件线程中调用 onCompletion(value, thrown, cancelled); } }; }); } } // 在后台线程中调用 protected abstract V compute() throws Exception; // 在事件线程中调用 protected void onCompletion(V result, Throwable exception, boolean cancelled) { } protected void onProgress(int current, int max) { } public boolean cancel(boolean mayInterruptIfRunning) { return computation.cancel(mayInterruptIfRunning); } public V get() throws InterruptedException, ExecutionException { return computation.get(); } public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { return computation.get(timeout, unit); } public boolean isCancelled() { return computation.isCancelled(); } public boolean isDone() { return computation.isDone(); } public void run() { computation.run(); }} 4. 其他形式的单线程子系统线程限制不仅仅限制在 GUI 系统。无论何时，线程限制都可以用作实现单线程化子系统的便利工具。 对避免同步与死锁束手无策的时候，使用线程限制成为了我们不得不使用的办法。 比如，一些原生库(native librarie）要求所有对库的访问，甚至 System.LoadLibrary 加载库时，必须在同一个线程中运行。","link":"/posts/97b4.html"},{"title":"Java并发编程实战：第9章 总结","text":"GUI框架几乎都是作为单线程化子系统实现的，所有与表现相关的代码都作为任务在一个事件线程中运行。 因为只有唯一一个线程，耗时任务会损害响应性，所以它们应该在后台线程中运行。 像 SwingWorker 以及本章中构建 BackgroundTask 这些助手类，提供了对取消、进度指示、完成指示的支持。无论是 GUI 组件还是非 GUI 组件，都能借助它们简化耗时任务的开发。","link":"/posts/c3e5.html"},{"title":"Java并发编程实战：第10章 活跃度,性能和测试","text":"1. 死锁1.1 死锁 哲学家进餐问题 这里有 5 个哲学家，以及 5 根筷子。 如果每个人都拿起左边的筷子，等待右侧筷子可用，同时不放弃手中的筷子，将导致死锁产生。 当一个线程永远占有有一个锁，而其它线程尝试去占有这个锁，那么它们将永远被阻塞。 1.2 锁顺序死锁 简单的顺序死锁 1234567891011121314151617181920212223242526public class LeftRightDeadlock { private final Object left = new Object(); private final Object right = new Object(); public void leftRight() { synchronized (left) { synchronized (right) { doSomething(); } } } public void rightLeft() { synchronized (right) { synchronized (left) { doSomethingElse(); } } } void doSomething() { } void doSomethingElse() { }} 对于 A、B 两个线程，分别锁住 left、right。 这个时候 A 线程想获取 right，B 线程想获取 left 锁 A 线程获取不到 right，因为已经被 B 线程锁住 同样 B 线程也获取不到 left，因为 left 已经被 A 线程锁住 如果所有的线程能够以固定的秩序获取锁，程序就不会出现锁顺序锁死了。 1.3 动态的锁顺序死锁动态的锁顺序死锁是指两个线程调用同一个方法时，传入的参数颠倒造成的死锁。 有时候我们并不能一目了然地看清是否己经对锁有足够的控制，来避免死锁的发生。 动态加锁顺序产生的死锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.util.concurrent.atomic.AtomicInteger;public class DynamicOrderDeadlock { // Warning: 容易产生死锁 public static void transferMoney(Account fromAccount, Account toAccount, DollarAmount amount) throws InsufficientFundsException { // 获得【借出钱】锁 synchronized (fromAccount) { // 获得【去借钱】锁 synchronized (toAccount) { // 如果【借出钱】的人账户 amount 没这么多钱，那么就抛出【资金不足】Exception if (fromAccount.getBalance().compareTo(amount) &lt; 0) throw new InsufficientFundsException(); else { // 资金充足，交易完成 fromAccount.debit(amount); toAccount.credit(amount); } } } } static class DollarAmount implements Comparable&lt;DollarAmount&gt; { private int amount = 0; public DollarAmount(int amount) { this.amount = amount; } /** 增加 */ public DollarAmount add(DollarAmount d) { this.amount = this.amount + d.amount; return this; } /** 减少 */ public DollarAmount subtract(DollarAmount d) { this.amount = this.amount - d.amount; return this; } /** -1, 0, 1 ---- 小于，等于，大于 */ public int compareTo(DollarAmount dollarAmount) { return Integer.compare(this.amount, dollarAmount.amount); } public int getAmount() { return amount; } } static class Account { private DollarAmount balance; private final int acctNo; private static final AtomicInteger sequence = new AtomicInteger(); public Account() { acctNo = sequence.incrementAndGet(); } /** 将钱借出 */ void debit(DollarAmount d) { balance = balance.subtract(d); } /** 去借钱 */ void credit(DollarAmount d) { balance = balance.add(d); } DollarAmount getBalance() { return balance; } public void setBalance(DollarAmount balance) { this.balance = balance; } int getAcctNo() { return acctNo; } } static class InsufficientFundsException extends Exception { }} 如果两个线程同时调用 transferMoney()，一个从 X 向 Y 转账，另一个从 Y 向 X 转账，那么就会发生死锁： 1234// thread_atransferMoney(myAccount, yourAccount, 10);// thread_btransferMoney(yourAccount, myAccount, 20); 在偶发的时序中，thread_a 会获得 myAccount 的锁,并等待 yourAccount 的锁，然而 B 此时持有 yourAccount 的锁,正在等待 myAccount 的锁。 如何避免着清情况的死锁问题 解决办法：通过制定锁的顾序来避免死锁。 在制定锁顺序时，可以使用 System.identityHashCode() 方法，该方法将返回由 Object.hashCode() 返回的值。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import java.util.concurrent.atomic.AtomicInteger;public class InduceLockOrder { private static final Object tieLock = new Object(); public static void transferMoney(final Account fromAcct, final Account toAcct, final DollarAmount amount) throws InsufficientFundsException { class Helper { public void transfer() throws InsufficientFundsException { // 如果【借出钱】的人账户 amount 没这么多钱，那么就抛出【资金不足】Exception if (fromAcct.getBalance().compareTo(amount) &lt; 0) throw new InsufficientFundsException(); else { // 资金充足，交易完成 fromAcct.debit(amount); toAcct.credit(amount); } } } // 【借出钱者】、【借入钱者】分别对应的 Object.hashCode() int fromHash = System.identityHashCode(fromAcct); int toHash = System.identityHashCode(toAcct); // 制定获得锁顺序 if (fromHash &lt; toHash) { synchronized (fromAcct) { synchronized (toAcct) { new Helper().transfer(); } } } else if (fromHash &gt; toHash) { synchronized (toAcct) { synchronized (fromAcct) { new Helper().transfer(); } } } else { synchronized (tieLock) { synchronized (fromAcct) { synchronized (toAcct) { new Helper().transfer(); } } } } } static class DollarAmount implements Comparable&lt;DollarAmount&gt; { private int amount = 0; public DollarAmount(int amount) { this.amount = amount; } /** 增加 */ public DollarAmount add(DollarAmount d) { this.amount = this.amount + d.amount; return this; } /** 减少 */ public DollarAmount subtract(DollarAmount d) { this.amount = this.amount - d.amount; return this; } /** -1, 0, 1 ---- 小于，等于，大于 */ public int compareTo(DollarAmount dollarAmount) { return Integer.compare(this.amount, dollarAmount.amount); } public int getAmount() { return amount; } } static class Account { private DollarAmount balance; private final int acctNo; private static final AtomicInteger sequence = new AtomicInteger(); public Account() { acctNo = sequence.incrementAndGet(); } /** 将钱借出 */ void debit(DollarAmount d) { balance = balance.subtract(d); } /** 去借钱 */ void credit(DollarAmount d) { balance = balance.add(d); } DollarAmount getBalance() { return balance; } public void setBalance(DollarAmount balance) { this.balance = balance; } int getAcctNo() { return acctNo; } } static class InsufficientFundsException extends Exception { }} 开始一个循环，它在典型条件下制定死锁 使用 DynamicOrderDeadlock，容易产生死锁： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Random;public class DemonstrateDeadlock { private static final int NUM_THREADS = 20; private static final int NUM_ACCOUNTS = 5; private static final int NUM_ITERATIONS = 1000000; public static void main(String[] args) { final Random rnd = new Random(); // 五个账户，每个账户先给它两个小目标 $ final DynamicOrderDeadlock.Account[] accounts = new DynamicOrderDeadlock.Account[NUM_ACCOUNTS]; for (int i = 0; i &lt; accounts.length; i++) { DynamicOrderDeadlock.Account account = new DynamicOrderDeadlock.Account(); account.setBalance(new DynamicOrderDeadlock.DollarAmount(200000000)); accounts[i] = account; } class TransferThread extends Thread { public void run() { // 这五个账户之间发生了多笔不可描述的金钱交易 for (int i = 0; i &lt; NUM_ITERATIONS; i++) { // 随机抽取两位幸运儿，发生金钱关系，金额不大于1000 int fromAcct = rnd.nextInt(NUM_ACCOUNTS); int toAcct = rnd.nextInt(NUM_ACCOUNTS); DynamicOrderDeadlock.DollarAmount amount = new DynamicOrderDeadlock.DollarAmount(rnd.nextInt(1000)); try { DynamicOrderDeadlock.transferMoney(accounts[fromAcct], accounts[toAcct], amount); System.out.println(&quot;线程【&quot; + Thread.currentThread().getName() + &quot;】运行第&quot; + i + &quot;次------ &quot; + &quot;账户【&quot; + fromAcct + &quot;】向账户【&quot; + toAcct + &quot;】转账&quot; + amount.getAmount() + &quot;$ ------ &quot; + &quot;账户【&quot; + fromAcct + &quot;】剩下 &quot; + accounts[fromAcct].getBalance().getAmount() + &quot;$ ------ &quot; + &quot;账户【&quot; + toAcct + &quot;】剩下 &quot; + accounts[toAcct].getBalance().getAmount() + &quot;$&quot;); } catch (DynamicOrderDeadlock.InsufficientFundsException ignored) { } } } } // 多线程交易！！！ for (int i = 0; i &lt; NUM_THREADS; i++) { TransferThread transferThread = new TransferThread(); transferThread.start(); } }} Output: 这里它们正常，20个线程，分别都应该发生 1000000 次交易的，不过在前面已经发生了死锁了。非法交易被警察抓了。 开始一个循环，它在制定锁顺序后的条件下，交易成功 使用 InduceLockOrder，笔笔交易完成： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Random;public class DemoInduceLockOrder { private static final int NUM_THREADS = 20; private static final int NUM_ACCOUNTS = 5; private static final int NUM_ITERATIONS = 1000000; public static void main(String[] args) { final Random rnd = new Random(); // 五个账户，每个账户先给它两个小目标 $ final InduceLockOrder.Account[] accounts = new InduceLockOrder.Account[NUM_ACCOUNTS]; for (int i = 0; i &lt; accounts.length; i++) { InduceLockOrder.Account account = new InduceLockOrder.Account(); account.setBalance(new InduceLockOrder.DollarAmount(200000000)); accounts[i] = account; } class TransferThread extends Thread { public void run() { // 这五个账户之间发生了多笔不可描述的金钱交易 for (int i = 0; i &lt; NUM_ITERATIONS; i++) { // 随机抽取两位幸运儿，发生金钱关系，金额不大于1000 int fromAcct = rnd.nextInt(NUM_ACCOUNTS); int toAcct = rnd.nextInt(NUM_ACCOUNTS); InduceLockOrder.DollarAmount amount = new InduceLockOrder.DollarAmount(rnd.nextInt(1000)); try { InduceLockOrder.transferMoney(accounts[fromAcct], accounts[toAcct], amount); System.out.println(&quot;线程【&quot; + Thread.currentThread().getName() + &quot;】运行第&quot; + i + &quot;次------ &quot; + &quot;账户【&quot; + fromAcct + &quot;】向账户【&quot; + toAcct + &quot;】转账&quot; + amount.getAmount() + &quot;$ ------ &quot; + &quot;账户【&quot; + fromAcct + &quot;】剩下 &quot; + accounts[fromAcct].getBalance().getAmount() + &quot;$ ------ &quot; + &quot;账户【&quot; + toAcct + &quot;】剩下 &quot; + accounts[toAcct].getBalance().getAmount() + &quot;$&quot;); } catch (InduceLockOrder.InsufficientFundsException ignored) { } } } } // 多线程交易！！！ for (int i = 0; i &lt; NUM_THREADS; i++) { TransferThread transferThread = new TransferThread(); transferThread.start(); } }} Output: 在有序的规则下，没有被抓，顺利完成了多次交易。 1.4 协作对象间的死锁如果在持有锁的情况下需要调用某个外部方法，就需要警惕死锁。 如果在持有锁时调用某个外部方法，那么将出现活跃性问题。在这个外部方法中可能或获取其他锁（这可能产生死锁），或者阻塞时间过长，导致其他线程无法及时获得当前被持有的锁。 协作对象间的锁顺序死锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import net.jcip.annotations.GuardedBy;import java.awt.Point;import java.util.HashSet;import java.util.Set;public class CooperatingDeadlock { // Warning: 可能产生死锁 class Taxi { @GuardedBy(&quot;this&quot;) private Point location, destination; private final Dispatcher dispatcher; public Taxi(Dispatcher dispatcher) { this.dispatcher = dispatcher; } public synchronized Point getLocation() { return location; } public synchronized void setLocation(Point location) { this.location = location; if (location.equals(destination)) { dispatcher.notifyAvailable(this); } } public synchronized Point getDestination() { return destination; } public synchronized void setDestination(Point destination) { this.destination = destination; } } class Dispatcher { @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; taxis; @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; availableTaxis; public Dispatcher() { taxis = new HashSet&lt;Taxi&gt;(); availableTaxis = new HashSet&lt;Taxi&gt;(); } public synchronized void notifyAvailable(Taxi taxi) { availableTaxis.add(taxi); } public synchronized Image getImage() { Image image = new Image(); for (Taxi t : taxis) { image.drawMarker(t.getLocation()); } return image; } } class Image { public void drawMarker(Point p) { } }} 虽然没有显示调用锁，但是Taxi.setLocation方法和Dispatcher.getImage由于获取锁仍然可能发生死锁情况： 使用开放调用来避免协作对象之间的死锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.awt.Point;import java.util.HashSet;import java.util.Set;public class CooperatingNoDeadlock { @ThreadSafe class Taxi { @GuardedBy(&quot;this&quot;) private Point location, destination; private final Dispatcher dispatcher; public Taxi(Dispatcher dispatcher) { this.dispatcher = dispatcher; } public synchronized Point getLocation() { return location; } public synchronized void setLocation(Point location) { boolean reachedDestination; synchronized (this) { this.location = location; reachedDestination = location.equals(destination); } if (reachedDestination) { dispatcher.notifyAvailable(this); } } public synchronized Point getDestination() { return destination; } public synchronized void setDestination(Point destination) { this.destination = destination; } } @ThreadSafe class Dispatcher { @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; taxis; @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; availableTaxis; public Dispatcher() { taxis = new HashSet&lt;Taxi&gt;(); availableTaxis = new HashSet&lt;Taxi&gt;(); } public synchronized void notifyAvailable(Taxi taxi) { availableTaxis.add(taxi); } public Image getImage() { Set&lt;Taxi&gt; copy; synchronized (this) { copy = new HashSet&lt;Taxi&gt;(taxis); } Image image = new Image(); for (Taxi t : copy) { image.drawMarker(t.getLocation()); } return image; } } class Image { public void drawMarker(Point p) { } }} 1.5 开放调用方法调用相当于一种抽象屏障，你无需了解在调用方法中所执行的操作，也正是由于不知道在被调用方法中执行的操作，因此在持有锁的时候对调用某个外部方法将难以进行分析，从而可能出现死锁。 如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调度（Open Call）。 依赖于开放调用的类会具有更好的行为，并且比那些需要获得锁才能调用的方法相比，更容易与其他的类合作。 使用开放调用来避免死锁类似于使用封裝来提供线程安全：尽管我们能够保证在没有封装的情况下构建线程安全的程序，但是对一个有效封装的类进行线程安全分析，要比分析没有封装的类容易得多。 类似地，分析一个完全依赖于开放调用的程序的程序活跃度，比分析那些非开放调用的程序更简单。尽量让你自己使用开放调用，这要比获得多重锁后识别代码路径更简单，因此可以确保用一致的顺序获得锁。 在程序中尽量使用开放调用。依赖于开放调用的程序，相比于那些在持有锁的时侯还调用外部方法的程序，更容易进行死锁自由度(deadlock-freedom）的分析。 1.6 资源死锁 当线程间相互等待对方持有的锁，并且谁都不会释放自己的锁时就会发生死锁，当线程持有和等待的目标变为资源时，会发生与之相类似的死锁。 假设你有两个放入池中的资源，比如分别是到两个数据库连接的连接池。当池为空的时候发生阻塞。 如果一个任务需要连接到两个数据库，并且两个资源并不是按照相同顺序进行调用的。 线程A可能持有数据库 D1 的连接，并等待连接到数据库 D2。 而线程B持有数据库 D2 的连接并等待到 D1 的连接。 资源死锁 … 完蛋 另一种基于资源的死锁形式就是线程饥饿死锁（Thread-Starvation Deadlock）。 一个 TaskA 将工作提交到单线程化的 Executor，并等待后面向该 Executor 提交的 TaskB 的计算结果。 TaskA 等待 TaskB 的计算结果，久久不能结束。 而单线程化的 Executor 需要执行完一个任务(TaskA)才能执行第二个任务(TaskB)。 即 TaskA 等 TaskB，TaskB 等 TaskA。就互等。 2. 避免和诊断死锁2.1 避免和诊断死锁 如果一个程序一次至多获得一个锁，那么就不会产生锁顺序死锁。 如果必须获得多个锁那么我们应该要制定锁顺序。尽量减少潜在锁之间的交互数量。 2.2 尝试定时的锁 在使用内部锁 synchronized 时，如果一个程序需要获得多个锁，容易造成死锁。 可以使用显式锁，来检测死锁和从锁中恢复。 java.util.concurrent.locks.Lock 类，与使用 synchronized 代码块相比，Lock 实现提供了更广泛的锁定操作。它们允许更灵活的结构。 调用 Lock.tryLock() 方法。如果锁可用，则获取锁并立即返回值为true。如果锁不可用，则此方法将立即返回值false。 在内部锁(synchronized)机制中，只有没有获得锁，就会永远保持等待，而 Lock.tryLock(long time, TimeUnit unit) 可以自定义超时时间。 2.3 通过线程转储分析死锁 JVM 通过 线程转储(thread dump) 帮助开发者识别死锁的发生。 线程转储 包括每个运行中线程的栈追踪信息 与之相似并随之发生的异常 以及锁的信息（如：被哪个线程获得、锁的栈结构、阻塞线程等待的是哪个锁） 在生成线程转储之前，JVM 在表示 “正在等待(is-waiting-for)” 关系的（有向）图中搜索循环来寻找死锁。 如果发现了死锁，它就会包括死锁的识别信息，其中参与了哪些锁和线程，以及程序中造成不良后果的锁请求发生在哪里。 转储分析死锁 【第10章 - 1.死锁】部分的示例：开始一个循环，它在典型条件下制定死锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Random;public class DemonstrateDeadlock { private static final int NUM_THREADS = 20; private static final int NUM_ACCOUNTS = 5; private static final int NUM_ITERATIONS = 1000000; public static void main(String[] args) { final Random rnd = new Random(); // 五个账户，每个账户先给它两个小目标 $ final DynamicOrderDeadlock.Account[] accounts = new DynamicOrderDeadlock.Account[NUM_ACCOUNTS]; for (int i = 0; i &lt; accounts.length; i++) { DynamicOrderDeadlock.Account account = new DynamicOrderDeadlock.Account(); account.setBalance(new DynamicOrderDeadlock.DollarAmount(200000000)); accounts[i] = account; } class TransferThread extends Thread { public void run() { // 这五个账户之间发生了多笔不可描述的金钱交易 for (int i = 0; i &lt; NUM_ITERATIONS; i++) { // 随机抽取两位幸运儿，发生金钱关系，金额不大于1000 int fromAcct = rnd.nextInt(NUM_ACCOUNTS); int toAcct = rnd.nextInt(NUM_ACCOUNTS); DynamicOrderDeadlock.DollarAmount amount = new DynamicOrderDeadlock.DollarAmount(rnd.nextInt(1000)); try { DynamicOrderDeadlock.transferMoney(accounts[fromAcct], accounts[toAcct], amount); System.out.println(&quot;线程【&quot; + Thread.currentThread().getName() + &quot;】运行第&quot; + i + &quot;次------ &quot; + &quot;账户【&quot; + fromAcct + &quot;】向账户【&quot; + toAcct + &quot;】转账&quot; + amount.getAmount() + &quot;$ ------ &quot; + &quot;账户【&quot; + fromAcct + &quot;】剩下 &quot; + accounts[fromAcct].getBalance().getAmount() + &quot;$ ------ &quot; + &quot;账户【&quot; + toAcct + &quot;】剩下 &quot; + accounts[toAcct].getBalance().getAmount() + &quot;$&quot;); } catch (DynamicOrderDeadlock.InsufficientFundsException ignored) { } } } } // 多线程交易！！！ for (int i = 0; i &lt; NUM_THREADS; i++) { TransferThread transferThread = new TransferThread(); transferThread.start(); } }} 启动程序后，控制台通过 jps 获取进程 PID： jcmd 工具向目标 JVM 发送一串命令： 1jcmd PID号 Thread.print 其中有一部分输出是这样的： 1234567891011121314151617Found one Java-level deadlock:=============================&quot;Thread-19&quot;: waiting to lock monitor 0x00007fd1f1a3bb48 (object 0x00000006c001e998, a DynamicOrderDeadlock$Account), which is held by &quot;Thread-18&quot;&quot;Thread-18&quot;: waiting to lock monitor 0x00007fd1f32b3de8 (object 0x00000006c001e970, a DynamicOrderDeadlock$Account), which is held by &quot;Thread-17&quot;&quot;Thread-17&quot;: waiting to lock monitor 0x00007fd1f1818cc8 (object 0x00000006c001e9e8, a DynamicOrderDeadlock$Account), which is held by &quot;Thread-5&quot;&quot;Thread-5&quot;: waiting to lock monitor 0x00007fd1f32b3de8 (object 0x00000006c001e970, a DynamicOrderDeadlock$Account), which is held by &quot;Thread-17&quot;Java stack information for the threads listed above:=================================================== Thread-19 等 Thread-18 Thread-18 等 Thread-17 Thread-17 等 Thread-5 Thread-5 等 Thread-17 互等，完犊子了。 3. 其它活跃度危险3.1 饥饿(starvation) 当线程访问它需要的资源时却被永久拒绝，将会发生饥饿。 线程 API 定义了 10 个优先级级别， 并对应到操作系统相应的调度优先级中。 线程 API 定义的线程优先级仅仅作为调度的参考。 有一些操作系统优先级别本身就少于10个，那么其中多个 Java 的优先级会映射到操作系统相同的优先级。 抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题。 3.2 弱响应性 如果在 GUI 应用程序中，使用了后台线程，那么较大可能会引起响应性差。 GUI框架中，如果后台任务是cpu密集型的，那么它会与主的GUI事件线程竞争 cpu 的时钟周期，可能导致 cpu 主线程的响应性弱。这时我们可以降低后台线程的优先级。 不良的锁管理也可能导致糟糕的响应性。如果某个线程长时间占有一个锁（或者正在对一个大容器进行迭代，并且对每个元素进行计算密集的处理），而其他想要访问这个容器的线程就必须等待很长时间。 3.3 活锁(livelock)活锁是线程活跃度失败的另一种形式，尽管没有阻塞，线程仍不能继续进行，因为它不断尝试相同的操作，却总是失败。 如： 在消息处理应用程序中，如果消息处理失败，其中传递消息的底层架构会会退整个事物，并把它置回队首。 如果消息处理程序对某种特定类型的消息处理存在bug，每次处理都会失败，那么每一次这个消息都会被从队列中取出，传递到存在问题的处理器(handler)，然后发生事务回退。 因为这条消息又会回到队首，处理器会不断被这样重复调用，并返回重复结果。这就是通常称为毒药信息 (poison message）的问题。 如何避免：在重试机制中引入随机性。 如： 两台机器尝试使用相同的频率，来发送数据包，那么这些数据包就会发生冲突。并又双双重试。 如果它们都非常精确地在一秒后重试，它们又会发生冲突，并不断冲突下去，导致数据包永远不能发送。 为了避免这种情况发生，我们可以通过用使一个随机组件它们进行等待。 在并发程序中，通过随机等待和撇回来进行重试能够相当有效地避免活锁的发生。","link":"/posts/696.html"},{"title":"Java并发编程实战：第11章 性能可伸缩性","text":"1. 性能可伸缩性 使用多线程可以使程序更充分的发挥出闲置的处理能力，从而更好地利用资源； 使用多线程，还能够使程序在现有任务正在运行的情况下立刻开始着手处理新的任务，从而提高系统的响应性。 2. 性能的思考 对于给定的活动而言，一些特定的资源通常非常缺乏，无论是CPU周期、内存、网络带宽、I/O带宽、数据库请求、磁盘空间、以及其他一些资源。 当活动的运行因某个特定资源受阻时，我们称之为受限于该资源：受限于CPU、受限于数据库。 可伸缩性指的是：当增加计算资源的时候（比如增加额外 CPU 数量、内存、存储器、TO 带宽)，吞吐量和生产量能够相应地得以改进。 2.1 对性能的权衡进行评估 几乎所有的工程上的决定都会遇到某些形式的折中。 如空间换时间、金钱换算力等等。 要避免不成熟的优化。首先要使我们的程序正确，然后再加快。 对性能调优时，一定要有明确的性能需求。对性能调优后，需要再次测量以验证是否达到了预期的性能提升目标。 2.2 Amdahl 定律 对于并发性的问题，有时候使用越多的资源，就能越快地解决。 不过对于一些串行化的任务来说，可能提供更多的资源，却不能够提高处理速度。 大多数的并发程序由一系列并行化和串行化的片段组成。 Amdahl 定律描述了在一个系统中，基于可并行化和串行化的组件各自所占的比重，程序通过获得额外的计算资源，理论上能參加速多少。 $$ Speedup \\leq 1 \\div [F + \\big(1 - F\\big)\\div N ] $$ N 表示处理器数量，F表示串行化任务的比重。 当 N 无限增大趋近无穷大时，下面公式结果可以忽略不计。 $$ \\big(1 - F\\big)\\div N $$ 即当给定足够的处理器(N)时，Speedup 不等式可以看作如下： $$ Speedup \\leq 1 \\div F $$ 也就是说，一个程序中，如果 50% 的处理都是串行化进行的话。当处理器算力充足，最多只能提升 2 倍的性能。 Amdahl 定律中不同串行化的百分比，带来的最大的效能 串行访问任务队列 1234567891011121314151617181920import java.util.concurrent.BlockingQueue;public class WorkerThread extends Thread { private final BlockingQueue&lt;Runnable&gt; queue; public WorkerThread(BlockingQueue&lt;Runnable&gt; queue) { this.queue = queue; } public void run() { while (true) { try { Runnable task = queue.take(); task.run(); } catch (InterruptedException e) { break; } } }} 这个例子忽略了另一个的相同的串行源：结果处理。 所有有用的计算都产生一些结果集或者边界效应。 因为 Runnable 没有提供明确的结果处理，这些任务必须具有一些边界效应，设定把它们的结果写入日志或者存入一个数据结构。 日志文件和结果容器通常由多个工作者线程共享，并且因此成为了同源的串行部分。 如果不是每个线程各自维护自己的结果的数据结构，而是在所有任务都执行完成后合并所有的结果，这最终的合并就成为了一个串行源。 3. 线程引入的开销3.1 切换上下文 如果可运行的线程数大于 CPU 的数量，那么 OS 最终回强行换出正在执行的线程，从而使其他线程能过使用 CPU。 这会引起上下文切换，它会保存当前运行线程的执行上下文，并重建调入线程的执行上下文。 切换上下文需要一定的开销，而在线程调度过程中需要访问由操作系统和 JVM 共享的数据结构。 上下文切换的开销并不只是包含 JVM 和操作系统的开销。 当一个新的线程被切换进来时，它所需要的数据可能不在当前处理器的本地缓存中，因此上下文切换将导致一些缓存缺失，因而线程在首次调度运行时会更加缓慢。 即使由很多其他正在等待的线程，调度器也会为每个可运行的线程分配一个最小执行时间。调度器将分期偿付切换上下文的开销，获得更多不中断的执行时间，从而提高整体的吞吐量。 3.2 内存同步 synchronized 和 volatile 提供的可见性保证要求使用一个特殊的、名为 存储关卡(memory barrier) 的指令，它可以刷新缓存，使缓存无效，刷新硬件的写缓冲，以及停止执行管道。 存储关卡 可能同样会对性能产生影响，因为它们抑制了其他编译器的优化；在存储关卡中，大多数操作是不能被重排序的。 现代的 JVM 能够通过优化，来去掉一些不会发生资源竞争的锁，从而减少额外的同步。如: 123synchronized (new Object()) { // .....} 更加成熟的 JVM 可以使用 逸出分析(escape analysis) 来识别本地对象的引用(即找出不会被发布到堆的本地对象引用)，并且因此成为线程本地的。如： 1234567public String getStoogeNames() { List&lt;String&gt; stooges = new Vector&lt;&gt;(); stooges.add(&quot;Moe&quot;); stooges.add(&quot;Larry&quot;); stooges.add(&quot;Curly&quot;); return stooges.toString();} 在本地执行 getStoogeNames() 至少需要获取/释放 Vector 的锁 4 次，每个 add() 一次，toString() 一次。 成熟的编译器能够分析出该程序内部状态一直没有逸出，因此这 4 次对锁的请求就可以被消除了。 即使编译器没有逸出分析，它还可以进行 锁的粗化(lock coarsening)，把邻近的同步代码块用相同的锁合并起来。 在 getStoogeNames() 中，JVM 如果进行锁的粗化，可能会把3个 add() 调用结合起来，并对 toString() 使用当读的锁请求和释放。并采用启发式方法来评估同步代码块中采用同步操作以及指令之间的相对开销。 3.3 阻塞 如上面所述，非竞争的同步可以由 JVM 完全掌控。 当锁为竞争性的时候，失败的线程会发生阻塞。 JVM 能 自旋等待(spin-waiting) 不断尝试获取锁，直到成功 JVM 还能在操作系统中 挂起(suspending) 被阻塞的线程。 自旋等待适合短期的等待，而挂起适合长时间等待。 挂起需要两次额外的上下文切换，以及OS和缓存的相关活动 阻塞的线程在它被CPU分配的执行时间内，还没有到期前就被换出。 稍后如果能够获得锁/资源，又会被换入。 阻塞归因于锁的竞争，线程持有锁：当它释放该锁的时候，它必须通知操作系统，重新开始因该锁而阻塞的其它线程。 4. 减少锁的竞争 串行化 会损害可伸缩性，上下文切换 会损害性能。 减少锁的竞争能改进性能和可伸缩性。 并发程序中，对可伸缩性首要的威胁是独古的资源锁。 锁的竞争性因素：锁被请求的频率，以及每次持有该锁的时间。(如果两者乘积足够小，可以认为是非竞争性的) 如何减少锁的竞争： 减少持有锁的时间 减少请求锁的频率 用协调机制取代独占锁，从而允许更强的并发性 4.1 缩小锁的范围 尽量缩短锁的持有时间。 将一些与锁无关的代码移出同步代码块 持有锁超过必要的时间 12345678910111213141516171819202122import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.util.HashMap;import java.util.Map;import java.util.regex.Pattern;@ThreadSafepublic class AttributeStore { @GuardedBy(&quot;this&quot;) private final Map&lt;String, String&gt; attributes = new HashMap&lt;&gt;(); public synchronized boolean userLocationMatches(String name, String regexp) { String key = &quot;users.&quot; + name + &quot;.location&quot;; String location = attributes.get(key); if (location == null) { return false; } else { return Pattern.matches(regexp, location); } }} 减少锁持续的时间 12345678910111213141516171819202122232425import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.util.HashMap;import java.util.Map;import java.util.regex.Pattern;@ThreadSafepublic class BetterAttributeStore { @GuardedBy(&quot;this&quot;) private final Map&lt;String, String&gt; attributes = new HashMap&lt;&gt;(); public boolean userLocationMatches(String name, String regexp) { String key = &quot;users.&quot; + name + &quot;.location&quot;; String location; synchronized (this) { location = attributes.get(key); } if (location == null) { return false; } else { return Pattern.matches(regexp, location); } }} 这消除了可伸缩性的一个阻碍，因为串行化的代码少了。 在上面代码中，attributes 成员变量可以使用 代理线程安全 的技术，通过使用 Hashtable、synchronizedMap、ConcurrentHashMap 来取代 HashMap。即用线程安全的容器来代理所有线程安全的职责。 同步代码块不能过小。一些需要采用原子方式执行的操作必须包含在一个同步块中。 4.2 减小锁的粒度 可以通过分拆锁(lock spliting)和分离锁(lock striping)来减小锁的粒度。 采用相互独立的锁，守卫多个独立的状态变量，在改变之前，它们都是由一个锁守护的。 分拆锁(lock spliting)和分离锁(lock striping)减小了锁发生时的粒度，潜在实现了更好的可伸缩性（使用的锁越多越会增加死锁的风险） 如果整个程序只有一个锁，而不是每个对象分配一个独立的锁。那么，执行所有的 synchronized 代码块时，不考虑锁的情况，就会成为串行化执行。因为很多线程都在竞争相同的锁。 简单理解就是整个学校九成的人都是独立(单身)的异性，你脱单的概率是不是就高了很多。同理整个学校九成的都是独立(单身)的同性，那是不是就很多人竞争了(口味独特的除外)。 应当分拆锁的候选程序 12345678910111213141516171819202122232425262728293031323334import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.util.HashSet;import java.util.Set;@ThreadSafepublic class ServerStatusBeforeSplit { @GuardedBy(&quot;this&quot;) public final Set&lt;String&gt; users; @GuardedBy(&quot;this&quot;) public final Set&lt;String&gt; queries; public ServerStatusBeforeSplit() { users = new HashSet&lt;String&gt;(); queries = new HashSet&lt;String&gt;(); } public synchronized void addUser(String u) { users.add(u); } public synchronized void addQuery(String q) { queries.add(q); } public synchronized void removeUser(String u) { users.remove(u); } public synchronized void removeQuery(String q) { queries.remove(q); }} 使用分拆锁重构 ServerStatus 12345678910111213141516171819202122232425262728293031323334353637383940import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.util.HashSet;import java.util.Set;@ThreadSafepublic class ServerStatusAfterSplit { @GuardedBy(&quot;users&quot;) public final Set&lt;String&gt; users; @GuardedBy(&quot;queries&quot;) public final Set&lt;String&gt; queries; public ServerStatusAfterSplit() { users = new HashSet&lt;String&gt;(); queries = new HashSet&lt;String&gt;(); } public void addUser(String u) { synchronized (users) { users.add(u); } } public void addQuery(String q) { synchronized (queries) { queries.add(q); } } public void removeUser(String u) { synchronized (users) { users.remove(u); } } public void removeQuery(String q) { synchronized (users) { queries.remove(q); } }} 4.3 分离锁 把一个竟争潡烈的锁分拆成两个，很可能形成两个竟争激烈的锁。尽管这可以通过两个线程并发执行，取代一个线程，从而对可伸缩性有一些小的改进，但这仍然不能大幅地提高多个处理器在同一系统中并发性的前景。 分拆锁有时候可以被扩展，分成可大可小加锁块的集合，并且它们归属于相互独立的对象，这样的情况就是分离锁。 ConcurrentHashMap 的实现是用来一个包含 16 个锁的 Array，每一个锁都守护 Hash Bucket 的 1/16 。Bucket N 由第 N mod 16个锁来守护。这也使得 ConcurrentHashMap 能够支持 16 个并发的 Writer。 分离锁的一个劣势在于：与采用单个锁来实现独占访问相比，要获得多个锁来实现独占访问将更加困难并且开销更高。 通常，在执行一个操作时最多只需获得一个锁，但在某些情况下需要加锁整个容器。例如 ConcurrentHashMap 的值需要被扩展、重排，放入一个更大的 Bucket 是，这时就需要获得所有分离的锁。 基于 Hash值的 map 中使用分离锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import net.jcip.annotations.ThreadSafe;@ThreadSafepublic class StripedMap { // 同比策略: buckets[n] 由 locks[n%N_LOCKS] 保护 private static final int N_LOCKS = 16; private final Node[] buckets; private final Object[] locks; private static class Node { Node next; Object key; Object value; } /** * 分离锁的 map * @param numBuckets map 容量 */ public StripedMap(int numBuckets) { buckets = new Node[numBuckets]; locks = new Object[N_LOCKS]; for (int i = 0; i &lt; N_LOCKS; i++) { locks[i] = new Object(); } } /** hash 值。通过 key 的hash值除以桶个数求余，取绝对值得出 */ private final int hash(Object key) { return Math.abs(key.hashCode() % buckets.length); } public Object get(Object key) { int hash = hash(key); // locks[hash % N_LOCKS] --&gt; 守护 buckets[hash] synchronized (locks[hash % N_LOCKS]) { for (Node m = buckets[hash]; m != null; m = m.next) { if (m.key.equals(key)) { return m.value; } } } return null; } public void clear() { for (int i = 0; i &lt; buckets.length; i++) { // locks[i % N_LOCKS] --&gt; 守护 buckets[i] synchronized (locks[i % N_LOCKS]) { buckets[i] = null; } } }} 4.4 避免热点域 分拆锁和分离锁能够改进可伸缩性，因为它们能够使不同的线程操作不同的数据(或者相同数据结构的不同部分)，而不会发生相互干扰。 如果一个锁守护两个独立变量 X 和 Y，线程 A 想要访问 X，而线程 B 想要访问 Y，这两个线程没有竟争任何数据，然而它们竞争相同的锁。 当每一个操作都请求变了的时候，锁的粒度很难被降低。性能和可伸缩性相互牵制。(优化：如缓存常用的计算结果、引入热点域，从而限制可伸缩性) 对于 HashMap，就是引入热点域 size，缓存size操作的结果，每次增减元素都及时更新。 4.5 独占锁的替代方法 ReadWriteLock 实行了一个 多读者-单写者(multiple-reader, single-write)加锁规则：只要没有更改，那么多个读者可以并发访问共享资源，但是写者必须独占获得锁。 对于多数操作都为读操作的数据结构，ReadWriteLock 与独占锁相比，可以提供更好的并发性。 原子变量类提供了针对整数或对象饮用的非常精妙的原子操作(因此更具可伸缩性)，并且使用现代处理器提供的底层并发原语(如：比较并交换compare-and-swap) 如果类中只有少量的热点域，并且该类不参加与其它变量的不变约束，那么使用原子变量替代它可能会提高可伸缩性。 4.6 不使用 对象池 在 JVM 的早期版本中，对象分配和垃圾回收等操作的执行速度非常慢，但在后续的版本中，这些操作的性能得到了极大提高。 为了解决 “缓慢的” 对象生命周期问题，许多开发人员都选择使用对象池，在对象池中，对象能被循环使用，而不是由垃圾收集器回收并在需要重新分配。 在并发程序中，对象池表现得比较糟糕。当线程分配新的对象时，需要线程内部非常细微的协调，因为分配运算通常使用本地的分配代码块来小区对象堆中的大部分同步。 对多个线程从对象池中请求对象，协调访问对象池的数据结构要使用同步技术，因此可能会产生线程阻塞。 锁竞争产生的阻塞，其代价比直接创建对象多几百倍。不推荐使用对象池。 5. 减少上下文切换的开销很多任务引入的操作都会发生阻塞，在运行和阻塞这两个状态之间转换，需要使用上下文切换。 日志消息 服务器应用程序发生阻塞的一个缘由是在处理请求期间产生日志消息。 大多数日志框架都是围绕 println 进行 “瘦” 包装的。 LogWriter 日志记录的工作由一个专职的后台线程完成，而不是由请求线程完成。 日志操作的服务时间包括与 InputStream/OutputStream 相关的类花费的时间。 如果【线程a】 I/O 操作发生阻塞，它很可能包括线程被阻塞的时间。操作系统会把这个阻塞线程从调度队列中移出，直到 I/O 结束，并且很可能比这个花费的时间更长。当 I/O 结束的时候，其他线程可能被唤醒，并被允许完成它们的调度时间限额，并且在调度队列中有些线程可能已经排在【线程a】前面了。这种情况会增加【线程a】的服务时间。 如果多个线程同时记录日志，它们可能还会竞争输出流的锁。这与阻塞I/O一样(线程阻塞，等待获得锁，然后被换出 —- 上下文切换增多) 把 I/O 操作从主线程中分离出来 把 I/O 操作从请求处理线程中分离出来很可能缩短处理请求的平均服务时间。 调用 I/O 操作的线程，不再因为等待输出流的锁，或者等待 I/O 完成而发生阻塞；它们只需使消息加入队列，然后返回到它们自己的任务中即可。 这样操作，使得请求线程在处理时，减少了 I/O 操作带来的阻塞，也就是说减少了上下文被换出。 把所有的日志 I/O 移入一个线程，消除了输出流的竞争，也减少了竞争源。","link":"/posts/2b7d.html"},{"title":"Java并发编程实战：第12章 测试并发程序","text":"1. 测试正确性1.1 测试并发程序并发程序打造可以分为两类： 安全性测试 活跃性测试 进展性测试 无进展测试 与活跃性测试相关的事性能测试。性能的衡量： 吞吐量 响应性 可伸缩性 1.2 测试正确性在为某个并发类设计单元测试时，首先需要执行与测试串行类时相同的分析 —- 找出需要检查的不变性条件和后验条件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.util.concurrent.Semaphore;@ThreadSafepublic class SemaphoreBoundedBuffer &lt;E&gt; { /** * Semaphore ---- 计数信号量 * availableItems ---- 可用items * availableSpaces ---- 可用空间 */ private final Semaphore availableItems, availableSpaces; /** 存放 Element 的数组 */ @GuardedBy(&quot;this&quot;) private final E[] items; /** * putPosition ---- 存入数组 items 的位置 * takePosition ---- 从数组中拿 Element 的位置 */ @GuardedBy(&quot;this&quot;) private int putPosition = 0, takePosition = 0; public SemaphoreBoundedBuffer(int capacity) { if (capacity &lt;= 0) { throw new IllegalArgumentException(); } // 初始化幸好量，可用 items = 0，可用空间 spaces = capacity availableItems = new Semaphore(0); availableSpaces = new Semaphore(capacity); items = (E[]) new Object[capacity]; } public boolean isEmpty() { return availableItems.availablePermits() == 0; } public boolean isFull() { return availableSpaces.availablePermits() == 0; } /** * 添加一个元素 * 可用空间 - 1 * 可用元素 + 1 */ public void put(E x) throws InterruptedException { availableSpaces.acquire(); doInsert(x); availableItems.release(); } /** * 拿出一个元素 * 可用空间 + 1 * 可用元素 - 1 */ public E take() throws InterruptedException { availableItems.acquire(); E item = doExtract(); availableSpaces.release(); return item; } /** * 添加一个元素 * @param x 元素 */ private synchronized void doInsert(E x) { int i = putPosition; items[i] = x; ++i; if (i == items.length) { putPosition = 0; } else { putPosition = i; } } private synchronized E doExtract() { int i = takePosition; E x = items[i]; items[i] = null; ++i; if (i == items.length) { takePosition = 0; } else { takePosition = i; } return x; }} 在计数信号量中，许可不会被显式地表现出来，也不会和它所在的线程有任何关联；release 创建许可，acquire消費许可。 1.2.1 基本的单元测试对 SemaphoreBoundedBuffer 进行基本单元测试： 1234567891011121314151617181920public class TestBoundedBuffer extends TestCase { @Test public void testIsEmptyWhenConstructed() { SemaphoreBoundedBuffer&lt;Integer&gt; bb = new SemaphoreBoundedBuffer&lt;Integer&gt;(10); assertTrue(bb.isEmpty()); // bb.isEmpty() = true assertFalse(bb.isFull()); // bb.isFull() = false } @Test public void testIsFullAfterPuts() throws InterruptedException { SemaphoreBoundedBuffer&lt;Integer&gt; bb = new SemaphoreBoundedBuffer&lt;Integer&gt;(10); for (int i = 0; i &lt; 10; i++) { bb.put(i); } assertTrue(bb.isFull()); // bb.isFull() = true assertFalse(bb.isEmpty()); // bb.isEmpty() = false }} 1.2.2 测试阻塞操作1234567891011121314151617181920212223242526272829import junit.framework.TestCase;import org.junit.Test;public class TestBoundedBuffer extends TestCase { private static final long LOCKUP_DETECT_TIMEOUT = 1000; @Test public void testTakeBlocksWhenEmpty() { final SemaphoreBoundedBuffer&lt;Integer&gt; bb = new SemaphoreBoundedBuffer&lt;Integer&gt;(10); Thread taker = new Thread() { public void run() { try { int unused = bb.take(); fail(); } catch (InterruptedException success) { } } }; try { taker.start(); Thread.sleep(LOCKUP_DETECT_TIMEOUT); taker.interrupt(); taker.join(LOCKUP_DETECT_TIMEOUT); assertFalse(taker.isAlive()); } catch (Exception unexpected) { fail(); } }} 如果在某个测试用例创建的辅助线程中发现了一个错误，那么框架通常无法得知与这个线程相关的是哪一个测试，所以需要通过一些工作将成功或失败信息传递回主线程，从而才能将相应的信息报告出来。 1.2.3 测试安全性 要想测试一个并发类在不可预知的并发访问下是否能够正确执行，我们可以安排多个线程对该并发类进行操作，运行一段时间再检查数据是否正常。 在对并发类进行安全性测试时，要关注某些熟悉可能会引发数据异常、导致程序出现问题。简单地识别出这些受检查的属性来，不要在检查这些属性，人为的限制程序的并发性。最好能做到在检查测试的属性时，不需要添加任何同步代码。 SemaphoreBoundedBuffer 的生产者-消费者测试程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import junit.framework.TestCase;import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.atomic.AtomicInteger;public class PutTakeTest extends TestCase { protected static final ExecutorService pool = Executors.newCachedThreadPool(); protected CyclicBarrier barrier; protected final SemaphoreBoundedBuffer&lt;Integer&gt; bb; protected final int nTrials, nPairs; protected final AtomicInteger putSum = new AtomicInteger(0); protected final AtomicInteger takeSum = new AtomicInteger(0); public static void main(String[] args) throws Exception { new PutTakeTest(10, 10, 100000).test(); // sample parameters pool.shutdown(); } public PutTakeTest(int capacity, int npairs, int ntrials) { this.bb = new SemaphoreBoundedBuffer&lt;Integer&gt;(capacity); this.nTrials = ntrials; this.nPairs = npairs; this.barrier = new CyclicBarrier(npairs * 2 + 1); } void test() { try { for (int i = 0; i &lt; nPairs; i++) { pool.execute(new Producer()); pool.execute(new Consumer()); } barrier.await(); // wait for all threads to be ready barrier.await(); // wait for all threads to finish assertEquals(putSum.get(), takeSum.get()); } catch (Exception e) { throw new RuntimeException(e); } } static int xorShift(int y) { y ^= (y &lt;&lt; 6); y ^= (y &gt;&gt;&gt; 21); y ^= (y &lt;&lt; 7); return y; } /** 生产者 */ class Producer implements Runnable { public void run() { try { int seed = (this.hashCode() ^ (int) System.nanoTime()); int sum = 0; barrier.await(); for (int i = nTrials; i &gt; 0; --i) { bb.put(seed); sum += seed; seed = xorShift(seed); } putSum.getAndAdd(sum); barrier.await(); } catch (Exception e) { throw new RuntimeException(e); } } } /** 消费者 */ class Consumer implements Runnable { public void run() { try { barrier.await(); int sum = 0; for (int i = nTrials; i &gt; 0; --i) { sum += bb.take(); } takeSum.getAndAdd(sum); barrier.await(); } catch (Exception e) { throw new RuntimeException(e); } } }} 1.2.4 测试资源管理 任何持有或管理着其他对象的对象，都应该在不需要某个对象时，放弃该对象的引用。 存储资源泄漏会抑制垃圾回收器回收内存(以及线程、文件句柄、套接字、数据库连接或者其它有限资源)，还会导致资源耗尽和应用程序的失败。因此要限制缓存的大小。 对内存不合理的占有，可以简单地通过堆检查工具测试出来。例如 JProfiler 工具。 测试资源泄漏 12345678910111213141516171819202122232425262728293031import junit.framework.TestCase;import org.junit.Test;public class TestBoundedBuffer extends TestCase { private static final int CAPACITY = 10000; private static final int THRESHOLD = 10000; public class Big { double[] data = new double[100000]; } @Test public void testLeak() throws InterruptedException { SemaphoreBoundedBuffer&lt;Big&gt; bb = new SemaphoreBoundedBuffer&lt;&gt;(CAPACITY); int heapSize1 = snapshotHeap(); // heap 的快照 for (int i = 0; i &lt; CAPACITY; i++) { bb.put(new Big()); } for (int i = 0; i &lt; CAPACITY; i++) { bb.take(); } int heapSize2 = snapshotHeap(); // heap 的快照 assertTrue(Math.abs(heapSize1 - heapSize2) &lt; THRESHOLD); } private int snapshotHeap() { /* Snapshot heap and return heap size */ return 0; }} 1.2.5 使用回调 回调用户提供的代码，有助于创建测试用例； 回调常常发生在一个对象生命周期的己知点上，这些点提供了很好的机会，来断言不变约束。例如，ThreadPoolExecutor 就把调用转到了任务的 Runnable 和 ThreadFactory 上。 测试一个线程池，涉及到对其执行策路的大量要素的测试：当需要时就创建额外的线程，不需要时就不要创建；当需要时就回收空闲线程，等等。创建一个爱盖了所有可能性的全面的测试套件是一件非常好的事情，但是大多数可能性都可以简单地、独立地进行测试。 用于测试 ThreadPoolExecutor 的线程工厂 12345678910111213import java.util.concurrent.Executors;import java.util.concurrent.ThreadFactory;import java.util.concurrent.atomic.AtomicInteger;class TestingThreadFactory implements ThreadFactory { public final AtomicInteger numCreated = new AtomicInteger(); private final ThreadFactory factory = Executors.defaultThreadFactory(); public Thread newThread(Runnable r) { numCreated.incrementAndGet(); return factory.newThread(r); }} 验证线程池扩展的测试方法 12345678910111213141516171819202122232425262728293031323334353637383940import junit.framework.TestCase;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadFactory;import java.util.concurrent.atomic.AtomicInteger;public class TestThreadPool extends TestCase { /** 线程工厂 */ private final TestingThreadFactory threadFactory = new TestingThreadFactory(); public void testPoolExpansion() throws InterruptedException { int MAX_SIZE = 10; ExecutorService exec = Executors.newFixedThreadPool(MAX_SIZE, threadFactory); // 提交 100 个 task 到 execute for (int i = 0; i &lt; 10 * MAX_SIZE; i++) { exec.execute(new Runnable() { public void run() { try { Thread.sleep(Long.MAX_VALUE); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }); } for (int i = 0; i &lt; 20 &amp;&amp; threadFactory.numCreated.get() &lt; MAX_SIZE; i++) { Thread.sleep(100); } // threadFactory.numCreated.get() = 10 // MAX_SIZE = 10 // junit.framework.AssertionFailedError: assertEquals(threadFactory.numCreated.get(), MAX_SIZE); exec.shutdownNow(); }} 如果核心池大小小于最大值，线程池会在执行的任务增多时相应地增长。 向池提交几个耗时任务，会使池中的执行任务的数量在足够长的时间内都是常量，这就可以进行一些断言，比如测试池是否如期地扩展。 1.2.6 产生更多的交替操作由于并发代码中发生的错误一般都是低概率事件，所以在测试并发错误时需要反复地执行许多次。 有些方法可以提高发现这些错误的概率，在多处理器系统上，如果处理器的数量少于活动线程的数量，那么与单处理器的系统或者包含多个处理器的系统相比，将能产生更多的交替行为。 同样，如果在不同的处理器数量、操作系统以及处理器架构的系统上进行测试，就可以发现那些在特定运行环境中才会出现的问题。 有一种有用的方法能提高交替操作的数量。以便能更有效的搜索程序的状态空间：在访问共享状态的操作中，使用Thread.yield将产生更多的上下文切换。当代码在访问状态的时候没有使用足够的同步，将存在一些对执行时序敏感的错误，通过在某个操作的执行过程 中调用yield方法，可以将这些错误暴露出来。这种方法需要在测试中添加一些调用并且在正式产品中删除这些调用。 使用 Thread.yield 产生更多的交替操作 1234567public synchronized void tranferCredits(Account from,Account to,int amount) { from.setBalance(from.getBalance()-amount); if (random.nextInt(1000)&gt;THRESHOLD) { Thread.yield(); } to.setBalance(to.getBalance()+amount); } 2. 测试性能2.1 性能测试 性能测试要符合当前程序的应用场景，理想情况下应该反映出被测试对象在应用程序中的实际用法。 性能测试将衡量典型测试用例中的端到端功能。通常，要获得一组合理的使用场景并不容易，理想情况下，在测试中应该反映出被测试对象在应用程序中的实际用法。 根据经验值来调整各种不同的限值，例如线程数量，缓存容量等等，这些限值都依赖于平台特性(如CPU、内存)。 2.2 比较多种算法 测试结果表明，LinkedBlockgingQueue 的可伸缩性要高于 ArrayBlockingQueue。 从测试结果来看，这个结果似乎有些奇怪，链表队列在每次插入元素时，都必须分配一个链表节点对象，这似乎比基于数组的队列相比，链表队列的 put 和 take 等方法支持并发性更高的访问，因为一些优化后的链接队列算法能将队列头节点的更新操作与尾节点的更新操作分享开来。 因此如果算法能通过多执行一些内存分配操作来降低竞争程度，那么这种算法通常具有更高的可伸缩性。 2.3 测量响应性 同一进程可以同时在多个内核上执行(多线程)，并且可以在进程之间共享内存。因此无论上下文切换发生什么，缓存同步都是不可避免的。 如果缓存过小，那么将导致非常多的上下文切换次数。频繁的上下文切换，会导致程序吞吐量较为糟糕。 如果线程由于较多的同步条件限制，导致持续的被阻塞，不公平的信号量(Semaphore)能够提供更好的吞吐量(差异性大)，公平的信号量提供更低的差异性。 3. 避免性能测试陷阱3.1 垃圾回收 垃圾回收的时序是不可预知的，在一个测量数据的测试运行中，任何时候垃圾回收器都有可能运行。 多次对程序进行测试时，如果仅在某一两次触发了垃圾回收，这可能会导致最终测试结果有所偏差。 有两种策略可以防止垃圾回收操作对测试结果产生偏差。 第一种策略是，确保垃圾回收操作在测试运行的整个期间都不会执行。 第二种策略是，确保垃圾回收操作在测试期间执行多次，这样测试程序就能充分反映出运行期间的内存分配与垃圾回收等开销。 （可以在调用JVM时指定-verbose：gc来判断是否执行了垃圾回收操作） 3.2 动态编译 HotSpot JVM 结合了字节码解释和动态编译。 当一个类首次被加载后，JVM 会以解释字节码的方式执行。 如果一个方法运行得较为频繁，动态编译器最终会将其挑出来，转成本机代码，当编译完成后，执行方式将由解释执行转换到直接执行。 编译的时机时不可预知的。大多数程序在运行得足够长后，所有频繁执行的代码露肩都会被编译。 在进行性能测试时，可以长时间运行要测试的程序，这样编译过程和解释执行仅仅占总体运行的很小一部分，对结果影响较小。或者先让待测试代码频繁执行，这样代码就会被完全编译，再测试时，即为直接执行。 在运行程序时，使用 -XX: +PrintCompilation，程序会在动态编译时打印出信息。可以通过这条消息来验证动态编译是在测试运行前，而不是在运行过程中。 3.3 不切实际的竞争程度 并发的应用程序总是交替执行两种非常不同的工作： 访问共享数据，比如从共享工作队列中获取下一个任务。 线程本地的计算（执行任务，假设任务自身并不访问共享数据）。 依赖于两种工作类型的相关特性，应用程序会经历不同级别的竞争，并表现出不同的性能与伸缩性行为。 如果有N个线程从共享工作队列中获取任务并执行，这些任务都是计算密集型的、耗时的（但并未频繁地跨线程访问数据），这种情况几乎没有竟争；吞吐量只受限于可用的 CPU 资源。另一方面，如果任务的生命周期很短，在工作队列上就会存在大量竞争，此时吞吐量受限于同步的开销。 为了获得有实际意义的结果，并发性能测试，除了需要考虑协调并发的因素，应该尽最去模拟让线程本地的计算由某一个特有的应用程序来完成。如果每个任务在真实应用程序中完成的工作，与测试程序相比，其本质和范围有相当大的不同，那么得到的关于性能瓶颈位置的结论将是毫无根据的。","link":"/posts/2d61.html"},{"title":"Java并发编程实战：第14章 构建自定义的同步工具","text":"1. 管理状态依赖性1.1 管理状态依赖性 状态依赖性指某种操作必须依赖于指定的状态才可以执行。比如一个阻塞队列的take方法依赖于这个阻塞队列中有至少一个元素这个状态。 如果一个状态依赖性操作所依赖的状态不满足，通常有几种处理办法： 抛出异常 使用某种约定的错误返回值 阻塞，直到依赖的状态被满足 状态依赖的可阻塞行为结构 12345678910111213141516171819void blockingAction() throws InterruptedException { // ... // 请求 依赖的状态 锁 // ... // 依赖条件不成立 while (不成立的条件) { // 释放锁 // ... // 直到依赖条件成立。如果中断或超时过期，则可选失败 // ... // 请求锁 } // do something // 释放锁} 生产者-消费者的设计经常会使用 ArrayBlockingQueue 这种有限缓存。一个有限缓存提供的 put 和 take 操作，每一个都有先验条件：不能从空缓存中获取元素，也不能把元素置入已满的緩存中。如果依赖于状态的操作在处理先验条件时失败，可以抛出异常或者返回错误状态（把问题留给调用者)，也可以保持阻塞直到对象转入正确的状态。 示例：有限缓存的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;@ThreadSafepublic abstract class BaseBoundedBuffer&lt;V&gt; { @GuardedBy(&quot;this&quot;) private final V[] buf; @GuardedBy(&quot;this&quot;) private int tail; @GuardedBy(&quot;this&quot;) private int head; @GuardedBy(&quot;this&quot;) private int count; protected BaseBoundedBuffer(int capacity) { this.buf = (V[]) new Object[capacity]; } protected synchronized final void doPut(V v) { buf[tail] = v; if (++tail == buf.length) { tail = 0; } ++count; } protected synchronized final V doTake() { V v = buf[head]; buf[head] = null; if (++head == buf.length) { head = 0; } --count; return v; } public synchronized final boolean isFull() { return count == buf.length; } public synchronized final boolean isEmpty() { return count == 0; }} 1.2 将先验条件失败传给调用者 如果有缓存不满足先验条件，会停滞不前 123456789101112131415161718192021222324252627282930313233import net.jcip.annotations.ThreadSafe;@ThreadSafepublic class GrumpyBoundedBuffer &lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; { public GrumpyBoundedBuffer() { this(100); } public GrumpyBoundedBuffer(int size) { super(size); } public synchronized void put(V v) throws BufferFullException { if (isFull()) { throw new BufferFullException(); } doPut(v); } public synchronized V take() throws BufferEmptyException { if (isEmpty()) { throw new BufferEmptyException(); } return doTake(); }}class BufferFullException extends RuntimeException {}class BufferEmptyException extends RuntimeException {} 如果向 GrumpyBoundedBuffer 中添加、拿取元素，GrumpyBoundedBuffer 已经满了、没有元素，那么将抛出 RuntimeException。 调用 GrumpyBoundedBuffer 1234567891011121314151617public class GrumpyBoundedBufferDemo { private GrumpyBoundedBuffer&lt;String&gt; buffer; int SLEEP_GRANULARITY = 50; public void useBuffer() throws InterruptedException { while (true) { try { String item = buffer.take(); // ... ... break; } catch (BufferEmptyException e) { Thread.sleep(SLEEP_GRANULARITY); // 建议使用：Thread.yield() 向调度程序提示当前线程愿意放弃其当前对处理器的使用。而不占用CPU } } }} 如果 GrumpyBoundedBuffer 中没有元素，那么 sleep，循环等待有元素可用。 1.3 利用 “轮询加休眠” 实现拙劣的阻塞 有限缓存使用了拙劣的阻塞 12345678910111213141516171819202122232425262728293031323334353637import net.jcip.annotations.ThreadSafe;@ThreadSafepublic class SleepyBoundedBuffer &lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; { int SLEEP_GRANULARITY = 60; public SleepyBoundedBuffer() { this(100); } public SleepyBoundedBuffer(int size) { super(size); } public void put(V v) throws InterruptedException { while (true) { synchronized (this) { if (!isFull()) { doPut(v); return; } } Thread.sleep(SLEEP_GRANULARITY); } } public V take() throws InterruptedException { while (true) { synchronized (this) { if (!isEmpty()) { return doTake(); } } Thread.sleep(SLEEP_GRANULARITY); } }} SleepyBoundedBuffer 与 GrumpyBoundedBuffer 不同的是，在 put 和 take 操作时，使用轮询+休眠的方式，直到满足条件。 像大多数行为良好的阻塞库的方法一样，SleepyBoundedBuffer 通过中断支持取消，如果被中断，它会提前返回，并抛出 InterruptedException。 1.4 使用条件队列解决拙劣的阻塞条件队列可以让一组线程(等特集)，以某种方式等待相关条件变成真。不同于传统的队列，它们的元素是数据项：条件队列的元素是等待相关条件的线程。 有限缓存使用条件队列 12345678910111213141516171819202122232425262728293031323334353637383940import net.jcip.annotations.ThreadSafe;@ThreadSafepublic class BoundedBuffer&lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; { public BoundedBuffer() { this(100); } public BoundedBuffer(int size) { super(size); } public synchronized void put(V v) throws InterruptedException { while (isFull()) { wait(); } doPut(v); notifyAll(); } public synchronized V take() throws InterruptedException { while (isEmpty()) { wait(); } V v = doTake(); notifyAll(); return v; } public synchronized void alternatePut(V v) throws InterruptedException { while (isFull()) { wait(); } boolean wasEmpty = isEmpty(); doPut(v); if (wasEmpty) { notifyAll(); } }} 使用了超类 Object 中的 wait()、notify()、notifyAll()方法： 12345678// 使当前线程等待，直到另一个线程为此对象调用notify()方法或notifyAll()方法。public final void wait() throws InterruptedException { }// 唤醒正在此对象的监视器上等待的单个线程。public final native void notify();// 唤醒正在此对象的监视器上等待的所有线程。public final native void notifyAll(); 2. 使用条件队列条件队列让构建有效且响应的状态依赖类变得更容易，但是使用时比较容易出错。应该尽量构建在像 LinkedBlockingQueue、Latch、Semaphore 和 FutureTask 基础之上。 2.1 条件谓词 条件调词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系。 在有限缓存中，只有缓存不为空时 take 才能执行，否则它必须等待。就 take 而言，它的条件谓词是“绶存不空”，take 执行前必须先测试。类似地，put 的条件谓词是“缓存不满”。 在条件等待中存在一种重要的三元关系，包括：加锁、wait() 方法、条件谓词 每次调用 wait 都会您式地与特定的永什调调相关联。当调用特定条件谓词的 wait 时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量。 2.2 过早地唤醒当线程A调用到 wait() 代码后，其它线程在此期间插足了 —- 获取了锁，并且修改了数据。那么线程A获取锁后，需要重新检查条件谓词。例如： 123456789101112131415161718public synchronized void put(V v) throws InterruptedException { // 条件谓词：isFull() while (isFull()) { wait(); } doPut(v); notifyAll();}public synchronized V take() throws InterruptedException { // 条件谓词：isEmpty() while (isEmpty()) { wait(); } V v = doTake(); notifyAll(); return v;} 【线程A】调用空缓存中的 take()，不满足条件（绶存不空），于是调用 wait() 使当前线程等待。 【线程B】调用该空缓存中的 put()，满足条件（缓存不满），于是将一个元素放入缓存，并且调用 notifyAll()，唤醒【线程A】。 【线程A】此时需要再次检查条件谓词是否满足。 不过有的时候，我们可能根本不知道哪个方法调用了 notify() 或 notifyAll()，唤醒正在 wait() 的线程。如果被唤醒的线程去检查条件谓词，还不能满足条件，就又要继续等待。 状态依赖方法的规范式 123456789void stateDependentMethod() throws InterruptedException { // 条件谓词必须被锁守护 synchronized(lock) { while (!conditionPredicate()) { lock.wait(); } // 现在，对象处于期望的状态中 }} 当使用条件等待时(Object.wait 或者 Condition.await) 永远设置一个条件谓词 —- 一些对象状态的测试，线程执行前必须满足它； 永远在调用 wait 前测试条件谓词，并且从 wait 中返回后再次测试； 永远在循环中调用 wait； 确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的； 当调用 wait、 notify 或者 notifyAll 时，要持有与条件队列相关联的锁；并且在检查条件谓词之后、开始执行被保护的逻辑之前，不要释放锁。 2.3 丢失的信号保证 notify() 一定在 wait() 之后。 2.4 通知 在有限缓存中，在绶存变为非空时，为了能够让 take 解除阻塞，我们必须确保每一条能够让缓存变为非空的代码路径都执行一个通知。 例如： 12345678910public synchronized void alternatePut(V v) throws InterruptedException { while (isFull()) { wait(); } boolean wasEmpty = isEmpty(); doPut(v); if (wasEmpty) { notifyAll(); }} 向有限缓存中添加一个元素，在最后调用 notifyAll() 通知正在 wait() 的线程。 对于 notify() 和 notifyAll() 无论调用哪一个，都必须持有与条件队列对象相关联的锁。 调用 notify() 的结果是：JVM 会从在这个条件队列中等待的众多线程中挑选出一个，并把它唤醒。 而调用 notifyAll() 会唤醒所有正在这个条件队列中等待的线程。 由于调用 notify() 和 notifyAll() 时必须持有条件队列对象的锁，这导致等待线程此时不能重新获得锁，无法从 wait() 返回，因此该通知线程应该尽快释放锁，以确保等待线程尽可能快地解除阻塞。 推荐使用 notifyAll()，因为多个线程可能会由于不同的原因在同一个条件队列中等待，调用 notifyAll() 会唤醒所有，而调用 notify() 只会由 JVM 挑选一个唤醒。 2.5 阀门类 开始阀门闭锁(starting gate latch) 二元闭锁： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.concurrent.CountDownLatch;/** * 在时序测试中，使用 CountDownLatch 来启动和停止线程 * * CountDownLatch.class ---- 利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。 */public class TestHarness { /** * 使用 CountDownLatch 来启动和停止线程 * @param nThreads 要启动的线程数 * @param task 线程任务 * @return 线程等待，释放时间 * @throws InterruptedException 当线程等待、休眠或以其他方式被占用，并且线程在活动之前或期间被中断时抛出 */ public long timeTasks(int nThreads, final Runnable task) throws InterruptedException { // 在线程可以通过await()方法之前，计数值为1，需调用countDown()方法的次数为1次 final CountDownLatch startGate = new CountDownLatch(1); // 在线程可以通过await()方法之前，计数值为 nThreads，需调用countDown()方法的次数为 nThreads 次 final CountDownLatch endGate = new CountDownLatch(nThreads); // 通过await()方法需满足：锁计数器为0、线程被中断、或者超过指定的等待时间 // 每调用countDown()方法，计数器减1 for (int i = 0; i &lt; nThreads; i++) { Thread aThread = new Thread() { @Override public void run() { try { // 线程等待 startGate.await(); try { // 启动线程 task.run(); } finally { // 减少锁存器的计数，如果计数达到零，则释放所有等待线程 endGate.countDown(); } } catch (InterruptedException ignored) {} } }; aThread.start(); } long start = System.nanoTime(); // startGate 锁计数器(原本定义为1)，现在调用 countDown() 方法，减去1 // 此时，startGate 的锁计数器为0，可以通过 await() 方法了 // 因此就可以到达 task.run() startGate.countDown(); // endGate 锁计数器原本定义为nThreads，也就是线程个数。 // 程序未出现异常情况，需要调用 countDown() 方法 nThreads 次 // endGate.countDown() 方法在每个线程的 finally {...} 中 // 因此需要 nThreads 个线程都完成，才能使得 锁计数器=0，这个时候才能通过 endGate.await() 方法 endGate.await(); long end = System.nanoTime(); return end - start; }} 这里通过将计数器初始化为1，创建了一个二元闭锁：它只有两种状态，初始状态和终止状态。闭锁会阻止线程通过开始阀门，直到阀门被打开，此时所有的线程都可以通过。 使用 wait 和 notifyAll 实现可重关闭的阀门 1234567891011121314151617181920212223242526272829import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;@ThreadSafepublic class ThreadGate { // 条件谓词: opened-since(n) (isOpen || generation&gt;n) @GuardedBy(&quot;this&quot;) private boolean isOpen; @GuardedBy(&quot;this&quot;) private int generation; public synchronized void close() { isOpen = false; } public synchronized void open() { ++generation; isOpen = true; notifyAll(); } // 阻塞，直到: opened-since(generation on entry) public synchronized void await() throws InterruptedException { int arrivalGeneration = generation; while (!isOpen &amp;&amp; arrivalGeneration == generation) { wait(); } }} 2.6 显式的 Condition 对象Lock 是一个广义的内置锁，而 Condition 也是一种广义的 内置条件队列。 123456789101112131415161718192021222324package java.util.concurrent.locks;public interface Condition { /** 使当前线程等待，直到它发出信号或被中断。 */ void await() throws InterruptedException; /** 使当前线程一直等待，直到它发出信号或中断，或者指定的等待时间过去。 */ boolean await(long time, TimeUnit unit)throws InterruptedException; /** 使当前线程一直等待，直到它发出信号或中断，或者指定的等待时间过去。 */ long awaitNanos(long nanosTimeout) throws InterruptedException; /** 导致当前线程等待，直到它发出信号。 */ void awaitUninterruptibly(); /** 使当前线程等待，直到它发出信号或中断，或指定的截止日期过去。 */ boolean awaitUntil(Date deadline) throws InterruptedException; /** 唤醒一个等待线程。*/ void signal(); /** 唤醒所有等待的线程。 */ void signalAll();} 内部条件队列有一些缺陷。每个内部锁只能有一个与之相关联的条件队列，多个线程可能为了不同的条件谓词在同一个条件队列中等待，而且大多数常见的锁模式都会暴露条件队列对象。这些因素都导致不可能为了使用notifyAll()，而强迫等待线程统一。 如果想编写一个带有多个条件谓词的并发对象，或者想获得除了条件队列可见性之外的更多的控制权，可以使用Lock和Condition，而不是内置锁和内置条件队列。 一个 Conaition 和一个单独的 Lock 相关联，就像条件队列和单独的内部锁相关联一样；调用与 Condition 相关联的 Lock 的 Lock.newConaition() 方法，可以创建一个 Conaition。如同 Lock 提供了比内部加锁要丰富得多的特征集一样，Condition 也提供了比内部条件队列要丰富得多的特征集：每个锁可以有多个等待集、可中断/不可中断的条件等待、基于时限的等待以及公平/非公平队列之间的选择。 不同于内部条件队列，你可以让每个 Lock 都有任意数量的 Condition 对象。 警告: Object 的 wait()、notify() 和notifyAll()方法在 Conaition 中的对等体是 await()、 signal() 和 BignalAll()。 但是 Condition 继承自 Object，这意味着它也有 wait() 和 notify() 方法。 一定要确保使用了正确的版本 —- await() 和 signal() 有限缓存使用显式的条件变量： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;@ThreadSafepublic class ConditionBoundedBuffer &lt;T&gt; { protected final Lock lock = new ReentrantLock(); // 条件谓词: notFull (count &lt; items.length) private final Condition notFull = lock.newCondition(); // 条件谓词: notEmpty (count &gt; 0) private final Condition notEmpty = lock.newCondition(); private static final int BUFFER_SIZE = 100; @GuardedBy(&quot;lock&quot;) private final T[] items = (T[]) new Object[BUFFER_SIZE]; @GuardedBy(&quot;lock&quot;) private int tail, head, count; // 阻塞，直到: notFull public void put(T x) throws InterruptedException { lock.lock(); try { while (count == items.length) { notFull.await(); } items[tail] = x; if (++tail == items.length) { tail = 0; } ++count; notEmpty.signal(); } finally { lock.unlock(); } } // 阻塞直到: notEmpty public T take() throws InterruptedException { lock.lock(); try { while (count == 0) { notEmpty.await(); } T x = items[head]; items[head] = null; if (++head == items.length) { head = 0; } --count; notFull.signal(); return x; } finally { lock.unlock(); } }} Condition 简化了使用单一通知的条件。使用更有效的 signal()，而不是 signalAll()，这就会减少相当数量的上下文转换，而且每次缓存操作都会触发对锁的请求。 3. 剖析 Synchronizer ReentrantLock 和 Semaphore 有很多共同点。这些类都扮演了“阀门”的角色，每次只允许有限数目的线程通过它。 线程到达阀门后 可以允许通过：ReentrantLock.lock()、Semaphore.acquire() 可以等待：lock()方法 或 acquire() 方法阻塞 可以取消：ReentrantLock.tryLock()、Semaphore.tayAcquire() 返回 false，指明在允许的时间内，【锁】或者【许可】不可用 它们都允许可中断的、不可中断的、可限时的请求尝试，它们也都允许选择公平、非公平的等待线程队列。 其实，ReentrantLock 和 Semaphore 都用到了同一个共同的基类：AbstractQueuedSynchronizer AbstractQueuedSynchronizer(AQS) 和其它很多的 Synchronizer 一样，AQS 是一个用来构建锁和 Synchronizer 的框架。 CountDownLatch、ReentrantReadWriteLock 和 FutureTask 都是基于 AQS 构建的。 使用 Lock 实现的计数信号量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;@ThreadSafepublic class SemaphoreOnLock { private final Lock lock = new ReentrantLock(); // 条件谓词: permitsAvailable (permits &gt; 0) private final Condition permitsAvailable = lock.newCondition(); @GuardedBy(&quot;lock&quot;) private int permits; SemaphoreOnLock(int initialPermits) { lock.lock(); try { permits = initialPermits; } finally { lock.unlock(); } } // 阻塞，直到: permitsAvailable public void acquire() throws InterruptedException { lock.lock(); try { while (permits &lt;= 0) { permitsAvailable.await(); } --permits; } finally { lock.unlock(); } } public void release() { lock.lock(); try { ++permits; permitsAvailable.signal(); } finally { lock.unlock(); } }} 在 SemaphoreonLock 中，请求许可的操作在两个地方可能会阻塞 信号量的状态正在被锁保护着 许可不可用 AQS 解决了实现一个 Synchronizer 的大量细节，比如等待线程的 FIFO(First Input, First Output) 队列。单独的 Synchronizer 可以定义一个灵活的标准，用来描述线程是否应该允许通过，还是需要等待。 使用 AQS 构建的 Synchronizer 只可能在一个点上发生阻塞，这样降低了上下文切换的开销，并提高了吞吐量。 4. AbstractQueuedSynchronizer4.1 AbstractQueuedSynchronizer 一个基于 AQS 的 synchronizer 所执行的基本操作，是一些不同形式的获取(acquire） 和释放（release）。 AQS 管理着一个广域状态信息的单一整数，状态信息可以通过 getState()、setState()、compareAndSetState()等方法进行操作 1234567891011121314// 返回同步状态的当前值。此操作具有volatile读取的内存语义protected final int getState() { return state;}// 设置同步状态的值。此操作具有volatile写入的内存语义protected final void setState(int newState) { state = newState;}// 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值。此操作具有volatile读写的内存语义protected final boolean compareAndSetState(int expect, int update) { // ...} ReentrantLock 用它来表现拥有它的线程已经请求了多少次锁 Semaphore 用它来表现剩余的许可数 Futurerask 用它来表现任务的状态（尚未开始、运行、完成和取消） AQS中获取和释放操作的规范式 1234567891011121314151617181920boolean acquire() throws InterruptedException { while (状态不允许获取) { if (阻止获取请求) { 如果尚未排队阻塞当前线程， } else { 否则则将当前线程入队 return failure } } 可能更新同步状态 如果线程已排队，则使线程出队 return success}void release() { 更新同步状态 if (新状态可能允许被阻塞的线程获取) { 解除阻塞一个或多个排队线程 }} 一个获取操作分为两步。第一步，Synchronizer 判断当前状态是否允许被获得：如果是，就让线程执行，如果不是，获取操作阻塞或失败。第二步包括了可能需要更新的状态；一个想获取 synchronizer 的线程会影响到其他线程是否能够获取它。 一个简单的闭锁 12345678910111213141516171819202122232425262728import net.jcip.annotations.ThreadSafe;import java.util.concurrent.locks.AbstractQueuedSynchronizer;@ThreadSafepublic class OneShotLatch { private final Sync sync = new Sync(); public void signal() { sync.releaseShared(0); } public void await() throws InterruptedException { sync.acquireSharedInterruptibly(0); } private class Sync extends AbstractQueuedSynchronizer { protected int tryAcquireShared(int ignored) { // 如果闭锁打开(state == 1)则成功，否则失败 return (getState() == 1) ? 1 : -1; } protected boolean tryReleaseShared(int ignored) { setState(1); // 闭锁现已打开 return true; // 其他线程现在可能能够获取 } }} 4.2 ReentrantLockReentrantLock 只支持独占的获取操作，因此它实现了 tryAcquire()、 tryRelease() 和 isHeldExclusively() 12345678910111213141516171819202122public class ReentrantLock implements Lock, java.io.Serializable { abstract static class Sync extends AbstractQueuedSynchronizer { // 执行不公平的 tryLock final boolean nonfairTryAcquire(int acquires) { // ...... } // 尝试设置状态以反映独占模式下的发布 protected final boolean tryRelease(int releases) { // ...... } // 如果同步仅针对当前（调用）线程进行，则返回true protected final boolean isHeldExclusively() { // ...... } } static final class NonfairSync extends Sync { protected final boolean tryAcquire(int acquires) { return nonfairTryAcquire(acquires); } }} 非公平的 ReentrantLock 中 tryAcquire 的实现 1234567891011121314151617181920212223final boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); // 同步状态的当前值 int c = getState(); if (c == 0) { // 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值 if (compareAndSetState(0, acquires)) { // 设置当前拥有独占访问权限的线程 setExclusiveOwnerThread(current); return true; } } // 返回最后由setExclusiveOwnerThread设置的线程，如果从未设置，则返回null else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); // 设置同步状态的值 setState(nextc); return true; } return false;} 4.3 Semaphore 和 CountDownLatch Semaphore Semaphore 使用 AQS 类型的同步状态持有当前可用许可的数量。Semaphore 的 tryAcquireShared 和 tryAcquire Shared 方法: 1234567891011121314151617181920212223242526272829303132333435363738public class Semaphore implements java.io.Serializable { abstract static class Sync extends AbstractQueuedSynchronizer { // ...... final int nonfairTryAcquireShared(int acquires) { for (;;) { // 同步状态的当前值 int available = getState(); int remaining = available - acquires; // 剩余状态量小于零 if (remaining &lt; 0 || // 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值 compareAndSetState(available, remaining)) return remaining; } } protected final boolean tryReleaseShared(int releases) { for (;;) { // 同步状态的当前值 int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error(&quot;Maximum permit count exceeded&quot;); // 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值 if (compareAndSetState(current, next)) return true; } } // ...... } static final class NonfairSync extends Sync { // ...... protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); } }} nonfairTryAcquireShared() 方法：首先计算剩余许可的数量，如果没有足够的许可，会返回一个值，表明获取操作失败。如果还有充足的许可剩余，nonfairTryAcquireShared 会使用 compareAndsetState()，尝试原子地递减许可的计数。 类似地，tryReleaseShared() 会递增许可计数，这会潜在地解除等待中的线程的阻塞，不断地重试直到成功地更新。tryReleaseShared 的返回值表明，释放操作是否可以解除其他线程的阻塞。 CountDownLatch CountDownLatch 使用 AQS 的方式与 Semaphore 相似，同步状态持有当前的计数： countDown 方法调用 release，后者会导致计数器递减，并且在计数器已经到达零的时候，解除所有等待线程的阻塞 12345678910111213protected boolean tryReleaseShared(int releases) { // 递减计数；转换为零时的信号 for (;;) { // 同步状态的当前值 int c = getState(); if (c == 0) return false; int nextc = c-1; // 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值 if (compareAndSetState(c, nextc)) return nextc == 0; }} await 调用 acquire，如果计数器己经到达零，acquire 会立即返回，否则它会被阻塞。 123protected int tryAcquireShared(int acquires) { return (getState() == 0) ? 1 : -1;} 4.4 ReentrantReadWriteLock ReentrantReadWriteLock 123456789101112131415public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable { private final ReentrantReadWriteLock.ReadLock readerLock; private final ReentrantReadWriteLock.WriteLock writerLock; abstract static class Sync extends AbstractQueuedSynchronizer { static final int SHARED_SHIFT = 16; protected final boolean tryRelease(int releases) { // ...... } protected final boolean tryAcquire(int acquires) { // ...... } }} ReadwriteLock 的接口要求了两个锁，一个读者锁和一个写者锁。在基于 AQS 的 ReentrantReadMriteLock 实现中，一个单独的 AQS 子类管理了读和写的加锁。 ReentrantReadwriteLock 使用一个 16 位的状态为写锁（write-lock）计数，使用另一个 16 位的状态为读锁(read-lock）计数。 对读锁的操作使用共享的获取与释放的方法：对写锁的操作使用独占的获取与释放的方法。","link":"/posts/d3e0.html"},{"title":"Java并发编程实战：第15章 原子变量与非阻塞同步机制","text":"1. 锁的劣势 volatile 变量 volatile 变量与锁相比是更轻量的同步机制，因为它们不会引起上下文的切换和线程调度。 然而，volatile 变量与锁相比有一些局限性：尽管它们提供了相似的可见性保证，但是它们不能用于构建原子化的复合操作。 当一个变量依赖其他变量时，或者当变量的新值依赖于旧值时，是不能用 volatile 变量的。这些都限制了 volatile 变量的使用，因此它们不能用于实现可靠的通用工具，比如计数器，或互斥体(mutex） 例如 i++ 看起来是原子操作(变量的新值依赖于旧值)，事实上有三个独立操作：获取当前值、为该值加一、协会更新值。为了不丢失更新，整个的 读-写-改 操作必须是原子的。 加锁可能存在的缺点 Counter示例： 1234567891011121314151617181920212223import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;/** * Counter 是线程安全的，不过在竞争下，性能回由于上下文切换的开销和调度延迟而收到损失。 * 倘若临时占有锁的线程进入休眠，将会导致其它线程的阻塞。 */@ThreadSafepublic final class Counter { @GuardedBy(&quot;this&quot;) private long value = 0; public synchronized long getValue() { return value; } public synchronized long increment() { if (value == Long.MAX_VALUE) { throw new IllegalStateException(&quot;counter overflow&quot;); } return ++value; }} 加锁还有其它的缺点。当一个线程正在等待锁时，它不能做任何其它事情。 如果一个线程在持有锁的情况下发生了延迟(如：页错误、调度延迟)，那么其它所有需要改锁的线程都不能前进了。 如果阻塞的线程是优先级很高的线程，持有锁的线程优先级较低，那么就导致了优先级倒置(priority inversion) 2. 硬件对并发的支持 乐观锁：乐观锁在操作数据时非常乐观，认为多个线程不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据 独占锁(如ReentrantLock)模式下，每次只能有一个线程能持有锁。它是一项 悲观 保守的加锁策略。 对于细粒度的操作，可以使用乐观锁，在不发生干扰的情况下完成更新操作。 2.1 比较并交换(compare-and-swap) 乐观策略 当多个线程试图使用比较并交换(CAS)，同时更新相同的变量时，其中一个线程会胜出，并且更新变量的值，而其它的线程都会失败。 失败的线程允许尝试再次比较并交换操作。一个线程在竞争 CAS 时失败，不会被阻塞，它可以决定是否重试，这样的灵活性大大减少了锁相关的活跃度风险。 模拟CAS操作 123456789101112131415161718192021222324252627282930313233343536373839404142import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;@ThreadSafepublic class SimulatedCAS { @GuardedBy(&quot;this&quot;) private int value; public synchronized int get() { return value; } /** * 比较并交换。 * 如果旧值等于期望值，那么设置新值(newValue)。 * @param expectedValue 期望值 * @param newValue 新值 * @return 旧值 */ public synchronized int compareAndSwap(int expectedValue, int newValue) { int oldValue = value; // 获取 if (oldValue == expectedValue) { // 比较 value = newValue; // 交换 } return oldValue; } /** * 比较并交换。 * 如果旧值等于期望值，那么设置新值(newValue)。 * 设置新值成功，返回 true，否则返回 false * @param expectedValue 期望值 * @param newValue 新值 * @return 新值设置成功，旧值 == 期望值，返回 true */ public synchronized boolean compareAndSet(int expectedValue, int newValue) { return (expectedValue == compareAndSwap(expectedValue, newValue)); }} 2.2 非阻塞计数器 竞争锁和非竞争锁 当一个线程试图进入另一个线程正在执行的同步块或方法时会触发锁竞争。该线程会被强制进入等待状态，直到第一个线程执行完同步块并且已经释放了监视器。 当同一时间只有一个线程尝试执行同步的代码区域时，锁会保持非竞争的状态。 使用 CAS 实现的非阻塞计数器 1234567891011121314151617181920212223242526272829import net.jcip.annotations.ThreadSafe;@ThreadSafepublic class CasCounter { // CAS private SimulatedCAS value; public int getValue() { return value.get(); } /** 自增 */ public int increment() { int value0; int compareAndSwap; do { // 获取旧值 value0 = this.value.get(); // 比较并交换 // compareAndSwap() 方法 ---- 如果旧值等于期望值()，那么设置新值(newValue)，始终返回旧值 // 旧值：this.value.get()，期望值：value0，新值：value0 + 1 // 多线程环境下，可能上面获取的 value0 已经不等于 this.value.get() 了 compareAndSwap = this.value.compareAndSwap(value0, value0 + 1); // value0 != compareAndSwap 为了确保多线程环境下，数据被其它线程修改，当前线程修改失败，可重新尝试修改 } while (value0 != compareAndSwap); // 返回新值 return value0 + 1; }} Cascounter 利用 CAS 实现了线程安全的计数器。自增操作遊循了经典形式 —- 取得旧值，根据它计算出新值（加1），并使用 CAS 设定新值。如果比较并交换(CAS)失败，立即重试该操作。 对于普通的 Counter 12345678910111213141516import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;@ThreadSafepublic final class Counter { @GuardedBy(&quot;this&quot;) private long value = 0; public synchronized long getValue() { return value; } public synchronized long increment() { return ++value; }} 如果自增，使用 value++ 的形式，那么需要对 increment() 加锁。 自增，使用比较并交换(CAS)的形式，自增失败后进行重试，不采用 increment() 加锁的形式。 比较并交换 compareAndSwap() 方法，加锁了。 基于 CAS 的计数器看起来比基于锁的计数器性能要差一些。CasCounter 有更多的操作和更复杂的控制流，表面看来还依赖于复杂的 CAS 操作。实质情况： CasCounter.increment() 方法没有使用锁，Counter.increment() 方法使用了锁。 CasCounter.increment() 方法，使用了比较并交换(CAS)，比较并交换 compareAndSwap() 方法是加锁的。 CasCounter 到达锁的路径是 CasCounter -&gt; increment() -&gt; compareAndSwap() Counter 到达锁的路径是 Counter -&gt; increment() 在多线程环境下，CasCounter 通过不断尝试以成功，使得对硬件设备的使用率更高；Counter 通过挂起线程，减轻了硬件设备的压力，在硬件设备允许的条件下，CasCounter 性能往往高于 Counter。 加锁的语法可能比较简洁，但是可能会引起系统级的加锁、线程挂起以及上下文切换。 3. 原子变量类 原子变量比锁更精巧，更轻量，并且在多处理器系统中，对实现高性能的并发代码非常关键。 更新原子变量的快速（非竟争）路径，并不会比获取锁的快速路径差，并且通常会更快。 更新原子变量的慢速路径绝对会比锁的慢速路径快，因为它不会引起线程的挂起和重新调度。 在使用原子变量取代锁的算法中，线程更不易出现延迟，如果它们遇到竟争，也更容易恢复。 原子变量类，提供了广义的 volatile 变量，以支持原子的、条件的读-写-改操作。 原子变量类共有12个，分成4组： 基本类型 AtomicBoolean - 布尔类型原子类 AtomicInteger - 整型原子类 AtomicLong - 长整型原子类 引用类型 AtomicReference - 引用类型原子类 AtomicMarkableReference - 带有标记位的引用类型原子类 AtomicStampedReference - 带有版本号的引用类型原子类 数组类型 AtomicIntegerArray - 整形数组原子类 AtomicLongArray - 长整型数组原子类 AtomicReferenceArray - 引用类型数组原子类 属性更新器类型 AtomicIntegerFieldUpdater - 整型字段的原子更新器 AtomicLongFieldUpdater - 长整型字段的原子更新器 AtomicReferenceFieldUpdater - 原子更新引用类型里的字段 3.1 原子变量是“更佳的volatile” NumberRange 例子 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.atomic.AtomicInteger;public class NumberRange { /** 不变约束: lower &lt;= upper */ private final AtomicInteger lower = new AtomicInteger(0); private final AtomicInteger upper = new AtomicInteger(0); /** 设置最低 number */ public void setLower(int i) { // 警告 -- 不安全的 &quot;检查再运行&quot; if (i &gt; upper.get()) { throw new IllegalArgumentException(&quot;can't set lower to &quot; + i + &quot; &gt; upper&quot;); } lower.set(i); } /** 设置最高 number */ public void setUpper(int i) { // 警告 -- 不安全的 &quot;检查再运行&quot; if (i &lt; lower.get()) { throw new IllegalArgumentException(&quot;can't set upper to &quot; + i + &quot; &lt; lower&quot;); } upper.set(i); } /** * 判断 i 是否满足 lower &lt;= i &lt;= upper * @return true or false */ public boolean isInRange(int i) { return (i &gt;= lower.get() &amp;&amp; i &lt;= upper.get()); }} 不能使用原子化的整数来存储边界。因为一个不变约束限制了两个数值，并且它们不能在遵循约束的情况下被同时更新，如果一个值域类使用 volatile 引用，或者使用多个原子化的整数，将会造成不安全的“检查再运行”顺序。 使用 CAS 避免多元的不变约束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import net.jcip.annotations.Immutable;import net.jcip.annotations.ThreadSafe;import java.util.concurrent.atomic.AtomicReference;@ThreadSafepublic class CasNumberRange { @Immutable private static class IntPair { // 不变约束: lower &lt;= upper final int lower; final int upper; public IntPair(int lower, int upper) { this.lower = lower; this.upper = upper; } } private final AtomicReference&lt;IntPair&gt; values = new AtomicReference&lt;IntPair&gt;(new IntPair(0, 0)); public int getLower() { return values.get().lower; } public int getUpper() { return values.get().upper; } public void setLower(int i) { while (true) { IntPair oldValue = values.get(); if (i &gt; oldValue.upper) { throw new IllegalArgumentException(&quot;Can't set lower to &quot; + i + &quot; &gt; upper&quot;); } IntPair newValue = new IntPair(i, oldValue.upper); // 使用比较并替换(CAS) if (values.compareAndSet(oldValue, newValue)) { return; } } } public void setUpper(int i) { while (true) { IntPair oldValue = values.get(); if (i &lt; oldValue.lower) { throw new IllegalArgumentException(&quot;Can't set upper to &quot; + i + &quot; &lt; lower&quot;); } IntPair newValue = new IntPair(oldValue.lower, i); // 使用比较并替换(CAS) if (values.compareAndSet(oldValue, newValue)) return; } }} 把 OnevalueCache 的技术结合到原子化引用中，通过原子化地更新持有上下边界的不变类的引用，来缩小竞争条件。CasNumberRange 使用了 AtomicReference 和 IntPair 来保持状态：通过使用 compareAndSet，它能够避开 NumberRange 的竞争条件，更新上下界。 3.2 性能比较：锁与原子变量 使用 ReentrantLock 实现随机数字生成器 1234567891011121314151617181920212223242526272829import net.jcip.annotations.ThreadSafe;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * ReentrantLock 模拟生成随机数 */@ThreadSafepublic class ReentrantLockPseudoRandom extends PseudoRandom { private final Lock lock = new ReentrantLock(false); private int seed; ReentrantLockPseudoRandom(int seed) { this.seed = seed; } public int nextInt(int n) { lock.lock(); try { int s = seed; seed = calculateNext(s); int remainder = s % n; return remainder &gt; 0 ? remainder : remainder + n; } finally { lock.unlock(); } }} 使用 AtomicInteger 实现随机数字生成器 1234567891011121314151617181920212223import net.jcip.annotations.ThreadSafe;import java.util.concurrent.atomic.AtomicInteger;@ThreadSafepublic class AtomicPseudoRandom extends PseudoRandom { private AtomicInteger seed; AtomicPseudoRandom(int seed) { this.seed = new AtomicInteger(seed); } public int nextInt(int n) { while (true) { int s = seed.get(); int nextSeed = calculateNext(s); if (seed.compareAndSet(s, nextSeed)) { int remainder = s % n; return remainder &gt; 0 ? remainder : remainder + n; } } }} 锁通过挂起线程来影响竞争，将小了CPS的利用和功效内存总线上的同步通信量。原子变量吧竞争光里退回给调用类。与大多数基于 CAS 的算法相比，AtomicPseudoRandom 通过不断反复尝试来响应竞争，在激烈竞争环境下会带来更多的竞争。 图中为书作者研究 Lock 和 AtomicInteger 在激烈竞争下的性能比较。不存在任何一个程序，除了竞争锁或原子变量，其它什么都不做。在实践中，原子化的伸缩性比锁更好(硬件的影响对原子化伸缩性影响较大)。 锁与原子化随竞争度的不同，性能发生的改变阐明了各自的优势和劣势。在中低程度的竞争下，原子化提供更好的可伸缩性；在高强度的竞争下，锁能够更好地帮助我们避免竞争。 4. 非阻塞算法 非阻塞(nonblocking)算法：一个线程的失败或挂起不应该影响其他线程的失败或挂起 锁自由(lock-frce)算法：如果算法的每一步骤中都有一些线程能够继续执行，那么这样的算法称为锁自由算法。 在线程间使用 CAS 进行协调，这样的算法如果能构建正确的话，它既是非阻塞的， 又是锁自由的。 4.1 非阻塞栈 实现同等功能前提下，非阻塞算法被认为比基于锁的算法更加复杂。创建非阻寨算法的前提是为维护数据的一致性，解决如何把原子化范围缩小到一个唯一变量。 非阻塞算法的特性：某项工作的完成具有不确定性，必须重新执行。 非阻塞算法中能确保线程安全性，因为 compareAndSet 像锁定机制一样，既能提供原子性，又能提供可见性。 使用 Treiber 算法 (Treiber, 1986) 的非阻塞栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import net.jcip.annotations.ThreadSafe;import java.util.concurrent.atomic.AtomicReference;/** 使用链表实现栈 */@ThreadSafepublic class ConcurrentStack&lt;E&gt; { AtomicReference&lt;Node&lt;E&gt;&gt; top = new AtomicReference&lt;Node&lt;E&gt;&gt;(); public void push(E item) { Node&lt;E&gt; newHead = new Node&lt;E&gt;(item); Node&lt;E&gt; oldHead; boolean cas = false; do { // 当前栈顶 oldHead = top.get(); // 新栈顶 newHead.next = oldHead; // 比较并交换 // 如果当前值(top.get()) == 期望值(oldHead)，则自动将值设置为给定的更新值(newHead)。 cas = top.compareAndSet(oldHead, newHead); } while (!cas); } public E pop() { Node&lt;E&gt; oldHead; Node&lt;E&gt; newHead; boolean cas = false; do { oldHead = top.get(); if (oldHead == null) { return null; } newHead = oldHead.next; // 比较并交换 // 如果当前值(top.get()) == 期望值(oldHead)，则自动将值设置为给定的更新值(newHead)。 cas = top.compareAndSet(oldHead, newHead); } while (!cas); return oldHead.item; } /** 链表 */ private static class Node&lt;E&gt; { public final E item; public Node&lt;E&gt; next; public Node(E item) { this.item = item; } }} 4.2 非阻塞链表一个链表比栈更加复杂，因为它需要支持首尾的快速访问。为了实现，它会维护独立的队首指针和队尾指针。两个指针初始时都指向队列的末尾节点。在成功加入新元素时，两个节点都需要更新 —- 原子化更新。 Michael-Scott 非阻塞队列算法中的插入(Michael 与 Scott, 1996) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import net.jcip.annotations.ThreadSafe;import java.util.concurrent.atomic.AtomicReference;@ThreadSafepublic class LinkedQueue &lt;E&gt; { private final Node&lt;E&gt; dummy = new Node&lt;E&gt;(null, null); private final AtomicReference&lt;Node&lt;E&gt;&gt; head = new AtomicReference&lt;Node&lt;E&gt;&gt;(dummy); private final AtomicReference&lt;Node&lt;E&gt;&gt; tail = new AtomicReference&lt;Node&lt;E&gt;&gt;(dummy); public boolean putHead(E item) { Node&lt;E&gt; newHead = new Node&lt;E&gt;(item, null); while (true) { // 链表头节点 Node&lt;E&gt; curHead = head.get(); // 保证 curHead 还是链表头节点 if (curHead == head.get()) { // 向头部插入新节点 if (newHead.next.compareAndSet(null, curHead)) { // 头部节点向前移动一位 return head.compareAndSet(curHead, newHead); } } } } public boolean putTail(E item) { Node&lt;E&gt; newNode = new Node&lt;E&gt;(item, null); while (true) { // 链表尾节点 Node&lt;E&gt; curTail = tail.get(); // 链表尾节点指向下一个节点的指针 Node&lt;E&gt; tailNext = curTail.next.get(); // 保证前面获取的尾巴后面没有插入新的节点 if (curTail == tail.get()) { // 前面获取的尾巴后面已经插入了新的节点 if (tailNext != null) { // 将尾巴向后移动一位 tail.compareAndSet(curTail, tailNext); // 前面获取的尾巴后面还未插入了新的节点，向尾巴后面插入新节点 } else if (curTail.next.compareAndSet(null, newNode)) { // 插入成功，将尾巴向后移动一位 return tail.compareAndSet(curTail, newNode); } } } } private static class Node &lt;E&gt; { final E item; final AtomicReference&lt;Node&lt;E&gt;&gt; next; public Node(E item, Node&lt;E&gt; next) { this.item = item; this.next = new AtomicReference&lt;Node&lt;E&gt;&gt;(next); } }} 4.3 原子化的域更新器原子的域更新器类表示现有volatile域的一种基于反射的“视图”，从而能够在已有的volatile域上使用CAS。 在 ConcurrentLinkedQueue 中使用原子化的域更新器 1234567891011private class Node&lt;E&gt; { private final E item; private volatile Node&lt;E&gt; next; public Node(E item) { this.item = item; }}private static AtomicReferenceFieldUpdater nextUpdater // 用来对next字段进行更新 = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, &quot;next&quot;); 4.4 ABA 问题 ABA 问題是因为在算法中误用比较并交换而引起的反常现象，节点被循环使用 解决：更新一对值，包括引用和版本号，而不是仅更新该值的引用。","link":"/posts/6a33.html"},{"title":"Java并发编程实战：第2章 线程安全性","text":"1. 什么是线程安全性下载资源 jar；https://repo1.maven.org/maven2/org/lucee/jcip-annotations/1.0.0/jcip-annotations-1.0.0.jar 先创建Java Web Module File -&gt; New -&gt; Module... Java -&gt; Next -&gt; Finish 选中创建的 Model -&gt; 右键选择 Add Framework Support... -&gt; 选择 Web Application -&gt; ok 配置 Tomcat Run -&gt; Edit Configurations... -&gt; Add New Configuration -&gt; Tomcat Server -&gt; Local 添加 Artifacts 刚刚添加的 Tomcat 配置 -&gt; Deployment -&gt; Deploy at the server starup -&gt; Add -&gt; Artifact... -&gt; ok 添加 tomcat 相关的 jar File -&gt; Project Structure -&gt; Modules -&gt; 选中创建的 Model -&gt; Dependencies -&gt; Add -&gt; Library... -&gt; Application Server Libraries -&gt; Tomcat *** -&gt; Add Selected -&gt; ok 1.1 一个无状态的 ServletJava 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import javax.servlet.GenericServlet;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import java.io.IOException;import java.math.BigInteger;import java.util.Arrays;/** * Created by osys on 2022/08/28 21:48. */public class StatelessFactories extends GenericServlet implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { BigInteger i = extractFromRequest(servletRequest); BigInteger[] factories = factor(i); encodeIntoResponse(servletResponse, factories); System.out.println(&quot;Input：&quot; + servletRequest.getParameter(&quot;demo&quot;)); System.out.println(&quot;i=&quot; + i.toString()); System.out.println(&quot;factories=&quot; + Arrays.toString(factories)); } @Override public String getServletInfo() { return null; } @Override public void destroy() { } void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) { } BigInteger extractFromRequest(ServletRequest req) { return new BigInteger(&quot;7&quot;); } BigInteger[] factor(BigInteger i) { return new BigInteger[] { i }; }} web.xml 配置： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!-- 配置和映射servlet --&gt; &lt;servlet&gt; &lt;!-- servlet注册的名字 --&gt; &lt;servlet-name&gt;demoServlet&lt;/servlet-name&gt; &lt;!-- servlet的全类名--&gt; &lt;servlet-class&gt;StatelessFactories&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- 需要和某一个servlet节点的servlet子节点的文本节点一致 --&gt; &lt;servlet-name&gt;demoServlet&lt;/servlet-name&gt; &lt;!-- 映射具体 的访问路径: / 代表当前web应用的根目录 --&gt; &lt;url-pattern&gt;/Demo&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; index.jsp 代码： 1234567891011121314151617181920212223242526&lt;%-- Created by IntelliJ IDEA. User: osys Date: 2022/3/25 Time: 16:24 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form name=&quot;f1&quot; id=&quot;f1&quot; action=&quot;${pageContext.request.contextPath}/Demo&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;创建数组:&lt;/td&gt; &lt;td&gt;&lt;label for=&quot;demo&quot;&gt;&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;demo&quot; id=&quot;demo&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 运行 Tomcat，访问 http://localhost:8080/ 随意输入 1234 并提交，页面跳转到 http://localhost:8080/Demo 控制台 output： 123Input:1234i=7factories=[7] 访问 StatelessFactories 的线程不会影响另一个访问同一个 StatelessFactories 的线程的计算结果，因为两个线程并没有共享状态。 由于线程访问无状态对象的行为并不会影响其他线程中操作的正确性，因此无状态对象是线程安全的。 说明： 有状态对象(Stateful Bean)：有数据存储功能。是有实例变量的对象，可以保存数据，是 非线程安全 的。在不同方法调用间不保留任何状态。 无状态对象(Stateless Bean)：一次操作，不能保存数据。是没有实例变量的对象，不能保存数据，是不变类，是 线程安全 的。 2. 原子性原子性：原子性是指操作是不可分的。如 count++ 涉及 读取-修改-写入 的操作序列，因此它并不是一个不可分割的操作。 竞态条件(Race Condition) :计算的正确性取决于多个线程的交替执行时序时,就会发生竞态条件。 2.1 常见竞态条件 先检测后执行 执行依赖于检测的结果,而检测结果依赖于多个线程的执行时序,而多个线程的执行时序通常情况下是不固定不可判断的,从而导致执行结果出现各种问题。 123456789101112131415例如：如果不存在 test.txt 文件，创建一个 test.txt 文件---- 不存在 test.txt 文件 --------A 进程发现文件 test.txt 不存在同时，B 程也发现 文件 test.txt 不存在于是 A进程，先创建 test.txt 文件不过 B 进程不知道 A 进程以及 创建了 test.txt 文件最后 B 进程创建 test.txt 文件将 A 进程创建的 test.txt 文件给替换掉了 延迟初始化 延迟初始化，是将对象的初始化操作推迟到实际使用时才进行。同时确保只被初始化一次 2.2 在没有同步的情况下统计已处理请求数量的 Servlet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import net.jcip.annotations.NotThreadSafe;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import java.io.IOException;import java.math.BigInteger;import java.util.Arrays;/** * Created by osys on 2022/08/28 21:48. */@NotThreadSafepublic class UnsafeCountingFactories implements Servlet { private long count = 0; @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { BigInteger i = extractFromRequest(servletRequest); BigInteger[] factories = factor(i); ++count; encodeIntoResponse(servletResponse, factories); System.out.println(&quot;Input:&quot; + servletRequest.getParameter(&quot;demo&quot;)); System.out.println(&quot;i=&quot; + i.toString()); System.out.println(&quot;factories=&quot; + Arrays.toString(factories)); System.out.println(count); } public long getCount() { return count; } void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) { } public BigInteger extractFromRequest(ServletRequest req) { return new BigInteger(&quot;7&quot;); } public BigInteger[] factor(BigInteger i) { return new BigInteger[] { i }; } @Override public String getServletInfo() { return null; } @Override public void destroy() { }} index.jsp 1234567891011121314151617181920212223242526&lt;%-- Created by IntelliJ IDEA. User: osys Date: 2022/3/25 Time: 16:24 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form name=&quot;f1&quot; id=&quot;f2&quot; action=&quot;${pageContext.request.contextPath}/Demo2&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;创建数组:&lt;/td&gt; &lt;td&gt;&lt;label for=&quot;demo2&quot;&gt;&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;demo2&quot; id=&quot;demo2&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; web.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;!-- servlet注册的名字 --&gt; &lt;servlet-name&gt;demoServlet2&lt;/servlet-name&gt; &lt;!-- servlet的全类名--&gt; &lt;servlet-class&gt;UnsafeCountingFactories&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- 需要和某一个servlet节点的servlet子节点的文本节点一致 --&gt; &lt;servlet-name&gt;demoServlet2&lt;/servlet-name&gt; &lt;!-- 映射具体 的访问路径: / 代表当前web应用的根目录 --&gt; &lt;url-pattern&gt;/Demo2&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 运行 Tomcat，访问 http://localhost:8080/ 多个页面同时进行 —- 随意输入 1234 并提交，页面跳转到 http://localhost:8080/Demo 线程不安全。 2.3 延迟初始化中的竞态条件延迟初始化 —- 先检查后执行 对于两个类 12345678910111213@NotThreadSafepublic class LazyInitRace { private ExpensiveObject instance = null; public ExpensiveObject getInstance() { return instance; } public void setInstance(ExpensiveObject instance) { instance = instance; }} 12345public class ExpensiveObject { public ExpensiveObject() { System.out.println(Thread.currentThread().getName() + &quot;----------------------- 创建了一个 ExpensiveObject 对象&quot;); }} 实现 Runnable 接口 12345678910111213141516public static class MyThread implements Runnable { private LazyInitRace lazyInitRace; public MyThread(LazyInitRace lazyInitRace) { this.lazyInitRace = lazyInitRace; } @Override public void run() { // 如果 ExpensiveObject == null，那么创建 ExpensiveObject 对象 if (lazyInitRace.getInstance() == null) { lazyInitRace.setInstance(new ExpensiveObject()); } }} 创建多线程 1234567891011public class LazyInitRaceDemo { private static final MyThread thread = new MyThread(new LazyInitRace()); public static void main(String[] args) { // 启动两个线程 Thread myThread1 = new Thread(thread, &quot;线程1&quot;); Thread myThread2 = new Thread(thread, &quot;线程2&quot;); myThread1.start(); myThread2.start(); }} Debug: 执行 start() 前 对于两个不同的进程，指向的都是同一个 LazyInitRaceDemo$MyThread ，即对应的 lazyInitRace 为同一个，此时 lazyInitRace 里面的成员变量 instance = null。 Output 12线程1----------------------- 创建一个 ExpensiveObject 对象线程2----------------------- 创建一个 ExpensiveObject 对象 说明： start()，线程1发现 instance = null，于是进行 lazyInitRace.setInstance(new ExpensiveObject()); 同时，start()，线程2也发现 instance = null，于是也进行 lazyInitRace.setInstance(new ExpensiveObject()); 2.4 避免竞态条件问题要避免这个问题，就必须在某个线程修改改变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态过程中。 使用 AtomicLong 类型的变量，来统计已处理请求的数量： java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import net.jcip.annotations.ThreadSafe;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import java.io.IOException;import java.math.BigInteger;import java.util.Arrays;import java.util.concurrent.atomic.AtomicLong;/** * Created by osys on 2022/08/28 21:48. */@ThreadSafepublic class CountingFactories implements Servlet { private final AtomicLong count = new AtomicLong(0); public long getCount() { return count.get(); } void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) { } public BigInteger extractFromRequest(ServletRequest req) { return new BigInteger(&quot;7&quot;); } public BigInteger[] factor(BigInteger i) { return new BigInteger[] { i }; } @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { BigInteger i = extractFromRequest(servletRequest); BigInteger[] factories = factor(i); count.incrementAndGet(); encodeIntoResponse(servletResponse, factories); System.out.println(&quot;Input:&quot; + servletRequest.getParameter(&quot;demo&quot;)); System.out.println(&quot;i=&quot; + i.toString()); System.out.println(&quot;factories=&quot; + Arrays.toString(factories)); System.out.println(count); } @Override public String getServletInfo() { return null; } @Override public void destroy() { }} index.jsp 1234567891011121314151617181920212223242526&lt;%-- Created by IntelliJ IDEA. User: osys Date: 2022/3/25 Time: 16:24 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form name=&quot;f3&quot; id=&quot;f3&quot; action=&quot;${pageContext.request.contextPath}/Demo3&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;创建数组:&lt;/td&gt; &lt;td&gt;&lt;label for=&quot;demo3&quot;&gt;&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;demo3&quot; id=&quot;demo3&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; web.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;!-- servlet注册的名字 --&gt; &lt;servlet-name&gt;demoServlet3&lt;/servlet-name&gt; &lt;!-- servlet的全类名--&gt; &lt;servlet-class&gt;CountingFactories&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- 需要和某一个servlet节点的servlet子节点的文本节点一致 --&gt; &lt;servlet-name&gt;demoServlet3&lt;/servlet-name&gt; &lt;!-- 映射具体 的访问路径: / 代表当前web应用的根目录 --&gt; &lt;url-pattern&gt;/Demo3&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 运行 Tomcat，访问 http://localhost:8080/ 多个页面同时进行 —- 随意输入 1234 并提交，页面跳转到 http://localhost:8080/Demo 线程安全。 通过使用 AtomicLong 来代替 long 类型的计数器，能够确保所有对计数器状态的访问操作都是原子的。 3. 加锁机制3.1 程序 2-5在没有足够原子性保证的情况下对其最近计算结果进行缓存 java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import net.jcip.annotations.NotThreadSafe;import javax.servlet.GenericServlet;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import java.io.IOException;import java.math.BigInteger;import java.util.Arrays;import java.util.concurrent.atomic.AtomicReference;/** * Created by osys on 2022/08/28 21:48. */@NotThreadSafepublic class UnsafeCachingFactories extends GenericServlet implements Servlet { private final AtomicReference&lt;BigInteger&gt; lastNumber = new AtomicReference&lt;&gt;(); private final AtomicReference&lt;BigInteger[]&gt; lastFactor = new AtomicReference&lt;&gt;(); @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() {return null;} @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { BigInteger i = extractFromRequest(servletRequest); if (lastNumber.get().equals(i)) { encodeIntoResponse(servletResponse, lastFactor.get()); } else { BigInteger[] factors = factor(i); lastNumber.set(i); lastFactor.set(factors); encodeIntoResponse(servletResponse, factors); } System.out.println(lastNumber.get() + &quot;-------------------------&quot;); System.out.println(Arrays.toString(lastFactor.get()) + &quot;-------------------------&quot;); } void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) { } BigInteger extractFromRequest(ServletRequest req) { return new BigInteger(&quot;7&quot;); } BigInteger[] factor(BigInteger i) { return new BigInteger[]{i}; } @Override public String getServletInfo() {return null;} @Override public void destroy() {}} index.jsp 1234567891011121314151617181920212223242526&lt;%-- Created by IntelliJ IDEA. User: osys Date: 2022/3/25 Time: 16:24 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form name=&quot;f4&quot; id=&quot;f4&quot; action=&quot;${pageContext.request.contextPath}/Demo4&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;创建数组:&lt;/td&gt; &lt;td&gt;&lt;label for=&quot;demo4&quot;&gt;&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;demo4&quot; id=&quot;demo4&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; web.xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;!-- servlet注册的名字 --&gt; &lt;servlet-name&gt;demoServlet4&lt;/servlet-name&gt; &lt;!-- servlet的全类名--&gt; &lt;servlet-class&gt;UnsafeCachingFactories&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- 需要和某一个servlet节点的servlet子节点的文本节点一致 --&gt; &lt;servlet-name&gt;demoServlet4&lt;/servlet-name&gt; &lt;!-- 映射具体 的访问路径: / 代表当前web应用的根目录 --&gt; &lt;url-pattern&gt;/Demo4&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 程序中，有这么一段代码： 12345678private final AtomicReference&lt;BigInteger&gt; lastNumber = new AtomicReference&lt;&gt;();private final AtomicReference&lt;BigInteger[]&gt; lastFactor = new AtomicReference&lt;&gt;();......BigInteger[] factors = factor(i);lastNumber.set(i);lastFactor.set(factors); 对于 lastNumber 和 lastFactor ，这些原子引用本身是线程安全的。 不过 lastNumber 又做为 lastFactor 的基数。这是线程不安全的。 简单的理解： lastNumber.set(i); 和 lastFactor.set(factors); 两个无法同时进行。即是可拆分的。因此对于 UnsafeCachingFactories 是非原子的。线程不安全。 如果只对其中一个值修改，那么在两次修改操作之间，其他线程将发现不变性条件被破坏了。 同样，我们也不能保证会同时获取两个值：在线程A获取这两个值的过程中，线程B修改了它们，这样线程A也会发现不变性条件被破坏了。 3.2 内置锁（互斥锁）Java 提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block） 同步代码块包含两个部分： 锁的对象引用 锁保护的代码块 线程进入同步代码块之前，会自动获得锁，并且在退出同步代码块时，自动释放锁。 同步代码块的锁是，方法调用所在的对象。静态同步代码块，则以Class对象作为锁。 能正确地缓存最新的计算记过，但并发性却非常糟糕： java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import java.io.IOException;import java.math.BigInteger;import java.util.Arrays;import java.util.concurrent.atomic.AtomicReference;/** * Created by osys on 2022/08/28 21:48. */@ThreadSafepublic class SynchronizedFactories implements Servlet { @GuardedBy(&quot;this&quot;) private final AtomicReference&lt;BigInteger&gt; lastNumber = new AtomicReference&lt;&gt;(); @GuardedBy(&quot;this&quot;) private final AtomicReference&lt;BigInteger[]&gt; lastFactor = new AtomicReference&lt;&gt;(); @Override public void init(ServletConfig servletConfig) throws ServletException {} @Override public ServletConfig getServletConfig() {return null;} @Override public synchronized void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { BigInteger i = extractFromRequest(servletRequest); if (!lastNumber.get().equals(i)) { BigInteger[] factors = factor(i); lastNumber.set(i); lastFactor.set(factors); encodeIntoResponse(servletResponse, factors); } else { encodeIntoResponse(servletResponse, lastFactor.get()); } System.out.println(lastNumber.get() + &quot;-----------------------&quot;); System.out.println(Arrays.toString(lastFactor.get()) + &quot;-----------------------&quot;); } void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) { } BigInteger extractFromRequest(ServletRequest req) { return new BigInteger(&quot;7&quot;); } BigInteger[] factor(BigInteger i) { return new BigInteger[]{i}; } @Override public String getServletInfo() {return null;} @Override public void destroy() {}} index.jsp: 1234567891011121314151617181920212223242526&lt;%-- Created by IntelliJ IDEA. User: osys Date: 2022/3/25 Time: 16:24 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form name=&quot;f5&quot; id=&quot;f5&quot; action=&quot;${pageContext.request.contextPath}/Demo5&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;创建数组:&lt;/td&gt; &lt;td&gt;&lt;label for=&quot;demo5&quot;&gt;&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;demo5&quot; id=&quot;demo5&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; web.xml: 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;!-- servlet注册的名字 --&gt; &lt;servlet-name&gt;demoServlet5&lt;/servlet-name&gt; &lt;!-- servlet的全类名--&gt; &lt;servlet-class&gt;SynchronizedFactories&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- 需要和某一个servlet节点的servlet子节点的文本节点一致 --&gt; &lt;servlet-name&gt;demoServlet5&lt;/servlet-name&gt; &lt;!-- 映射具体 的访问路径: / 代表当前web应用的根目录 --&gt; &lt;url-pattern&gt;/Demo5&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.3 重入 内置锁时可重入的。针对 某个线程，可以在 该线程 未释放 该锁 的同时，获取同 该锁 多次。 如果某个线程试图获得一个已经被自己持有的锁，那么这个请求就会成功。 重入的一种实现方式： 每个所关联一个 获取计数值 和 一个 所有者线程 。 当计数为 0 时，没有被任何线程持有。 当线程请求一个未被持有的锁时，JVM记录下锁的持有者，并且将获取计数值设置为1。 如果同一个线程再次获取这个锁，计数值将递增。 反之，当线程退出同步代码块时，计数器会相应的递减。 当计数值为 0 时，这个锁将被释放。 如果内置锁是不可重入的，那么这段代码将发生死锁 java 1234567891011import net.jcip.annotations.ThreadSafe;/** * Created by osys on 2022/08/28 21:48. */@ThreadSafepublic class Widget { public synchronized void doSomething() { System.out.println(&quot;父类，做某些事&quot;); }} 12345678910111213import net.jcip.annotations.ThreadSafe;/** * Created by osys on 2022/08/28 21:48. */@ThreadSafepublic class LoggingWidget extends Widget { @Override public synchronized void doSomething() { System.out.println(&quot;子类，做某些事&quot;); super.doSomething(); }} 这里 子类 重写了 父类 的方法，然后又调用了 父类 的方法。 如果没有可重入的锁： 每次执行 LoggingWidget.doSomething() 前，都会去获取 Widget 上的锁。 然而（如果）锁不可重入，那么在调用 super.doSomething() 时，将无法获得 Widget 上的锁，因为这个锁已经被持有了 因此，线程会永远停顿下去，等待一个永远也无法获得的锁。 重入避免了这周情况的发生。","link":"/posts/406e.html"},{"title":"Java并发编程实战：第3章 对象的共享","text":"1. 可见性其实关键字 synchronized 关键字不仅仅能用于实现原子性或者确定 “临界区（Critical Section）” 同步还有另一个重要的方面：内存可见性（Memory Visibility）。 我们不仅希望防止某个线程正常使用对象状态而另一个线程再同时修改该状态，而且希望确保当一个线程修改了对象状态之后，其他线程能够看到发生状态变化。我们可以通过同步或者类库中内置的同步保证对象安全地发布。 1.1 可见性 对于单线程而言，如果向某个变量先写入值，然后在没有其他写入操作的情况下，读取这个变量，其值是正确的。 多线程中。读操作、写操作，在不同的线程中执行，可能会导致读写不一致问题。 12345678data=11. 线程A，读取data=12. 线程A，修改data=2（还未写入）3. 线程B，读取data=14. 线程A，写入data=2（此时data值为2）此时线程B读取的内容是data=1，而线程A已经将data修改为2了 1.2 在没有同步的情况下共享变量12345678910111213141516171819202122232425262728293031323334353637/** * Created by osys on 2022/08/28 21:48. */public class NoVisibility { /** 默认值为 false */ private static boolean ready; /** 默认值为 0 */ private static int number; private static class ReaderTread extends Thread { @Override public void run() { this.setName(&quot;Reader&quot;); while (!ready) { /* 当一个线程使用了 Thread.yield() 方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行。 打个比方： 现在有很多人在排队上厕所，好不容易轮到这个人上厕所了，突然这个人说：“我要和大家来个竞赛，看谁先抢到厕所！”。 然后所有的人在同一起跑线冲向厕所，有可能是别人抢到了，也有可能他自己有抢到了。 我们还知道线程有个优先级的问题，那么手里有优先权的这些人就一定能抢到厕所的位置吗? 不一定的，他们只是概率上大些，也有可能没特权的抢到了。 */ Thread.yield(); } System.out.println(number); } } // main 线程 public static void main(String[] args) { // Reader 线程 new ReaderTread().start(); number = 66; ready = true; }} 这里一共有两个线程，Main 线程和 Reader 线程 当多个线程在没有同步的情况下共享数据时，Main 线程和 Reader 线程都将访问共享变量 ready 和 number Main 线程启动 Reader 线程，然后将 number 设为66，并将 ready 设为 true。 Reader 线程一直循环直到发现 ready 的值变为true，然后输出 number 的值。 虽然 NoVisibility 看起来会输出66，但事实上很可能输出 0，或者根本无法终止。 这是因为在代码中没有使用足够的同步机制，因此无法保证主线程写入的 ready 值和 number 值对于读线程来说是可见的。 1.3 失效数据12345678data=11. 线程A，读取data=12. 线程A，修改data=2（还未写入）3. 线程B，读取data=14. 线程A，写入data=2（此时data值为2）此时线程B读取的内容是data=1，而线程A已经将data修改为2了 当线程A，和线程B获取的 data 数据均为 1 时。线程A对数据进行更改，此时线程B中获取的 data=1 数据为失效数据。 程序清单 3-2、3-3 1234567891011121314151617import net.jcip.annotations.NotThreadSafe;/** * Created by osys on 2022/08/28 21:48. */@NotThreadSafepublic class MutableInteger { private Integer value; public Integer getValue() { return value; } public void setValue(Integer value) { this.value = value; }} 线程不安全：MutableInteger.java 12345678910111213141516171819import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;/** * Created by osys on 2022/08/28 21:48. */@ThreadSafepublic class SynchronizedInteger { @GuardedBy(&quot;this&quot;) private Integer value; public synchronized Integer getValue() { return value; } public synchronized void setValue(Integer value) { this.value = value; }} 这里使用了两个同步代码块，来进行get、set操作。不过针对不同线程分别调用这两个方法，还是换出现数据安全性问题（失效值）。 1.4 非原子的 64 位操作计算机中存储数据和计算数据都是基于二进制来做的。在 Java 的基本数据类型中，long 和 double 是 64 位的。 类型 占用字节 占用位数 数值长度 byte 1 8 -128~127(-2的7次方到2的7次方-1) short 2 16 -32768~32767(-2的15次方到2的15次方-1) int 4 32 -2的31次方到2的31次方-1 long 8 64 -2的63次方到2的63次方-1 float 4 32 （e-45是乘以10的负45次方，e+38是乘以10的38次方) （2的-149次方~2的128次方-1） double 8 64 (2的-1074次方 ~ 2的1024次方) char 2 16 boolean 1 位数中，不同位代表的含义不一样，有符号位，指数位，尾数位。 非原子的 64 位操作 最低安全性：当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的，而不再一个随机值。 Java内存模型要求，变量的读取操作和写入操作都必须是原子操作。对于非 volatile 类型的 64 位数值变量(long、double)，JVM允许将64位的读操作或写操作分解为两个32为的操作。 当读取一个非 volatile 类型的 64 位数值变量(long、double) 时，如果对改变了的 读 操作和 写 操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。 因此，即使不考虑失效数据问题，在多线程中使用共享且可变的long、double 等类型的变量也是不安全的，需要用 volatile 关键字来声明，或者用 锁 保护起来。 1.5 加锁与可见性内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。 当线程A执行某个同步代码块时，线程B随后进入由同一个锁保护的同步代码块。 在这种情况下可以保证，当线程B执行由锁保护的同步代码块时，可以看到前面线程A在同一个在代码块中的所有操作结果。 其实这就是为了确保某个线程写入该变量的值，对于其他线程来说都是可见的。 2. Volatile 关键字2.1 什么是重排序 在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。 1源代码 --&gt; 编译器优化的重排序 --&gt; 指令级并行的重排序 --&gt; 内存系统的重排序 --&gt; 最终指向指令 编译器优化的重排序 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序 处理器将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序 处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行。 2.2 可见性简单的理解，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。 2.3 volatile 关键字Java 中一种稍弱的同步机制。用来确保将变量的更新操作通知到其他线程。 简单理解就是，读取 volatile 变量，总数返回最新写入的值。 对于以下代码： 12345678910111213141516171819import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;/** * Created by osys on 2022/08/28 21:48. */@ThreadSafepublic class SynchronizedInteger { @GuardedBy(&quot;this&quot;) private Integer value; public synchronized Integer getValue() { return value; } public synchronized void setValue(Integer value) { this.value = value; }} 可以将其修改位用 volatile 关键字修饰： 12345678910111213141516171819import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;/** * Created by osys on 2022/08/28 21:48. */@ThreadSafepublic class SynchronizedInteger { @GuardedBy(&quot;this&quot;) private volatile Integer value; public Integer getValue() { return value; } public void setValue(Integer value) { this.value = value; }} 被 volatile 修饰的变量，编译器与运行时，都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。 在访问 volatile 变量时，不会执行加锁操作，因此也就不会指向线程阻塞，因此 volatile 变量是一种比 synchronized 关键字更轻量级的同步机制。 2.4 分析 volatile 变量从内存可见性的角度来看，写入 volatile 变量相当于退出同步代码块，读取 volatile 变量相当于进入同步代码块。 12volatile int value1 = 666;int value2 = 123; 非 volatile 变量可以这样理解： 1234567单线程：1. 平时修改数据(value2)，首先读取数据（将value2拷贝一份出来） --- 每个线程读取都会拷贝一份value2=1232. 对(将value2=123) 拷贝出来的数据进行修改，value2=4563. 然后将 value2=456 写入到本体中，完成了修改操作多线程：4. 如果多线程情况下，每个线程同时读取，分别都拷贝了一份(value2=123)，其中一个线程对其进行了修改并写入(value2=456)，其他线程已读取的数据还是前面的(value2=123) 从内存角度来看 volatile 变量： 1231. 有A、B两个线程，读取 volatile 变量，就相当于进入了 volatile 变量的同步代码块中2. 线程A修改了 volatile 变量，线程B也会同步知道线程 A修改了 volatile 变量3. 线程A修改了 volatile 变量后，进行写入操作，即退出了该同步代码块 2.5 局限性volatile 关键字通常用做某个 操作完成、发生中断、状态 的标志。如： 12345678910111213141516171819202122/** * Created by osys on 2022/08/28 21:48. */public class Demo8 { /** 状态的标志 */ private volatile boolean aSleep; public void mainMethod() { startDoSomething(); while (!aSleep) { stopDoSomething(); } } public void startDoSomething() { System.out.println(&quot;开始 ------ 做某些事&quot;); } public void stopDoSomething() { System.out.println(&quot;停止 ------ 做某些事&quot;); }} volatile 关键字不足以确保递增操作 i++ 的原子性，因为我们不能确保只有一个线程对变量执行写操作。 3. 发布与逸出3.1 发布(Publish) 发布一个对象指的是，是对象能够再当前作用域之外的代码中使用。 12345678910111213import sun.nio.ch.Secrets;import java.util.HashSet;import java.util.Set;public class PublishObject { private static Set&lt;Secrets&gt; publishSecrets = new HashSet&lt;&gt;(); public static Set&lt;Secrets&gt; getInstance() { return publishSecrets; }} 3.2 逸出(Escape)逸出：不应该发布的对象被发布 对于上面的代码： 12345678public class PublishObject { private static Set&lt;Secrets&gt; publishSecrets = new HashSet&lt;&gt;(); public static Set&lt;Secrets&gt; getInstance() { return publishSecrets; }} 当我们发布某个对象时，可能会间接地发布其他对象。 如我们不是发布 Set 对象，而是 Secrets 对象 如将别的 Secrets 对象添加到 publishSecrets 集合中，那么同样的，被添加的这个 Secrets 对象也会被发布。 因为任何使用者都能遍历这个集合，并且获得这个新 Secrets 对象的引用。 1234567public class UnsafeStates { private String[] states = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; public String[] getStates() { return states; }} 任何调用者都可能会修改发布的对象，如上 states 对象，该数组已经逸出了它所在的作用域。 当发布一个对象时，在该对象的非私有域应用的对象同样会被发布。 一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到其他对象，那么这些对象也都会被发布。 3.3 安全地对象构造隐式地是由 this 引用逸出： 1234567891011121314151617181920212223242526272829303132333435public class ThisEscape { public ThisEscape(EventSource source) { source.registerListener(new EventListener() { @Override public void onEvent(Event event) { doSomething(event); } }); } void doSomething(Event event) { } /** 事件源 */ interface EventSource { /** * 注册事件监听 * @param eventListener 事件监听 */ void registerListener(EventListener eventListener); } /** 事件监听 */ interface EventListener { /** * 一个事件 * @param event 一个事件 */ void onEvent(Event event); } /** 事件 */ interface Event { }} ThisEscape 中给出了逸出地一个特殊示例，即 this 引用在构造函数中逸出。 当内部地 EventListener 实例发布时，在外部封装的 ThisEscape 实例逸出了。 当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。 如果 this 引用在构造过程中逸出，那么这种对象就被认为是不正确的构造。 使用工厂方法来防止 this 引用在构造过程中逸出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Created by osys on 2022/08/28 21:48. */public class SafeListener { private final EventListener listener; private SafeListener() { listener = new EventListener() { @Override public void onEvent(Event event) { doSomething(event); } }; } public static SafeListener newInstance(EventSource source) { SafeListener safeListener = new SafeListener(); source.registerListener(safeListener.listener); return safeListener; } void doSomething(Event event) { } /** 事件源 */ interface EventSource { /** * 注册事件监听 * @param eventListener 事件监听 */ void registerListener(EventListener eventListener); } /** 事件监听 */ interface EventListener { /** * 一个事件 * @param event 一个事件 */ void onEvent(Event event); } /** 事件 */ interface Event { }} 如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个使用的构造函数和一个公共的工程方法，从而避免不正确的构造过程。 4. 线程封闭4.1 线程封闭 当访问共享数据时，通常是要使用同步。 如果要避免使用同步，就是不提供共享数据。 如果仅在单线程中访问数据，就不需要同步。 4.2 Ad-hoc 线程封闭Ad-hoc 线程封闭：线程封闭性的职责完全由程序实现来承担。 Ad-hoc 非常脆弱，因为它没有一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到特定的线程上。 4.3 栈封闭（线程局部使用）栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。 局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。 基本类型的局部变量与引用变量的线程封闭性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151import java.util.Collection;import java.util.Comparator;import java.util.HashSet;import java.util.Objects;import java.util.Set;import java.util.SortedSet;import java.util.TreeSet;/** * Created by osys on 2022/08/28 21:48. */public class Animals { Ark ark; Species species; Gender gender; /** * 加载动物对 载体 * @param candidates 候选动物 * @return 动物对数 */ public int loadTheArk(Collection&lt;Animal&gt; candidates) { SortedSet&lt;Animal&gt; animals; int numPairs = 0; // 候选 Animal candidate = null; animals = new TreeSet&lt;Animal&gt;(new SpeciesGenderComparator()); animals.addAll(candidates); // 依次循环所有候选动物，存在同物种，不同性别的动物，加入动物对中 for (Animal animal : animals) { if (candidate == null || !candidate.isPotentialMate(animal)) { candidate = animal; } else { // 同物种，不同性别。向【动物对】载体中添加这两个动物 ark.load(new AnimalPair(candidate, animal)); ++numPairs; candidate = null; } } //动物对数 return numPairs; } /** 动物 */ static class Animal { /** 物种 */ Species species; /** 性别 */ Gender gender; /** 是否是同物种，不同性别 */ public boolean isPotentialMate(Animal other) { return this.species == other.species &amp;&amp; this.gender != other.gender; } @Override public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof Animal)) { return false; } Animal animal = (Animal) o; return species == animal.species &amp;&amp; gender == animal.gender; } @Override public int hashCode() { return Objects.hash(species, gender); } } /** 物种 */ enum Species { // 土豚、孟加拉虎、驯鹿、野狗、大象、青蛙、GNU、土狼、 AARDVARK, BENGAL_TIGER, CARIBOU, DINGO, ELEPHANT, FROG, GNU, HYENA, // 鬣蜥、美洲虎、猕猴桃、美洲豹、马斯塔顿、蝾螈、章鱼、 IGUANA, JAGUAR, KIWI, LEOPARD, MASTADON, NEWT, OCTOPUS, // 食人鱼、格查尔、犀牛、蝾螈、三趾树懒、 PIRANHA, QUETZAL, RHINOCEROS, SALAMANDER, THREE_TOED_SLOTH, // 独角兽、毒蛇、狼人、黄蜂、牦牛、斑马 UNICORN, VIPER, WEREWOLF, XANTHUS_HUMMINBIRD, YAK, ZEBRA } /** 性别 */ enum Gender { // 雄性、雌性 MALE, FEMALE } /**一对动物 */ static class AnimalPair { private final Animal one, two; public AnimalPair(Animal one, Animal two) { this.one = one; this.two = two; } @Override public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof AnimalPair)) { return false; } AnimalPair that = (AnimalPair) o; return Objects.equals(one, that.one) &amp;&amp; Objects.equals(two, that.two); } @Override public int hashCode() { return Objects.hash(one, two); } } /** 物种性别比较 */ static class SpeciesGenderComparator implements Comparator&lt;Animal&gt; { /** * 先进行物种比较，物种比较相同，再进行性别比较 * @param one 动物1 * @param two 动物2 * @return 0为物种相同，且 */ @Override public int compare(Animal one, Animal two) { // Enum.compareTo() // 将此枚举与订单的指定对象进行比较。当此对象小于、等于或大于指定对象时，返回负整数、零或正整数。 // 枚举常量只能与同一枚举类型的其他枚举常量进行比较。该方法实现的自然顺序是常量的声明顺序。 int speciesCompare = one.species.compareTo(two.species); return (speciesCompare != 0) ? speciesCompare : one.gender.compareTo(two.gender); } } /** 动物对 载体 */ static class Ark { private Set&lt;AnimalPair&gt; loadedAnimals = new HashSet&lt;&gt;(); /** 向 【动物对】 载体中添加 【动物对】 */ public void load(AnimalPair pair) { loadedAnimals.add(pair); } }} loadTheArk 中的 animals 变量为局部变量，它被限制在保存本地变量的线程中。 5. ThreadLocal ThreadLocal 允许 每个线程 与特有数值的对象 关联在一起。 ThreadLocal 提供了 get 和 set 访问器，为每个使用 ThreadLoacl 的线程维护一份单独的拷贝。 因此 get 总是返回由当前只想线程通过 set 设置的最新值。 线程本地（ThreadLocal）变量通常用于防止基于可变的单例（Singleton）或全局变量的设计中，出现（不正确的）共享。 5.1 使用 ThreadLocal 确保线程封闭性1234567891011121314151617181920212223242526272829import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;/** * Created by osys on 2022/08/28 21:48. */public class ConnectionDispenser { static String DB_URL = &quot;jdbc:mysql://localhost/test&quot;; private ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() { @Override public Connection initialValue() { try { return DriverManager.getConnection(DB_URL); } catch (SQLException e) { throw new RuntimeException(&quot;无法获取连接, e&quot;); } } }; public Connection getConnection() { return connectionHolder.get(); } public void setConnection(ThreadLocal&lt;Connection&gt; connection) { this.connectionHolder = connection; }} 可以将 ThreadLocal&lt;T&gt; 看作 Map&lt;Thread, T&gt; 它存储了与线程相关的值（不过事实上它并非这样实现的）。 与线程相关的值存储在线程对象自身中，线程终止后，这些值会被垃圾回收。 6. 不可变性多个线程总试图访问相同的可变状态，可能会出现未及时更新、访问的数据为过期数据。 如果对象的状态不能被修改，那么这些风险与复杂度就自然而然的消失了。 6.1 对象的不可变不可变性病不生简单地等于将对中的所有域都声明为 final 类型，所有域都是 finel 类型的对象仍然是可变的，因为 final 域可以获得一个可变对象的引用。 1234不可变对象需要满足：1. 对象创建后，状态不能被修改2. 所有域都是 final 类型3. 对象创建期间没有发生 this 引用的逸出 6.2 构造于底层可变对象之上的不可变类1234567891011121314151617181920212223242526272829303132333435363738import net.jcip.annotations.Immutable;import java.util.HashSet;import java.util.List;import java.util.Set;import java.util.Vector;/** * Created by osys on 2022/08/28 21:48. */@Immutablepublic final class ThreeStooges { private final Set&lt;String&gt; stooges = new HashSet&lt;&gt;(); public ThreeStooges() { stooges.add(&quot;Moe&quot;); stooges.add(&quot;Larry&quot;); stooges.add(&quot;Curly&quot;); } public boolean isStooge(String name) { return stooges.contains(name); } public String getStoogeNames() { List&lt;String&gt; stooges = new Vector&lt;&gt;(); stooges.add(&quot;Moe&quot;); stooges.add(&quot;Larry&quot;); stooges.add(&quot;Curly&quot;); return stooges.toString(); } public static void main(String[] args) { ThreeStooges threeStooges = new ThreeStooges(); System.out.println(&quot;threeStooges.stooges = &quot; + threeStooges.stooges); // threeStooges.stooges = [Moe, Larry, Curly] }} 尽管存储 String 的 Set 是可变的，不过 ThreeStooges 的设计使得 ThreeStooges 对象被创建后，就不能再修改 set。 stooges 引用是 final 类型的，所以所有的对象状态只能通过 final 域进行询问（满足不可变对象的要求） 6.3 使用 volatile 发布不可变对象在不可变的容器中混存数字和它的因数 123456789101112131415161718192021222324252627import net.jcip.annotations.Immutable;import java.math.BigInteger;import java.util.Arrays;/** * 不可变容器，混存值 */@Immutablepublic class OneValueCache { private final BigInteger lastNumber; private final BigInteger[] lastFactors; public OneValueCache(BigInteger i, BigInteger[] factors) { lastNumber = i; lastFactors = Arrays.copyOf(factors, factors.length); } public BigInteger[] getFactors(BigInteger i) { if (lastNumber == null || !lastNumber.equals(i)) { return null; } else { return Arrays.copyOf(lastFactors, lastFactors.length); } }} 通过使用不可变对象来持有所有的变量，可以消除在访问和更新这些变量时的竟争条件。 若使用可变的容器对象，须使用锁以确保原子性。 使用不可变对象，一旦有一个线程获得了它的引用，永远不必担心其他线程会修改它的状态。 7. 安全发布7.1 不可变容器的 volatile 类型引用不可变容器： 123456789101112131415161718192021222324252627282930313233import net.jcip.annotations.Immutable;import java.math.BigInteger;import java.util.Arrays;/** * 不可变容器，混存值 */@Immutablepublic class OneValueCache { private final BigInteger lastNumber; private final BigInteger[] lastFactors; public OneValueCache(BigInteger i, BigInteger[] factors) { lastNumber = i; // 防止空指针异常 if (factors == null) { lastFactors = null; } else { lastFactors = Arrays.copyOf(factors, factors.length); } } public BigInteger[] getFactors(BigInteger i) { if (lastNumber == null || !lastNumber.equals(i)) { // lastNumber = null 或 lastNumber != i return null; } else { return Arrays.copyOf(lastFactors, lastFactors.length); } }} 使用到不可变容器对象的 volatile 类型引用，缓存最新的结果： 12345678910111213141516171819202122232425262728293031323334353637import net.jcip.annotations.ThreadSafe;import javax.servlet.GenericServlet;import javax.servlet.Servlet;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import java.math.BigInteger;/** * 使用到不可变容器对象的 volatile 类型引用，缓存最新的结果 */@ThreadSafepublic class VolatileCachedFactories extends GenericServlet implements Servlet { private volatile OneValueCache cache = new OneValueCache(null, null); @Override public void service(ServletRequest req, ServletResponse resp) { BigInteger i = extractFromRequest(req); BigInteger[] factors = cache.getFactors(i); if (factors == null) { factors = factor(i); cache = new OneValueCache(i, factors); } encodeIntoResponse(resp, factors); } void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) { } BigInteger extractFromRequest(ServletRequest req) { return new BigInteger(&quot;7&quot;); } BigInteger[] factor(BigInteger i) { return new BigInteger[]{i}; }} VolatileCachedFactories 利用 OneValuecache 存储缓存的数字及其因数。 当一个线程设置 volatile 类型的 cache 域引用到一个新的 OnevalueCache 后，新数据会立即对其他线程可见。 7.2 在没有适当的同步的情况下就发布对象12345678910/** * Created by osys on 2022/08/28 21:48. */public class Holder { private int n; public Holder(int n) { this.n = n; }} 12345678910/** * Created by osys on 2022/08/28 21:48. */public class StuffIntoPublic { public Holder holder; public void initialize() { holder = new Holder(42); }} holder 容器还是会在其他线程中被设置为一个不一致的状态。 即使它的不变约束已经在构造函数中得以正确创建。如多个线程都调用 initialize()，其 holder 成员变量的引用会发生多次改变。 7.3 安全发布的模式为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见。 一个正确创建的对象可以通过下列条件安全地发布： 通过静态初始化器初始化对象的引用； 将它的引用存储到 volatile域 或 AtomicReference； 将它的引用存储到正确创建的对象的 final 域中； 或者将它的引用存储到由锁正确保护的域中。 7.4 高效不可变对象被安全发布后，状态不能被修改的对象，叫作高效不可变对象。不可变对象是线程安全的。它们的常量（变量）是在构造函数中创建的。 如： 123456789101112131415161718import java.util.Collections;import java.util.Date;import java.util.HashMap;import java.util.Map;/** * Created by osys on 2022/08/28 21:48. */public class Demo9 { public final Map&lt;String, Date&gt; lastLogin; public Demo9() { Map&lt;String, Date&gt; stringDate = new HashMap&lt;&gt;(); stringDate.put(&quot;LeeHua&quot;, new Date()); stringDate.put(&quot;Rainbow&quot;, new Date()); lastLogin = Collections.synchronizedMap(stringDate); }} 如果 Date 值在置入 Map 中后就不会改变，那么 synchronizedMap 中同步的实现，对于安全地发布 Date 值，是至关重要的。而访问这些 Date 值时就不再需要额外的同步。 7.5 可变对象发布对象的必要条件依赖于对象的可变性： 不可变对象可以通过任意机制发布； 高效不可变对象必须要安全发布； 可变对象必须要安全发布，同时必须要线程安全或者是被锁保护。 7.6 安全地共享对象在并发程序中，使用和共享对象的一些最有效的策略如下： 线程限制：一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有它的线程修改。 共享只读(shared read-only)：一个共享的只读对象，在没有额外同步的情况下，可以被多个线程并发地访问 ，但是任何线程都不能修改它。共享只读对象包括可变对象与高效不可变对象。 共享线程安全(shared thread-safe)：一个线程安全的对象在内部进行同步，所以共他线程无须额外同步，就可以通过公共接口随意地访问它。 被守护的(Guarded)：一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象。","link":"/posts/fff0.html"},{"title":"Java并发编程实战：第4章 组合对象","text":"1. 设计线程安全的类尽管将所有的状态都存储在公共静态域中，仍然能写出线程安全的程序。 在没有进行全局检查的情况下，封装能够保证类的线程安全性。 设计线程安全类的过程应该包括下面3个基本要素： 确定对象状态是由哪些变量构成的； 确定限制状态变量的不变约束； 制定一个管理并发访问对象状态的策略。 1.1 同步策略(Synchronization Policy)定义了对象如何协调对其状态的访问，并且不会违反它的不便约束或验证条件。 使用 Java 监视器模式的简单线程安全计数器： 12345678910111213141516171819202122import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;/** * Created by osys on 2022/08/28 21:48. */@ThreadSafepublic final class Counter { @GuardedBy(&quot;this&quot;) private long value = 0; public synchronized long getValue() { return value; } public synchronized long increment() { if (value == Long.MAX_VALUE) { throw new IllegalStateException(&quot;counter overflow&quot;); } return ++value; }} 1.2 收集同步需求对象与变量拥有一个 状态空间 ：这个空间即 它们可能处于状态的范围。 例如上面的：Counter 类 12345678// long 类型数据限制其范围是 Long.MIN_VALUE 到 Long.MAX_VALUEprivate long value = 0; // 限制了 value 的值必须是正值if (value == Long.MAX_VALUE) { // 是否非法 throw new IllegalStateException(&quot;counter overflow&quot;);}return ++value; 类似地，操作的后验条件会指出某种 状态转换(state transitions) 是非法的 不变约束 与 后验条件 施加在状态及状态转换上的约束，引入了额外的同步与封装的需要。 1.3 状态依赖的操作 类的 不变约束 与方法的 后验条件 约束了对象 合法的状态 和 合法状态转换 对象的方法也可以有 先验条件。如无法从空队列中移除一个条目。 单线程中，操作如果无法满足 先验条件 必然失败。 多线程中，原本为 假 的先验条件，可能会由于其它线程的活动变为 真。 在并发程序中，有持续等待, 直到先验条件为真，再继续处理的操作。在 Java 中，等待特定条件成立的内置高效机制 wait 和 notify 与内部锁紧密地绑定在一起。 1.4 状态所有权 在很多情况下，所有权与封裝性总是在一起出现的。 对象封装它拥有的状态，且拥有它封装的状态。拥有给定状态的所有者决定了锁协议，该协议用于维护变量状态的完整性。 所有权意味着控制权，不过一旦将引用发布到一个可变对象上，就不再拥有独占的控制权，充其量只可能有共享控制权。 类通常不会拥有由构造函数或方法传递进来的对象，除非该方法是被明确设计用来转换传递对象的所有权的（比如同步容器的包装工厂方法)。 2. 实例限制2.1 实例限制即使一个对象不是线程安全的，仍然有许多技术可以让它安全地用于多线程程序。 比如，你可以确保它只被单一线程访问（线程限制），也可以确保所有的访问都正确地被锁保护。 通过使用实例限制 (instance confinement)，封装简化了类的线程安全化工作，这通常称为限制。 将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁。 使用限制确保线程安全： 12345678910111213141516171819202122232425import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.util.HashSet;import java.util.Set;/** * Created by osys on 2022/08/28 21:48. */@ThreadSafepublic class PersonSet { @GuardedBy(&quot;this&quot;) private final Set&lt;Person&gt; mySet = new HashSet&lt;&gt;(); public synchronized void addPerson(Person p) { mySet.add(p); } public synchronized boolean containsPerson(Person p) { return mySet.contains(p); } interface Person { }} 2.2 Java 监视器模式(Java monitor pattern) 线程限制原则的直接推论之一是Java 监视器模式。 遵循Java监视器模式的对象封裝了所有的可变状态，并由对象自己的内部锁保护。 Java的内置锁有时也被叫做监视器锁(monitor locks) 或监视器(monitors) Counter 演示了这个模式的典型案例： Counter 封裝了一个状态变量value，所有对该变最的访问都要通过 Counter 的方法，这些方法都是同步的。 12345678910111213141516171819import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;@ThreadSafepublic final class Counter { @GuardedBy(&quot;this&quot;) private long value = 0; public synchronized long getValue() { return value; } public synchronized long increment() { if (value == Long.MAX_VALUE) { throw new IllegalStateException(&quot;counter overflow&quot;); } return ++value; }} 私有锁保护状态： 12345678910111213141516171819import apple.laf.JRSUIConstants;import net.jcip.annotations.GuardedBy;/** * Created by osys on 2022/08/28 21:48. */public class PrivateLock { private final Object myLock = new Object(); @GuardedBy(&quot;myLock&quot;) JRSUIConstants.Widget widget; void someMethod() { synchronized (myLock) { // 访问或修改 widget 的状态 } }} 使用私有锁对象，而不是对象的内部锁（或任何其他可公共访问的锁），有很多好处。 私有的锁对象可以封装锁，这样客户代码无法得到它。 可公共访问的锁允许客户代码涉足它的同步策略 —- 正确地或不正确地。 客户不正确地得到另一个对象的锁，会引起活跃度方面的问题。 另外要验证程序是正确地使用着一个可公共访问的锁，需要检查完整的程序，而不是一个单独的类。 2.3 机动车追踪器(tracking fleet vehicle)每一辆机动车都有一个 string 标识，并有一个与之对应的位置(x，y) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import net.jcip.annotations.ThreadSafe;import java.awt.Point;import java.util.Collections;import java.util.HashMap;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;/** * 机动车追踪器 */@ThreadSafepublic class DelegatingVehicleTracker { /** 机动车位置 */ private ConcurrentMap&lt;String, Point&gt; locations; /** 机动车位置(不可修改的，即最初位置) */ private final Map&lt;String, Point&gt; unmodifiableMap; public DelegatingVehicleTracker(Map&lt;String, Point&gt; points) { locations = new ConcurrentHashMap&lt;String, Point&gt;(points); unmodifiableMap = Collections.unmodifiableMap(locations); } /** 所有机动车位置(不可变的) */ public Map&lt;String, Point&gt; getLocations() { return unmodifiableMap; } /** * 某机动车位置 * @param id 机动车 id * @return 机动车位置 */ public Point getLocation(String id) { return locations.get(id); } /** * 修改机动车位置(需要存在该机动车) * @param id 机动车 id * @param x 机动车 x 坐标 * @param y 机动车 y 坐标 */ public void setLocation(String id, int x, int y) { if (locations.replace(id, new Point(x, y)) == null) { throw new IllegalArgumentException(&quot;车辆名称无效: &quot; + id); } } /** * 机动车移动 * @param evt 机动车移动事件 */ public void vehicleMoved(VehicleMovedEvent evt) { // 位置 Point local = evt.point; // 修改机动车位置(需要存在该机动车) setLocation(evt.vehicleId, local.x, local.y); } /** 所有机动车位置(可变的) */ public Map&lt;String, Point&gt; getLocationsAsStatic() { return Collections.unmodifiableMap( new HashMap&lt;String, Point&gt;(locations)); } /** * 打印机动车位置 * @param vehicleId 机动车id * @param local 机动车位置 */ public void renderVehicle(String vehicleId, Point local) { System.out.println(&quot;机动车 &quot; + vehicleId + &quot; 位置：&quot; + local); } /** 机动车移动事件 */ static class VehicleMovedEvent { Point point; String vehicleId; public VehicleMovedEvent(Point point, String vehicleId) { this.point = point; this.vehicleId = vehicleId; } }} 3. 委托线程安全3.1 基于监视器的机动车追踪器实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.util.Collections;import java.util.HashMap;import java.util.Map;/** * 基于监视器的机动车追踪器实现 */@ThreadSafepublic class MonitorVehicleTracker { @GuardedBy(&quot;this&quot;) private final Map&lt;String, MutablePoint&gt; locations; public MonitorVehicleTracker(Map&lt;String, MutablePoint&gt; locations) { this.locations = deepCopy(locations); } public synchronized Map&lt;String, MutablePoint&gt; getLocations() { return deepCopy(locations); } public synchronized MutablePoint getLocation(String id) { MutablePoint loc = locations.get(id); return loc == null ? null : new MutablePoint(loc); } public synchronized void setLocation(String id, int x, int y) { MutablePoint loc = locations.get(id); if (loc == null) { throw new IllegalArgumentException(&quot;No such ID: &quot; + id); } loc.x = x; loc.y = y; } /** * 深拷贝一个机动车追踪器 * @param m 机动车追踪器 * @return 深拷贝后的机动车追踪器 */ private static Map&lt;String, MutablePoint&gt; deepCopy(Map&lt;String, MutablePoint&gt; m) { Map&lt;String, MutablePoint&gt; result = new HashMap&lt;&gt;(m.size()); for (String id : m.keySet()) { result.put(id, new MutablePoint(m.get(id))); } // 深拷贝后，返回一个不可修改的 Map return Collections.unmodifiableMap(result); }} 3.2 将现场安全委托到 ConcurrentHashMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import net.jcip.annotations.ThreadSafe;import java.awt.Point;import java.util.Collections;import java.util.HashMap;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;/** * 机动车追踪器 */@ThreadSafepublic class DelegatingVehicleTracker { /** 机动车位置 */ private ConcurrentMap&lt;String, Point&gt; locations; /** 机动车位置(不可修改的，即最初位置) */ private final Map&lt;String, Point&gt; unmodifiableMap; public DelegatingVehicleTracker(Map&lt;String, Point&gt; points) { locations = new ConcurrentHashMap&lt;String, Point&gt;(points); unmodifiableMap = Collections.unmodifiableMap(locations); } /** 所有机动车位置(不可变的) */ public Map&lt;String, Point&gt; getLocations() { return unmodifiableMap; } /** * 某机动车位置 * @param id 机动车 id * @return 机动车位置 */ public Point getLocation(String id) { return locations.get(id); } /** * 修改机动车位置(需要存在该机动车) * @param id 机动车 id * @param x 机动车 x 坐标 * @param y 机动车 y 坐标 */ public void setLocation(String id, int x, int y) { if (locations.replace(id, new Point(x, y)) == null) { throw new IllegalArgumentException(&quot;车辆名称无效: &quot; + id); } } /** * 机动车移动 * @param evt 机动车移动事件 */ public void vehicleMoved(VehicleMovedEvent evt) { // 位置 Point local = evt.point; // 修改机动车位置(需要存在该机动车) setLocation(evt.vehicleId, local.x, local.y); } /** 所有机动车位置(可变的) */ public Map&lt;String, Point&gt; getLocationsAsStatic() { return Collections.unmodifiableMap( new HashMap&lt;String, Point&gt;(locations)); } /** * 打印机动车位置 * @param vehicleId 机动车id * @param local 机动车位置 */ public void renderVehicle(String vehicleId, Point local) { System.out.println(&quot;机动车 &quot; + vehicleId + &quot; 位置：&quot; + local); } /** 机动车移动事件 */ static class VehicleMovedEvent { Point point; String vehicleId; public VehicleMovedEvent(Point point, String vehicleId) { this.point = point; this.vehicleId = vehicleId; } }} 3.3 非状态依赖变量12345678910111213141516171819202122232425262728import java.awt.event.KeyListener;import java.awt.event.MouseListener;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;/** * 委托线程安全到多个底层的状态变量 */public class VisualComponent { private final List&lt;KeyListener&gt; keyListeners = new CopyOnWriteArrayList&lt;&gt;(); private final List&lt;MouseListener&gt; mouseListeners = new CopyOnWriteArrayList&lt;&gt;(); public void addKeyListener(KeyListener listener) { keyListeners.add(listener); } public void addMouseListener(MouseListener listener) { mouseListeners.add(listener); } public void removeKeyListener(KeyListener listener) { keyListeners.remove(listener); } public void removeMouseListener(MouseListener listener) { mouseListeners.remove(listener); }} VisualComponent 使用 CopyOnWriteArrayList 存储每个监听器清单。 在 VisualComponent 中，不但每个 List 是线程安全的，而且不存在哪个不变约束会增加一个状态与另一个状态间的耦合，所以 VisualComponent 可以将它的线程安全贵任委托到 MouseListener 和 KeyListener 对象上。 3.4 不完整地保护不变约束NumberRange 不是线程安全的；它没有保护好用于约東 lower 和 upper 的不变约束。 setLower 和 setupper 都是检查再运行的操作，但是它们没有适当地加锁以保证其原子性。 123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.atomic.AtomicInteger;/** * NumberRange 类没有完整地保护它的不变约束 */public class NumberRange { /** 不变约束: lower &lt;= upper */ private final AtomicInteger lower = new AtomicInteger(0); private final AtomicInteger upper = new AtomicInteger(0); /** 设置最低 number */ public void setLower(int i) { // 警告 -- 不安全的 &quot;检查再运行&quot; if (i &gt; upper.get()) { throw new IllegalArgumentException(&quot;can't set lower to &quot; + i + &quot; &gt; upper&quot;); } lower.set(i); } /** 设置最高 number */ public void setUpper(int i) { // 警告 -- 不安全的 &quot;检查再运行&quot; if (i &lt; lower.get()) { throw new IllegalArgumentException(&quot;can't set upper to &quot; + i + &quot; &lt; lower&quot;); } upper.set(i); } /** * 判断 i 是否满足 lower &lt;= i &lt;= upper * @return true or false */ public boolean isInRange(int i) { return (i &gt;= lower.get() &amp;&amp; i &lt;= upper.get()); }} 如果类中还存在复合操作，如 setLower 和 setupper，类必须提供它自身有的锁以保证复合操作都是原子的。 除非所有的操作可以委托给一个状态变量。如下： 1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.atomic.AtomicReference;/** * NumberRange2 类完整地保护它的不变约束 */public class NumberRange2 { /** 不变约束: lower &lt;= upper */ private final AtomicReference&lt;RangeNum&gt; lowerAndUpper = new AtomicReference&lt;&gt;(new RangeNum(0, 0)); /** 设置最低 number */ public void setLower(int i) { lowerAndUpper.set(new RangeNum(i, lowerAndUpper.get().upper)); } /** 设置最高 number */ public void setUpper(int i) { lowerAndUpper.set(new RangeNum(lowerAndUpper.get().lower, i)); } /** * 判断 i 是否满足 lower &lt;= i &lt;= upper * @return true or false */ public boolean isInRange(int i) { return (i &gt;= lowerAndUpper.get().lower &amp;&amp; i &lt;= lowerAndUpper.get().upper); } class RangeNum { public int lower; public int upper; public RangeNum(int lower, int upper) { // 警告 -- 不安全的 &quot;检查再运行&quot; if (upper &lt; lower) {throw new IllegalArgumentException(&quot;upper must be greater than or equal to lower!&quot;);} this.lower = lower; this.upper = upper; } }} 3.5 发布底层的状态变量如果一个状态变量是线程安金的，没有任何不变约束限制它的值，并且没有任何状态转换限制它的操作，那么它可以被安全发布。 发布了状态的机动车追踪器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.util.Collections;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * Created by osys on 2022/08/28 21:48. */@ThreadSafepublic class PublishingVehicleTracker { private final Map&lt;String, SafePoint&gt; locations; private final Map&lt;String, SafePoint&gt; unmodifiableMap; public PublishingVehicleTracker(Map&lt;String, SafePoint&gt; locations) { this.locations = new ConcurrentHashMap&lt;&gt;(locations); this.unmodifiableMap = Collections.unmodifiableMap(this.locations); } public Map&lt;String, SafePoint&gt; getLocations() { return unmodifiableMap; } public SafePoint getLocation(String id) { return locations.get(id); } public void setLocation(String id, int x, int y) { if (!locations.containsKey(id)) { throw new IllegalArgumentException(&quot;invalid vehicle name: &quot; + id); } locations.get(id).set(x, y); } @ThreadSafe class SafePoint { @GuardedBy(&quot;this&quot;) private int x, y; public SafePoint(int x, int y) { this.set(x, y); } private SafePoint(int[] a) { this(a[0], a[1]); } public SafePoint(SafePoint p) { this(p.get()); } public synchronized int[] get() { return new int[]{x, y}; } public synchronized void set(int x, int y) { this.x = x; this.y = y; } }} PublishingVehicleTracker 的线程安全性源自于它所委托的底层 ConcurrentHashMap。 不过这次 Map 的内容是线程安全的可变 SafePoint，而非不可变的。 getLocation 方法返回底层 Map 的不可变拷贝，调用者在其上无法添加或移除车辆，却可以通过修改返回的 Map 中 SafePoint 的值，改变一个机动车的位置。 只有 PublishingVehicleTracker 对机动车追踪器的合法值没有施加任何额外的约束时，它才是线程安全的。 如果需要对机动车的 location 的改变(setLocation())进行判断或者执行一些其他的操作，那么 PublishingVehicleTracker 的做法可能就不正确了. 4. 向已有的线程安全类添加功能4.1 向已有的线程安全类添加功能 Java 类库中包含了很多有用的 构建块 类。重用这些已有的类要好于创建一个新的。重用能够降低开发的难度、风和维护成本。 有时一个线程安全类支持我们需要的全部操作，但更多时候，一个类只支持我们需要的大部分操作，这时我们需要在不破坏其线程安全性的前提下，向它添加一个新的操作。 修改原始的类 添加一个新原子操作的最安全的方式是，修改原始的类，以支持期望的操作。 但是你可能无法访问源代码或者没有修改的自由，所以这通常是不可能的。 即使你可以修改原始的类，也需要理解其实现的同步策略，才能在维持原有设计的前提下完善它的功能。 直接向类中加入新方法，意味着所有实现类同步策略的代码仍然包含在一个源代码文件中，因此便于理解与维护。 扩展这个类 另一种方法是扩展这个类，假如这个类在设计上是可以扩展的。如： 1234567891011121314151617import net.jcip.annotations.ThreadSafe;import java.util.Vector;@ThreadSafepublic class BetterVector &lt;E&gt; extends Vector&lt;E&gt; { /** 扩展可序列化类时，应重新定义 serialVersionUID */ static final long serialVersionUID = -3963416950630760754L; public synchronized boolean putIfAbsent(E x) { boolean absent = !contains(x); if (absent) { add(x); } return absent; }} 扩展后，同步策略的实现会被分布到多个独立维护的源代码(.class)文件中，所以扩展一个类比直接在类中加入代码更脆弱。 如果低层的类选择了不同的锁保护它的状态变量，从而会改变它的同步策略，子类就在不知不觉中被破坏，因为它不能再用正确的锁控制对基类状态的并发访问。 4.2 客户端加锁创建一个助手类，该助手类包含一个作用于线程安全 List 的原子 缺少即加入 的操作。 非线程安全的 “缺少即加入” 实现（不要这样做） 12345678910111213141516@NotThreadSafeclass BadListHelper &lt;E&gt; { public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public synchronized boolean putIfAbsent(E x) { boolean absent = !list.contains(x); if (absent) { list.add(x); } return absent; } // ========================= // 等等有关操作 list 的其它方法 // =========================} 这里是并不能保证对 list 的操作是线程安全的，即使使用了同步修饰 putIfAbsent() 方法。 虽然对 putIfAbsent() 加了内置锁，但是这仅仅限制同一时间仅有单一线程调用此方法。 我们并不能保证其它线程调用 BadListHelper 的其它方法，对 list 进行操作。即使其它方法也都是用了内置锁。 使用客户端加锁实现的 “缺少即加入” 123456789101112131415161718@ThreadSafeclass GoodListHelper &lt;E&gt; { public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;()); public boolean putIfAbsent(E x) { synchronized (list) { boolean absent = !list.contains(x); if (absent) { list.add(x); } return absent; } } // ========================= // 等等有关操作 list 的其它方法 // =========================} 线程安全 如果说，为了添加另一个原子操作而去扩展一个类(扩展类加锁)容易出问题，是因为它将加锁的代码分布到了继承体系中的多个类里。 然而客户端加锁其实是更加脆弱的，因为它必须将类 a.class中的加锁代码置入与a.class完全无关的类中。 在那些不关注锁策略的类中使用客户端加锁时，一定要小心。客户端加锁与扩展类有很多共同之处：所得类的行为与基类的实现之间都存在耦合。正如同扩展会破坏实现的封装性一样，客户端加锁会破坏同步策略的封装性。 4.3 组合(composition)向己有的类中添加一个原子操作，还有更好的选择：组合。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import net.jcip.annotations.ThreadSafe;import java.util.Collection;import java.util.Iterator;import java.util.List;import java.util.ListIterator;/** * Created by osys on 2022/08/28 21:48. */@ThreadSafepublic class ImprovedList&lt;T&gt; implements List&lt;T&gt; { private final List&lt;T&gt; list; /** * PRE: list 参数是线程安全的。 */ public ImprovedList(List&lt;T&gt; list) {this.list = list;} public synchronized boolean putIfAbsent(T x) { boolean contains = list.contains(x); if (contains) { list.add(x); } return !contains; } // List 方法的普通委托。 // 可变方法必须同步以确保 putIfAbsent 的原子性。 @Override public synchronized void clear() {list.clear();} @Override public synchronized void add(int index, T element) {list.add(index, element);} @Override public synchronized boolean add(T e) {return list.add(e);} @Override public synchronized boolean remove(Object o) {return list.remove(o);} @Override public synchronized boolean addAll(Collection&lt;? extends T&gt; c) {return list.addAll(c);} @Override public synchronized boolean addAll(int index, Collection&lt;? extends T&gt; c) {return list.addAll(index, c);} @Override public synchronized boolean removeAll(Collection&lt;?&gt; c) {return list.removeAll(c);} @Override public synchronized boolean retainAll(Collection&lt;?&gt; c) {return list.retainAll(c);} @Override public synchronized T set(int index, T element) {return list.set(index, element);} @Override public synchronized T remove(int index) {return list.remove(index);} // 不可变方法 @Override public T get(int index) {return list.get(index);} @Override public int size() {return list.size();} @Override public boolean isEmpty() {return list.isEmpty();} @Override public boolean contains(Object o) {return list.contains(o);} @Override public Iterator&lt;T&gt; iterator() {return list.iterator();} @Override public Object[] toArray() {return list.toArray();} @Override public &lt;T&gt; T[] toArray(T[] a) {return list.toArray(a);} @Override public boolean containsAll(Collection&lt;?&gt; c) {return list.containsAll(c);} @Override public boolean equals(Object o) {return list.equals(o);} @Override public int hashCode() {return list.hashCode();} @Override public int indexOf(Object o) {return list.indexOf(o);} @Override public int lastIndexOf(Object o) {return list.lastIndexOf(o);} @Override public ListIterator&lt;T&gt; listIterator() {return list.listIterator();} @Override public ListIterator&lt;T&gt; listIterator(int index) {return list.listIterator(index);} @Override public List&lt;T&gt; subList(int fromIndex, int toIndex) {return list.subList(fromIndex, toIndex);}} ImprovedList 通过将操作委托给底层的 List 实例，实现了 List 的操作，同时还添加了一个原子的putIfAbsent()方法。 就像 Collections.synchronizedList 和其他容器封装器那样，ImprovedList 假设一旦有一个 list 传给它的构造函数后，客户将不再直接使用这个 list，而仅仅通过 ImprovedList 访问它。 通过使用内部锁，ImproveaList 引入了一个新的锁层。 它并不关心底层的 List 是否线程安全，即使 List 不是线程安全的，或者会改变 ImproveaList 的锁实现，Improvedtist 都有自己兼容的锁可以提供线程安全性。 虽然额外的一层同步可能会带来一些微弱的性能损失，但是相比于去尝试模拟另一个对象的锁策路而言，ImprovedList并不那么脆弱。 我们己经使用 Java 监视器模式有效地封裝了一个己有的 List，而且只要我们的类持有底层 List 的唯一外部引用，那么就能保证提供线程安全性。 5. 同步策略的文档化1.为类的用户编写类线程安全性担保的文档；为类的维护者编写类的同步文档。 2.每次使用synchronized，volatile或者任何线程安全类，都表现了一种同步策略，这个策略是你程序设计的一个元素，因此应该将它文档化。","link":"/posts/f8f2.html"},{"title":"Java并发编程实战：第8章 应用线程池","text":"1. 应用线程池1.1 在任务与执行策略之间的隐性耦合Executor 框架可以将任务的提交与任务的执行策略解耦开来。Executor 框架为制定和修改执行策略提供了相当大的灵活性，但并非所有的任务都能适用所有的执行策略。 有些类型的任 务需要明确地指定执行策略， 包括： 依赖性任务：简单来说就是，提交的 task 是需要依赖 其它任务 的， task 就类似有某种枷锁一样，浑身不自在。 大多数任务都是独立的，它们不依赖于其他任务的执行时序、 执行结果或其他效果。 当在线程池中执行独立的任务时， 可以随意地改变线程池的大小和配置，这些修改只会对执行性能产生影响。 如果提交给线程池的任务需要依赖其他的任务， 那么就隐含地给执行策略带来了约束， 此时必须小心地维持这些执行策略，以避免产生活跃性问题。 采用线程封闭机制的任务： 在单线程中的 Executor：能够对并发性做出更强的承诺。 它们能确保任务不会并发地执行， 使我们能够放宽代码对线程安全的要求。对象可以封闭在 task 所在的线程中， 使得在该线程中执行的 task 在访问该对象时不需要同步， 即使这些资源不是线程安全的也没有问题。 Executor 从单线程环境改为线程池环境，任务可能会被并发地执行，失去了线程安全性。 对响应时间敏感的任务： GUI应用程序对于响应时间是敏感的：如果用户在点击按钮后需要很长延迟才能得到可见的反馈， 那么他们会感到不满。 如果将一个运行时间较长的任务提交到单线程的Executor中， 或者将多个运行时间较长的任务提交到一个只包含少量线程的线程池 中， 那么将降低由该Executor管理的服务的响应性。 ​ 使用ThreadLocal的任务： ThreadLocal使每个线程都可以拥有某个变量的一个私有版本。然而，只要条件允许，Executor可以自由地重用这些线程。 在标准的Executor实现中，当执行需求较低时将回收空闲线程，而当需求增加时将添加新的线程，并且如果从任务中抛出了一个未检查异常，那么将用一个新的工作者线程来替代抛出异常的线程。 只有当线程本地值的生命周期受限于任务的生命周期时，在线程池的线程中使用ThreadLocal才有意义。 在线程池的线程中不应该使用 ThreadLocal在任务之间传递值。 只有当任务都是同类型的并且相互独立时，线程池的性能才能达到最佳。如果将运行时间较长的与运行时间较短的任务混合在一起，那么除非线程池很大，否则将可能造成拥塞。如果提交的任务依赖于其他任务，那么除非线程池无限大，否则将可能造成死锁。 1.1.1 线程饥饿死锁 在多线程中，如果某个线程任务，依赖于其它任务的执行，那么就有可能会产生线程死锁。 在单线程的 Executor 中，如果一个任务将另一个任务提交到同一个 Executor，并且等待这个被提交任务的结果，那么通常会引发死锁。 第二个任务停留在工作队列中，并等待第一个任务完成，而第一个任务又无法完成，因为它在等待第二个任务的完成。 在单线程化的 Executor 中死锁的任务 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class ThreadDeadlock { // single executor ExecutorService exec = Executors.newSingleThreadExecutor(); public class LoadFileTask implements Callable&lt;String&gt; { private final String fileName; public LoadFileTask(String fileName) { this.fileName = fileName; } public String call() throws Exception { // 读取文件 return &quot;&quot;; } } public class RenderPageTask implements Callable&lt;String&gt; { public String call() throws Exception { Future&lt;String&gt; header, footer; header = exec.submit(new LoadFileTask(&quot;header.html&quot;)); footer = exec.submit(new LoadFileTask(&quot;footer.html&quot;)); String page = renderBody(); return header.get() + page + footer.get(); } private String renderBody() { // 页面渲染 return &quot;&quot;; } } public void test() { RenderPageTask mainTask = new RenderPageTask(); exec.submit(mainTask); }} 例子 ThreadDeadlock.RenderPageTask 将两个 LoadFileTask 添加到单例的 ExecutorService 中。在 tast() 中，我们将 RenderPageTask 添加到单例的 ExecutorService 中，那么会出现 mainTask 等待其他两个 LoadFileTask 的结果，久久不能结束，而那两个 LoadFileTask 却需要等待 mainTask 结束才能被单例的 ExecutorService 执行（久久不能开始）。 1.1.2 耗时操作 执行时间较长的任务不仅会造成线程池堵塞，甚至还会增加执行时间较短任务的服务时间。 如果线程池中线程的数量远小于在稳定状态下执行时间较长任务的数量， 那么到最后可能所有的线程都会运行这些执行时间较长的任务， 从而影响整体的响应性。 限定任务等待资源的时间， 而不要无限制地等待。 例如 Thread.join、BlockingQueue.put、CountDownLatch.await 以及 Selector.select 等。 1.2 定制线程池的大小在代码中通常不会固定线程池的大小。线程池的长度应该通过某种配置机制来提供，或者根据 Runtime.availableProcessors() 来动态计算。 1234public class Runtime { // 返回 Java 虚拟机可用的处理器数量。 int &gt; 0 public native int availableProcessors();} 要设置线程池的大小，需要避免【过大】和【过小】这两种极端情况。 如果线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅会导致更高的内存使用量，而且还可能耗尽资源。 如果线程池过小，那么将导致许多空闲的处理器无法执行工作，从而降低吞吐率。 如果需要执行不同类别的任务，井且它们之间的行为相差很大，那么应该考虑使用多个线程池，从而使每个线程池可以根据各自的工作负载来调整。 大小设定公式 1最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目 1.3 配置 ThreadPoolExecutorThreadPoolExecutor 为一些 Executor 提供了基本的实现，这些 Executor 是由 Executors 中 的 newCachedThreadPool、newFixedThreadPool 和 newScheduledThreadExecutor 等工厂方法返回的。 1.3.1 线程的创建与销毁 核心池大小(core pool size)、最大池的大小(maximum pool size)和存活时间(keep-alive time)共同管理着线程的创建与销段。 核心池大小是目标的大小；线程池的实现试图维护池的大小：即使没有任务执行，池的大小也等于核心池的大小，并且直到工作队列充满前，池都不会创建更多的线程。 最大池的大小是可同时活动的线程数的上限。如果一个线程已经闲置的时间超过了存活时间，它将成为一个被回收的候选者，如果当前的池的大小超过了核心池的大小，线程池会终止它。 Executors.newFixedThreadPool() 123456789101112131415161718public class Executors { public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, // 核心池大小 nThreads, // 最大池的大小 0L, // 存活时间 TimeUnit.MILLISECONDS,// 时间单位 new LinkedBlockingQueue&lt;Runnable&gt;());// 执行任务之前保存任务的队列 } public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) { return new ThreadPoolExecutor(nThreads, // 核心池大小 nThreads, // 最大池的大小 0L, // 存活时间 TimeUnit.MILLISECONDS,// 时间单位 new LinkedBlockingQueue&lt;Runnable&gt;(),// 执行任务之前保存任务的队列 threadFactory);// Executor创建新线程时使用的工厂 }} ThreadPoolExecutor 其中一个构造方法： 1234567891011121314151617181920/** * 使用给定的初始参数创建一个新的ThreadPoolExecutor 。 * 参数： * corePoolSize - 保留在池中的线程数，即使它们是空闲的，除非设置allowCoreThreadTimeOut * maximumPoolSize – 池中允许的最大线程数 * keepAliveTime – 当线程数大于核心时，这是多余的空闲线程在终止前等待新任务的最长时间。 * unit – keepAliveTime参数的时间单位 * workQueue – 用于在执行任务之前保存任务的队列。此队列将仅保存由execute方法提交的Runnable任务。 * threadFactory – 执行器创建新线程时使用的工厂 * handler – 由于达到线程边界和队列容量而阻塞执行时使用的处理程序 */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { // ......} 1.3.2 管理队列任务 有限线程池限制了可以并发执行的任务的数量。 如果新增任务的频率超过了线程池能过处理它们的速度，任务将在队列中等候。 即使通车平均任务新增都很稳定，也难免会出现突然的激增。尽管队列有助于缓和瞬时的任务激增，但是如果任务持续快速地到来，队列中很多任务等待被执行，这可能会耗尽内存。 ThreadPoolExecutor 允许提供一个 BlockingQueue 来保存等待执行的任务。 基本的任务排队方法有 3 种： 无界队列、有界队列和同步移交 (Synchronous Handoff)。 对于庞大或者无限的池，可以使用 SynchronousQueue，完全绕开队列，将任务直接从生产者移交给工作者线程。 SynchronousQueue 并不是一个真正的队列，而是一种管理直接在线程间移交信息的机制。 把一个元素放入到 SynchronousQueue 中，必须有另一个线程正在等待接受移交的任务。 如果没有这样一个线程，只要当前池的大小还小于最大值，ThreadPoolBxecutor 就会创建一个新的线程；否则根据饱和策略，任务会被拒绝。 只有当池是无限的，或者可以接受任务被拒绝，SynchronousQueue 才是一个有实际价值的选揮。 对于先进先出的队列（如：LinkedBlockingQueue、ArrayBlockingQueue），都是顺序执行任务的。如果想要控制任务的执行顺序，可以使用优先队列（PriorityBlockingQueue），通过 Comparator 定义任务优先级。 1.3.3 饱和策略当一个有限队列充满后，饱和策略开始起作用。ThreadPoolExecutor 的饱和策略可以通过 setRejectedExecutionHandler() 来修改。JDK提供的实现有：AbortPolicy、CallerRunsPolicy、DiscardPolicy 和 DiscardOldestPolicy。 中止(Abort)策略： 默认的饱和策略，该策略将抛出未检查的 RejectedExecutionException。 抛弃最旧的(Discard-Oldest)策略 该策略则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。 调用者运行(Caller-Runs)策略： 该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了execute的线程中执行该任务。 创建一个可变长的线程池，使用受限队列和 “调用者运行” 饱和策略 12345678910111213private static final Integer CORE_POOL_SIZE = 1000;private static final Integer MAXIMUM_POOL_SIZE = 2000;private static final Long KEEP_ALIVE_TIME = 0L;private static final Integer CAPACITY = 1000;ThreadPoolExecutor executor = new ThreadPoolExecutor( CORE_POOL_SIZE, // 保留在池中的线程数 MAXIMUM_POOL_SIZE, // 池中允许的最大线程数 KEEP_ALIVE_TIME, // 多余的空闲线程在终止前等待新任务的最长时间 TimeUnit.MILLISECONDS, // 时间单位 new LinkedBlockingDeque&lt;Runnable&gt;(CAPACITY), // 用于在执行任务之前保存任务的队列 new ThreadPoolExecutor.CallerRunsPolicy() // 调用者运行(Caller-Runs)策略); 使用 Semaphore 来遏制任务的提交 123456789101112131415161718192021222324252627282930313233import net.jcip.annotations.ThreadSafe;import java.util.concurrent.Executor;import java.util.concurrent.RejectedExecutionException;import java.util.concurrent.Semaphore;@ThreadSafepublic class BoundedExecutor { private final Executor exec; private final Semaphore semaphore; public BoundedExecutor(Executor exec, int bound) { this.exec = exec; this.semaphore = new Semaphore(bound); } public void submitTask(final Runnable command) throws InterruptedException { semaphore.acquire(); try { exec.execute(new Runnable() { public void run() { try { command.run(); } finally { semaphore.release(); } } }); } catch (RejectedExecutionException e) { semaphore.release(); } }} 1.3.4 线程工厂 每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。 默认的线程工厂方法将创建一个新的、非守护的线程，并且没有特殊的配置。 通过指定一个线程工厂方法，可以定制线程池的配置信息。 在 ThreadFactory 中只定义了一个方法 newThread()，每当线程池需要创建一个新线程时都会调用这个方法。 定制的线程工厂 12345678910111213141516import java.util.concurrent.ThreadFactory;import java.util.concurrent.atomic.AtomicInteger;import java.util.logging.Level;import java.util.logging.Logger;public class MyThreadFactory implements ThreadFactory { private final String poolName; public MyThreadFactory(String poolName) { this.poolName = poolName; } public Thread newThread(Runnable runnable) { return new MyAppThread(runnable, poolName); }} 自定义的线程基类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class MyAppThread extends Thread { /** 线程默认名称 */ public static final String DEFAULT_NAME = &quot;MyAppThread&quot;; /** 是否调用 debug 调试生命周期 */ private static volatile boolean debugLifecycle = false; /** 线程名称的一部分：这里使用递增数命名线程 */ private static final AtomicInteger created = new AtomicInteger(); /** 运行的线程数 */ private static final AtomicInteger alive = new AtomicInteger(); /** 日志 */ private static final Logger log = Logger.getAnonymousLogger(); public MyAppThread(Runnable r) { this(r, DEFAULT_NAME); } public MyAppThread(Runnable runnable, String name) { // 线程初始化 super(runnable, name + &quot;-&quot; + created.incrementAndGet()); // 未捕获的异常处理 setUncaughtExceptionHandler(new UncaughtExceptionHandler() { public void uncaughtException(Thread t, Throwable e) { log.log(Level.SEVERE, &quot;未捕获的异常线程：&quot; + t.getName(), e); } }); } public void run() { // 复制 debug 调试断言，以确保始终一致的值。 boolean debug = debugLifecycle; if (debug) log.log(Level.FINE, &quot;Created &quot; + getName()); try { alive.incrementAndGet(); super.run(); } finally { alive.decrementAndGet(); if (debug) log.log(Level.FINE, &quot;Exiting &quot; + getName()); } } public static int getThreadsCreated() { return created.get(); } public static int getThreadsAlive() { return alive.get(); } public static boolean getDebug() { return debugLifecycle; } public static void setDebug(boolean b) { debugLifecycle = b; }} 1.3.5 构造后再定制 ThreadPoolExecutor 大多数通过构造函数传递给 ThreadPoolExecutor 的参数（比如核心池大小，最大池大小，存活时间，线程工厂和拒绝执行处理器(rejected execution handler)），都可以在创建 Executor 后通过 setters 进行修改。Executors.newSingleThreadExecutor() 创建的 Executor 除外。 123456public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));} newSingleThreadExecutor() 与其他方法的实现不同，它按 FinalizableDelegatedExecutorService 方式封装的 ExecutorService，而不是原始的 ThreadPoolExecutor。 在 Executors中包含一个 unconfigurableExecutorService() 工厂方法： 12345public static ExecutorService unconfigurableExecutorService(ExecutorService executor) { if (executor == null) throw new NullPointerException(); return new DelegatedExecutorService(executor);} 它返回一个现有的 ExecutorService，并对它进行包装。它只暴露出 ExecutorService 的方法，不能进行进一步的配置。 1.4 扩展 ThreadPoolExecutorThreadPoolExecutor 是可扩展的， 它提供了几个 “钩子” 方法让子类去复写： beforeExecute() 12345678910/** * 在给定线程中，执行给定 Runnable 之前调用的方法。 * 此方法由将执行 【Runnable r】 的线程 【Thread t】 调用，并可用于重新初始化 ThreadLocals，或执行日志记录 * 这个实现什么都不做，但可以在子类中定制。 * * 参数： * t - 将运行【Runnable r】的线程 * r - 将要执行的任务 */protected void beforeExecute(Thread t, Runnable r) { } afteExecute() 12345678910/** * 在完成给定 Runnable 的执行时调用的方法。 * 如果 【Throwable != null】，则 Throwable 是导致执行突然终止的未捕获的 RuntimeException 或 Error * 这个实现什么都不做，但可以在子类中定制。 * * 参数： * t - 导致终止的异常，如果执行正常完成，则返回 null * r - 已完成的任务 */protected void afterExecute(Runnable r, Throwable t) { } terminated() 12/** Executor 终止时调用的方法。这个实现什么都不做，但可以在子类中定制。 */protected void terminated() { } 扩展线程池，以提供日志和计时功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicLong;import java.util.logging.Logger;public class TimingThreadPool extends ThreadPoolExecutor { public TimingThreadPool() { super(1, 1, 0L, TimeUnit.SECONDS, null); } private final ThreadLocal&lt;Long&gt; startTime = new ThreadLocal&lt;Long&gt;(); private final Logger logger = Logger.getLogger(String.valueOf(TimingThreadPool.class)); private final AtomicLong numTasks = new AtomicLong(); private final AtomicLong totalTime = new AtomicLong(); protected void beforeExecute(Thread t, Runnable r) { super.beforeExecute(t, r); logger.fine(String.format(&quot;Thread %s: start %s&quot;, t, r)); startTime.set(System.nanoTime()); } protected void afterExecute(Runnable r, Throwable t) { try { long endTime = System.nanoTime(); long taskTime = endTime - startTime.get(); numTasks.incrementAndGet(); totalTime.addAndGet(taskTime); logger.fine(String.format(&quot;Thread %s: end %s, time=%dns&quot;, t, r, taskTime)); } finally { super.afterExecute(r, t); } } protected void terminated() { try { logger.info(String.format(&quot;Terminated: avg time=%dns&quot;, totalTime.get() / numTasks.get())); } finally { super.terminated(); } }} 2. 并行递归算法2.1 并行递归算法如果每一个循环的每次迭代都睡觉哦独立的，并且我们不必等待所有的迭代都完成后再一次处理，那么我们可以使用 Executor 把一个顺序的循环转化为并行的循环。 把顺序执行转换为并行执行 123456789101112131415161718192021222324252627282930import java.util.Collection;import java.util.List;import java.util.Queue;import java.util.concurrent.ConcurrentLinkedQueue;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public abstract class TransformingSequential { /** 顺序执行 */ void processSequentially(List&lt;Element&gt; elements) { for (Element e : elements) { process(e); } } /** 并行执行 */ void processInParallel(Executor exec, List&lt;Element&gt; elements) { for (final Element e : elements) { exec.execute(() -&gt; process(e)); } } public abstract void process(Element e); interface Element { }} 当每个选代彼此独立，并且完成循环体中每个送代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的。 把顺序递归转化为并行递归 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Collection;import java.util.List;import java.util.Queue;import java.util.concurrent.ConcurrentLinkedQueue;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;public abstract class TransformingSequential { /** 顺序递归 */ public &lt;T&gt; void sequentialRecursive(List&lt;Node&lt;T&gt;&gt; nodes, Collection&lt;T&gt; results) { for (Node&lt;T&gt; n : nodes) { results.add(n.compute()); sequentialRecursive(n.getChildren(), results); } } /** 并行递归 */ public &lt;T&gt; void parallelRecursive(final Executor exec, List&lt;Node&lt;T&gt;&gt; nodes, final Collection&lt;T&gt; results) { for (final Node&lt;T&gt; n : nodes) { exec.execute(() -&gt; results.add(n.compute())); parallelRecursive(exec, n.getChildren(), results); } } /** 执行并行递归，获取结果 */ public &lt;T&gt; Collection&lt;T&gt; getParallelResults(List&lt;Node&lt;T&gt;&gt; nodes) throws InterruptedException { ExecutorService exec = Executors.newCachedThreadPool(); Queue&lt;T&gt; resultQueue = new ConcurrentLinkedQueue&lt;T&gt;(); parallelRecursive(exec, nodes, resultQueue); exec.shutdown(); exec.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS); return resultQueue; } interface Node &lt;T&gt; { T compute(); List&lt;Node&lt;T&gt;&gt; getChildren(); }} 2.2 示例：谜题框架 “搬箱子” 谜题的抽象 1234567891011121314151617181920import java.util.Set;/** * “搬箱子” 谜题的抽象 * @param &lt;P&gt; 位置 * @param &lt;M&gt; 移动 */public interface Puzzle &lt;P, M&gt; { /** 初始化 */ P initialPosition(); /** 移动位置是否为本位置 */ boolean isGoal(P position); /** 合法移动 */ Set&lt;M&gt; legalMoves(P position); /** 搬箱子 */ P move(P position, M move);} 谜题解决者框架的链节点 1234567891011121314151617181920212223242526272829import net.jcip.annotations.Immutable;import java.util.LinkedList;import java.util.List;@Immutablepublic class PuzzleNode &lt;P, M&gt; { /** 位置 */ final P pos; /** 移动位置 */ final M move; /** 上一个位置 */ final PuzzleNode&lt;P, M&gt; prev; public PuzzleNode(P pos, M move, PuzzleNode&lt;P, M&gt; prev) { this.pos = pos; this.move = move; this.prev = prev; } /** 链表转集合 */ List&lt;M&gt; asMoveList() { List&lt;M&gt; solution = new LinkedList&lt;M&gt;(); for (PuzzleNode&lt;P, M&gt; node = this; node.move != null; node = node.prev) { solution.add(0, node.move); } return solution; }} 顺序话版的谜题解决者 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.HashSet;import java.util.List;import java.util.Set;public class SequentialPuzzleSolver &lt;P, M&gt; { private final Puzzle&lt;P, M&gt; puzzle; private final Set&lt;P&gt; seen = new HashSet&lt;P&gt;(); public SequentialPuzzleSolver(Puzzle&lt;P, M&gt; puzzle) { this.puzzle = puzzle; } /** 解决者 */ public List&lt;M&gt; solve() { P pos = puzzle.initialPosition(); return search(new PuzzleNode&lt;P, M&gt;(pos, null, null)); } /** 箱子移动 */ private List&lt;M&gt; search(PuzzleNode&lt;P, M&gt; node) { // 该位置不存在箱子，或者箱子没有到过这个位置 if (!seen.contains(node.pos)) { seen.add(node.pos); // 移动位置是否为本位置 if (puzzle.isGoal(node.pos)) { return node.asMoveList(); } // 获取每个合法移动 for (M move : puzzle.legalMoves(node.pos)) { // 当前箱子位置移动 P pos = puzzle.move(node.pos, move); // 下一个箱子移动 PuzzleNode&lt;P, M&gt; child = new PuzzleNode&lt;&gt;(pos, move, node); List&lt;M&gt; result = this.search(child); if (result != null) { return result; } } } return null; }} 并发版的谜题解决者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.util.List;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;public class ConcurrentPuzzleSolver &lt;P, M&gt; { /** 搬箱子谜题 */ private final Puzzle&lt;P, M&gt; puzzle; private final ExecutorService exec; /** 箱子是否存在该位置 */ private final ConcurrentMap&lt;P, Boolean&gt; seen; /** 可携带结果的闭锁 */ protected final ValueLatch&lt;PuzzleNode&lt;P, M&gt;&gt; solution = new ValueLatch&lt;&gt;(); public ConcurrentPuzzleSolver(Puzzle&lt;P, M&gt; puzzle) { this.puzzle = puzzle; // Return ThreadPoolExecutor Object this.exec = initThreadPool(); this.seen = new ConcurrentHashMap&lt;P, Boolean&gt;(); if (exec instanceof ThreadPoolExecutor) { ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) exec; // 被拒绝任务，它默默地丢弃被拒绝的任务。 threadPoolExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy()); } } private ExecutorService initThreadPool() { return Executors.newCachedThreadPool(); } /** 解决者 */ public List&lt;M&gt; solve() throws InterruptedException { try { P p = puzzle.initialPosition(); exec.execute(newTask(p, null, null)); // 阻塞，知道找到一个方案 PuzzleNode&lt;P, M&gt; solutionPuzzleNode = solution.getValue(); return (solutionPuzzleNode == null) ? null : solutionPuzzleNode.asMoveList(); } finally { exec.shutdown(); } } protected Runnable newTask(P position, M move, PuzzleNode&lt;P, M&gt; puzzleNode) { return new SolverTask(position, move, puzzleNode); } protected class SolverTask extends PuzzleNode&lt;P, M&gt; implements Runnable { SolverTask(P pos, M move, PuzzleNode&lt;P, M&gt; prev) { super(pos, move, prev); } public void run() { // 已找到一个解决方案，或者该位置曾经到达过 if (solution.isSet() || seen.putIfAbsent(pos, true) != null) { return; } // 移动位置是否为本位置 if (!puzzle.isGoal(pos)) { // 获取每个合法移动 for (M move : puzzle.legalMoves(pos)) { exec.execute( // 创建一个新的 task 进行位置移动 newTask(puzzle.move(pos, move), move, this) ); } } else { // 移动位置为本位置 solution.setValue(this); } } }} ConcurrentPuzzleSolver 使用可携带结果的闭锁 123456789101112131415161718192021222324252627@ThreadSafepublic class ValueLatch &lt;T&gt; { @GuardedBy(&quot;this&quot;) private T value = null; /** 一种同步辅助，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。 */ private final CountDownLatch done = new CountDownLatch(1); public boolean isSet() { return (done.getCount() == 0); } public synchronized void setValue(T newValue) { if (!isSet()) { value = newValue; // Decrease ---&gt; 【done.getCount() - 1】 done.countDown(); } } public T getValue() throws InterruptedException { // 当前线程等待直到锁存器倒计时到零 done.await(); synchronized (this) { return value; } }}","link":"/posts/9a9d.html"},{"title":"Redis 分布式锁的实现","text":"1. Redis 分布式锁说明Java 实现 Redis 分布式锁案例已经上传到笔者的GitHub，欢迎下载参考，如有错误希望大佬指正。 在大多数情况下，应该都是使用成熟的分布式锁框架，如 Redisson。这里只是根据 Redisson 部分源码思想进行的个人摸索，编写了一个利用Redis实现的分布式可重入锁，包含看门狗对锁进行续期。 1.1 什么是 Redis 分布式锁 在 Java 中提供了 synchronized 和 Lock 锁，来保证多线程程序中的线程安全问题。 分布式锁指的是，在分布式系统，不同的进程中，访问共享资源的一张锁的实现。 如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。 1.2 分布式锁需要满足的条件 互斥性。在任意时刻，只有一个线程能持有锁。 重入锁。一个线程能重复获取同一把锁。 不会发生死锁。即使有一个线程在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。 具有容错性。只要大部分的 Redis 节点正常运行，就可以加锁和解锁。 解铃还须系铃人。加锁和解锁必须是同一个线程，自己不能把别人加的锁给解了。 锁过期续费。在线程任务未完成的情况下，需要自动续约锁，以防锁过期。 1.3 Redis 分布式锁原理 加锁 一个分布式系统中，可能会存在各种各样的分布式锁，这些锁，都应该有一个标识，如：lock1、lock2、lock3… 对于一把锁，如标识为lock1的锁，可能会有好几个不同机器上的线程在竞争。 竞争锁的线程，也应该给它们一个线程标识，如：uuid1、uuid2、uuid3… 如果线程 uuid1 获取了锁 lock1，在还未释放锁的时候，允许线程 uuid1 能重复获取 lock1(记录获取数量)，释放直到获取该锁的数量为零(锁不再被线程uuid1持有) Redis 哈希是结构化为字段值对集合的记录类型。可以使用散列来表示基本对象并存储计数器分组等。 1hset key filed value 散列表(hashmap)能够满足保存：锁标识:线程标识:重入次数 解锁 如上面加锁中所述，锁是可以重入的。 一个线程可以重复获取同一把锁，因此每次解锁，该锁的记录值 value 应该减1 如果某个线程获取锁 lock1 的值为零了，锁应该被释放，这时候要允许别的线程获取锁 lock1。 1.4 Redis 分布式锁实现原理(lua 脚本说明)我们都知道 redis 是单线程的，因此可以通过lua脚本来获取锁、释放锁、锁续期，保证原子性。 加锁 KEYS[1] —- 锁标识 ARGV[1] —- 线程标识 ARGV[2] —- 锁过期时间 12345678910111213141516171819202122232425-- 是否有线程获取了锁 KEYS[1]if (redis.call('exists', KEYS[1]) == 0) then -- 没有线程获取锁 KEYS[1]， 创建散列表数据类型的锁 KEYS[1]，并为 KEYS[1] 锁中的 ARGV[1] 字段值加上指定增量值 1 redis.call('hincrby', KEYS[1], ARGV[1], 1); -- 设置 KEYS[1] 锁的到期时间(单位：ms) redis.call('pexpire', KEYS[1], ARGV[2]); return 1; end; -- 当前线程持有该锁的数量local beforeGetCurrentLockHasNum = 0; -- 锁 KEYS[1] 中是否存在字段 ARGV[1]，如果存在，那么说明是当前线程 ARGV[1] 获取了锁 KEYS[1]if (redis.call('hexists', KEYS[1], ARGV[1]) == 1) then -- 获取当前线程持有该锁的数量 beforeGetCurrentLockHasNum = redis.call('hget', KEYS[1], ARGV[1]); -- 为 KEYS[1] 锁中的 ARGV[1] 字段值加上指定增量值(1) redis.call('hincrby', KEYS[1], ARGV[1], 1); -- 以毫秒为单位来设置 KEYS[1] 锁的过期时间 ARGV[2] --- (更新过期时间) redis.call('pexpire', KEYS[1], ARGV[2]); -- 获取线程 ARGV[1] 现在拥有锁 KEYS[1] 的数量，减去之前没有重入时的数量，看看是否重入成功，重入成功，那么结果=1 local afterGetCurrentLockHasNum = redis.call('hget', KEYS[1], ARGV[1]) - beforeGetCurrentLockHasNum; -- 如果获取成功，那么结果=1，否则=0 return afterGetCurrentLockHasNum; end; -- 线程 ARGV[1] 不持有锁 KEYS[1]，锁已经被其它线程获取了，beforeGetCurrentLockHasNum = 0return beforeGetCurrentLockHasNum; 解锁 KEYS[1] —- 锁标识 ARGV[1] —- 线程标识 1234567891011121314-- 查看线程 ARGV[1] 是否获取了 KEYS[1] 锁if (redis.call('hexists', KEYS[1], ARGV[1]) == 0) then -- 线程 ARGV[1] 没有获取 KEYS[1] 锁 return 0; end; -- 线程 ARGV[1] 获取了 KEYS[1] 锁，释放一个锁，然后查看当前重入次数(持有量)local counter = redis.call('hincrby', KEYS[1], ARGV[1], -1); if (counter == 0) then -- 释放锁后，不再持有锁，删除 KEYS[1] 锁，允许后续别的线程加锁 redis.call('del', KEYS[1]); return 1; end; -- 释放锁后，还持有锁，返回释放锁的数量：1return 1; 锁续期 KEYS[1] —- 锁标识 ARGV[1] —- 线程标识 ARGV[2] —- 重置时间 12345678-- 是否是该线程 ARGV[1] 获取了锁 KEYS[1]if (redis.call('hexists', KEYS[1], ARGV[1]) == 0) then -- 不是该线程 ARGV[1] 获取了锁 KEYS[1] return 'fail'; end;-- 是该线程 ARGV[1] 获取了锁 KEYS[1]，重置过期时间 ARGV[2]redis.call('pexpire', KEYS[1], ARGV[2]); return 'success'; 2. Java 实现 Redis 分布式锁这里通过 Spring Boot 示例项目，使用 spring-boot-starter-data-redis 来连接 redis。主要是体现其实现思想。 创建一个 RedisLock 类： 12345678910111213141516171819202122232425import org.springframework.context.annotation.DependsOn;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.data.redis.core.script.RedisScript;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.util.Collections;import java.util.UUID;@Component(value = &quot;redisLock&quot;)@DependsOn({&quot;stringRedisTemplate&quot;, &quot;redisTemplate&quot;, &quot;redisConnectionFactory&quot;})public class RedisLock { /** 这里使用的是spring-boot-starter-data-redis，使用别的Redis连接工具也一样 */ @Resource(name = &quot;stringRedisTemplate&quot;) private StringRedisTemplate stringRedisTemplate; /** 生成一个 uuid 标识一个线程 */ public static String generationUuid() { // 线程标识 return UUID.randomUUID().toString(); }} 2.1 获取锁12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 获取锁，可重入锁 * * @param lockKey 锁标识 KEY[1] * @param uuid 线程标识 ARGV[1] * @param expireTime 锁过期时间 ARGV[2] * @return 是否获取成功 */public boolean lock(String lockKey, String uuid, long expireTime) { if (expireTime &lt;= 0) { return false; } boolean lock = false; // 最后返回 0 或 1（0表示获取锁失败，1表示获取锁成功） String luaScriptStr = // 是否有线程获取了锁 KEYS[1] &quot;if (redis.call('exists', KEYS[1]) == 0) then &quot; + // 没有线程获取锁 KEYS[1]， 创建散列表数据类型的锁 KEYS[1]，并为 KEYS[1] 锁中的 ARGV[1] 字段值加上指定增量值 1 &quot;redis.call('hincrby', KEYS[1], ARGV[1], 1); &quot; + // 设置 KEYS[1] 锁的到期时间(单位：ms) &quot;redis.call('pexpire', KEYS[1], ARGV[2]); &quot; + &quot;return 1; &quot; + &quot;end; &quot; + // 当前线程持有该锁的数量 &quot;local beforeGetCurrentLockHasNum = 0; &quot; + // 锁 KEYS[1] 中是否存在字段 ARGV[1]，如果存在，那么说明是当前线程 ARGV[1] 获取了锁 KEYS[1] &quot;if (redis.call('hexists', KEYS[1], ARGV[1]) == 1) then &quot; + // 获取当前线程持有该锁的数量 &quot;beforeGetCurrentLockHasNum = redis.call('hget', KEYS[1], ARGV[1]); &quot; + // 为 KEYS[1] 锁中的 ARGV[1] 字段值加上指定增量值(1) &quot;redis.call('hincrby', KEYS[1], ARGV[1], 1); &quot; + // 以毫秒为单位来设置 KEYS[1] 锁的过期时间 ARGV[2] --- (更新过期时间) &quot;redis.call('pexpire', KEYS[1], ARGV[2]); &quot; + // 获取线程 ARGV[1] 现在拥有锁 KEYS[1] 的数量，减去之前没有重入时的数量，看看是否重入成功，重入成功，那么结果=1 &quot;local afterGetCurrentLockHasNum = redis.call('hget', KEYS[1], ARGV[1]) - beforeGetCurrentLockHasNum; &quot; + // 如果获取成功，那么结果=1，否则=0 &quot;return afterGetCurrentLockHasNum; &quot; + &quot;end; &quot; + // 线程 ARGV[1] 不持有锁 KEYS[1]，锁已经被其它线程获取了，beforeGetCurrentLockHasNum = 0 &quot;return beforeGetCurrentLockHasNum; &quot;; RedisScript&lt;Long&gt; luaScriptObj = new DefaultRedisScript&lt;&gt;(luaScriptStr, Long.class); String result = String.valueOf(stringRedisTemplate.execute( luaScriptObj, // KEY[1]=lockKey Collections.singletonList(lockKey), // ARGV[1]=uuid，ARGV[2]=expireTime uuid, String.valueOf(expireTime) )); if (!&quot;0&quot;.equals(result)) { lock = true; System.out.printf(&quot;线程：%s，获取锁：%s，过期时间：%s\\n&quot;, uuid, lockKey, expireTime); } return lock;} 2.2 释放锁12345678910111213141516171819202122232425262728293031323334353637/** * 释放锁，可重入锁 * * @param lockKey 锁标识 KEY[1] * @param uuid 线程标识 ARGV[1] * @return 是否释放成功 */public boolean unlock(String lockKey, String uuid) { boolean release = false; // 最后返回 0 或 1（0表示没有释放锁，或者释放锁失败。1表示释放锁成功） String luaScriptStr = // 查看线程 ARGV[1] 是否获取了 KEYS[1] 锁 &quot;if (redis.call('hexists', KEYS[1], ARGV[1]) == 0) then &quot; + // 线程 ARGV[1] 没有获取 KEYS[1] 锁 &quot;return 0; &quot; + &quot;end; &quot; + // 线程 ARGV[1] 获取了 KEYS[1] 锁，释放一个锁，然后查看当前重入次数(持有量) &quot;local counter = redis.call('hincrby', KEYS[1], ARGV[1], -1); &quot; + &quot;if (counter == 0) then &quot; + // 释放锁后，不再持有锁，删除 KEYS[1] 锁，允许后续别的线程加锁 &quot;redis.call('del', KEYS[1]); &quot; + &quot;return 1; &quot; + &quot;end; &quot; + // 释放锁后，还持有锁，返回释放锁的数量：1 &quot;return 1; &quot;; RedisScript&lt;Long&gt; luaScriptObj = new DefaultRedisScript&lt;&gt;(luaScriptStr, Long.class); String result = String.valueOf(stringRedisTemplate.execute( luaScriptObj, Collections.singletonList(lockKey), uuid )); if (&quot;1&quot;.equals(result)) { release = true; System.out.printf(&quot;线程：%s，释放锁：%s\\n&quot;, uuid, lockKey); } return release;} 2.3 锁续期1234567891011121314151617181920212223242526272829303132333435/** * 锁续期 * * @param lockKey 锁标识 KEY[1] * @param uuid 线程标识 ARGV[1] * @param expireTime 重置时，所得过期时间 ARGV[2] * @return 续期成功/无需续期 true，续期失败 false */public boolean renewal(String lockKey, String uuid, long expireTime) { String luaScriptStr = // 是否是该线程 ARGV[1] 获取了锁 KEYS[1] &quot;if (redis.call('hexists', KEYS[1], ARGV[1]) == 0) then &quot; + // 不是该线程 ARGV[1] 获取了锁 KEYS[1] &quot;return 'fail'; &quot; + &quot;end; &quot; + // 是该线程 ARGV[1] 获取了锁 KEYS[1]，重置过期时间 ARGV[2] &quot;redis.call('pexpire', KEYS[1], ARGV[2]); &quot; + &quot;return 'success'; &quot;; if (expireTime &lt;= 0) { return false; } boolean renewal = false; RedisScript&lt;String&gt; luaScriptObj = new DefaultRedisScript&lt;&gt;(luaScriptStr, String.class); String result = stringRedisTemplate.execute( luaScriptObj, Collections.singletonList(lockKey), uuid, String.valueOf(expireTime) ); if (&quot;success&quot;.equals(result)) { renewal = true; System.out.printf(&quot;线程：%s，持有锁：%s，进行续期：%s\\n&quot;, uuid, lockKey, expireTime); } return renewal;} 3. Java 实现锁续期3.1 创建一个注解创建一个注解，用于标识获取锁、释放锁。 1234567891011121314151617import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface LockMethodListener { /** * 获取锁：true * 释放锁：false */ boolean isGetLock() default false;} 3.2 使用注解在获取锁方法【lock】、释放锁方法【unlock】上使用该注解： 1234@LockMethodListener(isGetLock = true)public boolean lock(String lockKey, String uuid, long expireTime) { // 获取锁} 1234@LockMethodListener(isGetLock = false)public boolean unlock(String lockKey, String uuid) { // 释放锁} 3.3 编写切面前面虽说是已经完成了注解的编写，但无实质处理。下面针对使用了注解 LockMethodListener 的方法编写切面。下面代码需要用到 LockListener.java 锁监听类，后续 3.4 锁监听类 部分衔接。 创建切面类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;@Aspect@Componentpublic class LockMethodListenerAspect { /** * 看门狗信息Map */ private static final ConcurrentHashMap&lt;String, LockInfo&gt; WITCH_DOG_MAP = new ConcurrentHashMap&lt;&gt;(); /** * 执行续期的线程池 */ private static final ScheduledThreadPoolExecutor SCHEDULED_THREAD_POOL_EXECUTOR = new ScheduledThreadPoolExecutor(30); @Resource(name = &quot;redisLock&quot;) private RedisLock redisLock; /** * 看门狗相关信息 */ private static class LockInfo { /** * 看门狗任务 */ public ScheduledFuture&lt;?&gt; future; /** * 锁重入次数 */ public int reentrant; public LockInfo(ScheduledFuture&lt;?&gt; future, int reentrant) { this.future = future; this.reentrant = reentrant; } }} 切面规则/表达式 123@Pointcut(&quot;@annotation(lockMethodListener)&quot;)public void lockPointCut(LockMethodListener lockMethodListener) {} 编写切入逻辑 一旦有线程调用了获取锁/释放锁方法后，就会执行该逻辑 123456789101112131415161718192021222324252627282930@AfterReturning( returning = &quot;resultValue&quot;, value = &quot;lockPointCut(lockMethodListener)&quot;, argNames = &quot;joinPoint,lockMethodListener,resultValue&quot;)public void afterMethodListener(JoinPoint joinPoint, LockMethodListener lockMethodListener, Boolean resultValue) { // 参数获取 Object[] args = joinPoint.getArgs(); boolean isGetLock = lockMethodListener.isGetLock(); // 获取锁true，释放锁false String lockKey = String.valueOf(args[0]); // 锁标识 String uuid = String.valueOf(args[1]); // 线程标识 // 如果没有获取到锁，直接返回，无需启动/关闭 看门狗 if (!resultValue) { return; } // 锁(获取) if (isGetLock) { long expireTime = Long.parseLong(String.valueOf(args[2])); if (expireTime &lt;= 0) { // 若是执行加锁操作时，锁的过期时间设置为0，那么不用启动 看门狗 return; } witch(lockKey, uuid, expireTime); return; } // 锁(释放) unWitch(lockKey, uuid);} 3.4 监听锁续期方法 看门狗 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 看门狗 * * @param lockKey 锁标识 * @param uuid 线程标识 * @param expireTime 锁过期时间 */public void witch(String lockKey, String uuid, long expireTime) { String key = lockKey + uuid; // 如果该线程已经启动过看门狗，那么不再启动看门狗，每个锁只启动一个看门狗 LockInfo reentrantInfo = WITCH_DOG_MAP.get(lockKey + uuid); if (reentrantInfo != null) { ++reentrantInfo.reentrant; return; } // 该线程没有启动过看门狗（线程首次获取锁） // 创建一个锁续期相关的延时任务 ScheduledFuture&lt;?&gt; future = SCHEDULED_THREAD_POOL_EXECUTOR.scheduleAtFixedRate( // 执行续期的task new LockAsync(this.redisLock, lockKey, uuid, expireTime), // 首次执行间隔时间 expireTime / 2, // 后续执行间隔时间 expireTime / 2, // 时间单位 TimeUnit.MILLISECONDS ); // 保存该线程看门狗，待任务完成后，删除该看门狗。启动看门狗时 reentrant = 1 reentrantInfo = new LockInfo(future, 1); WITCH_DOG_MAP.put(key, reentrantInfo);}/** * 执行锁续期的任务 */public static class LockAsync implements Runnable { /** * redis锁类 */ private final RedisLock redisLock; /** * 锁标识 */ private final String lockKey; /** * 线程标识 */ private final String uuid; /** * 过期时间 */ private final long expireTime; public LockAsync(RedisLock redisLock, String lockKey, String uuid, long expireTime) { this.redisLock = redisLock; this.lockKey = lockKey; this.uuid = uuid; this.expireTime = expireTime; } @Override public void run() { // 锁续期 this.redisLock.renewal(this.lockKey, this.uuid, this.expireTime); }} 关闭看门狗 1234567891011121314151617181920/** * 锁被释放，去掉看门狗 * * @param lockKey 锁标识 * @param uuid 线程标识 */public void unWitch(String lockKey, String uuid) { // 任务完成后，删除对应线程看门狗（重入次数为0时，任务已经完成，可以删除看门狗） LockInfo reentrantInfo = WITCH_DOG_MAP.get(lockKey + uuid); if (reentrantInfo == null || reentrantInfo.future.isCancelled()) { return; } // 按照 锁重入次数进行判断，当重入次数为0时，关闭看门狗 // --reentrantInfo.reentrant; // if (reentrantInfo.reentrant &lt;= 0) { // reentrantInfo.future.cancel(true); // } // 正常情况下，一但执行锁释放，直接关闭看门狗 reentrantInfo.future.cancel(true);} 切面整体代码如下： 锁每隔半个过期时间，就会续期一次 每次续期后，过期时间恢复为最初的过期时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;@Aspect@Componentpublic class LockMethodListenerAspect { /** * 看门狗信息Map */ private static final ConcurrentHashMap&lt;String, LockInfo&gt; WITCH_DOG_MAP = new ConcurrentHashMap&lt;&gt;(); /** * 执行续期的线程池 */ private static final ScheduledThreadPoolExecutor SCHEDULED_THREAD_POOL_EXECUTOR = new ScheduledThreadPoolExecutor(30); @Resource(name = &quot;redisLock&quot;) private RedisLock redisLock; @Pointcut(&quot;@annotation(lockMethodListener)&quot;) public void lockPointCut(LockMethodListener lockMethodListener) { } @AfterReturning( returning = &quot;resultValue&quot;, value = &quot;lockPointCut(lockMethodListener)&quot;, argNames = &quot;joinPoint,lockMethodListener,resultValue&quot; ) public void afterMethodListener(JoinPoint joinPoint, LockMethodListener lockMethodListener, Boolean resultValue) { // 参数获取 Object[] args = joinPoint.getArgs(); boolean isGetLock = lockMethodListener.isGetLock(); // 获取锁true，释放锁false String lockKey = String.valueOf(args[0]); // 锁标识 String uuid = String.valueOf(args[1]); // 线程标识 // 如果没有获取到锁，直接返回，无需启动 看门狗 if (!resultValue &amp;&amp; !isGetLock) { return; } // 锁(获取)：获取锁成功 if (resultValue &amp;&amp; isGetLock) { long expireTime = Long.parseLong(String.valueOf(args[2])); if (expireTime &lt;= 0) { // 若是执行加锁操作时，锁的过期时间设置为0，那么不用启动 看门狗 return; } witch(lockKey, uuid, expireTime); return; } // 锁(释放)：释放锁成功 if (isGetLock) { unWitch(lockKey, uuid); } } /** * 看门狗 * * @param lockKey 锁标识 * @param uuid 线程标识 * @param expireTime 锁过期时间 */ public void witch(String lockKey, String uuid, long expireTime) { String key = lockKey + uuid; // 如果该线程已经启动过看门狗，那么不再启动看门狗，每个锁只启动一个看门狗 LockInfo reentrantInfo = WITCH_DOG_MAP.get(lockKey + uuid); if (reentrantInfo != null) { ++reentrantInfo.reentrant; return; } // 该线程没有启动过看门狗（线程首次获取锁） // 创建一个锁续期相关的延时任务 ScheduledFuture&lt;?&gt; future = SCHEDULED_THREAD_POOL_EXECUTOR.scheduleAtFixedRate( // 执行续期的task new LockAsync(this.redisLock, lockKey, uuid, expireTime), // 首次执行间隔时间 expireTime / 2, // 后续执行间隔时间 expireTime / 2, // 时间单位 TimeUnit.MILLISECONDS ); // 保存该线程看门狗，待任务完成后，删除该看门狗。启动看门狗时 reentrant = 1 reentrantInfo = new LockInfo(future, 1); WITCH_DOG_MAP.put(key, reentrantInfo); } /** * 锁被释放，去掉看门狗 * * @param lockKey 锁标识 * @param uuid 线程标识 */ public void unWitch(String lockKey, String uuid) { // 任务完成后，删除对应线程看门狗（重入次数为0时，任务已经完成，可以删除看门狗） LockInfo reentrantInfo = WITCH_DOG_MAP.get(lockKey + uuid); if (reentrantInfo == null || reentrantInfo.future.isCancelled()) { return; } // 按照 锁重入次数进行判断，当重入次数为0时，关闭看门狗 // --reentrantInfo.reentrant; // if (reentrantInfo.reentrant &lt;= 0) { // reentrantInfo.future.cancel(true); // } // 正常情况下，一但执行锁释放，直接关闭看门狗 reentrantInfo.future.cancel(true); } /** * 看门狗相关信息 */ private static class LockInfo { /** * 看门狗任务 */ public ScheduledFuture&lt;?&gt; future; /** * 锁重入次数 */ public int reentrant; public LockInfo(ScheduledFuture&lt;?&gt; future, int reentrant) { this.future = future; this.reentrant = reentrant; } } /** * 执行锁续期的任务 */ public static class LockAsync implements Runnable { /** * redis锁类 */ private final RedisLock redisLock; /** * 锁标识 */ private final String lockKey; /** * 线程标识 */ private final String uuid; /** * 过期时间 */ private final long expireTime; public LockAsync(RedisLock redisLock, String lockKey, String uuid, long expireTime) { this.redisLock = redisLock; this.lockKey = lockKey; this.uuid = uuid; this.expireTime = expireTime; } @Override public void run() { // 锁续期 this.redisLock.renewal(this.lockKey, this.uuid, this.expireTime); } }} 到这里，Java 实现 redis 分布式锁已经完成。 4. 测试案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;@Servicepublic class DemoService { @Resource private RedisLock redisLock; private final static String LOCK_KEY_DEMO = &quot;LOCK_KEY&quot;; private static final ThreadPoolExecutor POOL_EXECUTOR = new ThreadPoolExecutor( 10, 100, 30, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;() ); /** * 测试 */ public void demo() { Runnable runnable = () -&gt; { // 获取锁 long start = System.currentTimeMillis(); String threadKey = RedisLock.generationUuid(); boolean lock = false; try { lock = getLock(threadKey); } catch (InterruptedException e) { throw new RuntimeException(e); } if (!lock) { return; } // 模拟任务执行 2s try { Thread.sleep(2000L); } catch (InterruptedException e) { throw new RuntimeException(e); } // 释放锁 boolean unLock = false; try { unLock = releaseLock(threadKey); } catch (InterruptedException e) { throw new RuntimeException(e); } }; // 模拟多个线程竞争锁 for (int i = 0; i &lt; 5; i++) { POOL_EXECUTOR.execute(runnable); } } /** * 轮询的获取锁，直到获取到锁为止 */ private boolean getLock(String threadKey) throws InterruptedException { // 锁过期时间 1s boolean lock = redisLock.lock(LOCK_KEY_DEMO, threadKey, 1000L); if (!lock) { Thread.sleep(100); // 避免迭代过多，栈溢出 return getLock(threadKey); } return true; } /** * 释放锁 */ private boolean releaseLock(String threadKey) throws InterruptedException { boolean unlock = redisLock.unlock(LOCK_KEY_DEMO, threadKey); if (!unlock) { Thread.sleep(100); // 避免迭代过多，栈溢出 return releaseLock(threadKey); } return true; }} 执行demo()方法，结果如下： 12345678910111213141516171819202122232425262728线程：7d87528f-8da9-40f5-a32b-7d3cc10fbb17，获取锁：LOCK_KEY，过期时间：1000线程：7d87528f-8da9-40f5-a32b-7d3cc10fbb17，持有锁：LOCK_KEY，进行续期：1000线程：7d87528f-8da9-40f5-a32b-7d3cc10fbb17，持有锁：LOCK_KEY，进行续期：1000线程：7d87528f-8da9-40f5-a32b-7d3cc10fbb17，持有锁：LOCK_KEY，进行续期：1000线程：7d87528f-8da9-40f5-a32b-7d3cc10fbb17，持有锁：LOCK_KEY，进行续期：1000线程：7d87528f-8da9-40f5-a32b-7d3cc10fbb17，释放锁：LOCK_KEY线程：63a22f14-d504-4098-82dc-cd893e87acac，获取锁：LOCK_KEY，过期时间：1000线程：63a22f14-d504-4098-82dc-cd893e87acac，持有锁：LOCK_KEY，进行续期：1000线程：63a22f14-d504-4098-82dc-cd893e87acac，持有锁：LOCK_KEY，进行续期：1000线程：63a22f14-d504-4098-82dc-cd893e87acac，持有锁：LOCK_KEY，进行续期：1000线程：63a22f14-d504-4098-82dc-cd893e87acac，释放锁：LOCK_KEY线程：39bb17d2-cd09-4336-9c6a-219484fc709f，获取锁：LOCK_KEY，过期时间：1000线程：39bb17d2-cd09-4336-9c6a-219484fc709f，持有锁：LOCK_KEY，进行续期：1000线程：39bb17d2-cd09-4336-9c6a-219484fc709f，持有锁：LOCK_KEY，进行续期：1000线程：39bb17d2-cd09-4336-9c6a-219484fc709f，持有锁：LOCK_KEY，进行续期：1000线程：39bb17d2-cd09-4336-9c6a-219484fc709f，持有锁：LOCK_KEY，进行续期：1000线程：39bb17d2-cd09-4336-9c6a-219484fc709f，释放锁：LOCK_KEY线程：fb209186-18f8-490c-ae5f-c1939b77d3a5，获取锁：LOCK_KEY，过期时间：1000线程：fb209186-18f8-490c-ae5f-c1939b77d3a5，持有锁：LOCK_KEY，进行续期：1000线程：fb209186-18f8-490c-ae5f-c1939b77d3a5，持有锁：LOCK_KEY，进行续期：1000线程：fb209186-18f8-490c-ae5f-c1939b77d3a5，持有锁：LOCK_KEY，进行续期：1000线程：fb209186-18f8-490c-ae5f-c1939b77d3a5，持有锁：LOCK_KEY，进行续期：1000线程：fb209186-18f8-490c-ae5f-c1939b77d3a5，释放锁：LOCK_KEY线程：8370aba2-2d3c-4852-a8a0-17e6dfbb76cc，获取锁：LOCK_KEY，过期时间：1000线程：8370aba2-2d3c-4852-a8a0-17e6dfbb76cc，持有锁：LOCK_KEY，进行续期：1000线程：8370aba2-2d3c-4852-a8a0-17e6dfbb76cc，持有锁：LOCK_KEY，进行续期：1000线程：8370aba2-2d3c-4852-a8a0-17e6dfbb76cc，持有锁：LOCK_KEY，进行续期：1000线程：8370aba2-2d3c-4852-a8a0-17e6dfbb76cc，释放锁：LOCK_KEY","link":"/posts/6ccd.html"},{"title":"Java并发编程实战：第5章 构建块","text":"1. 同步容器1.1 同步容器 在Java的集合容器框架中，主要有四大类别：List、Set、Queue、Map。 其中List、Set、Queue接口分别继承了Collection接口，Map本身是一个接口。 同步容器主要包括2类 Vector、Stack 12Vector实现了List接口，Vector实际上就是一个数组，和ArrayList类似，但是它进行了同步措施。Stack也是一个同步容器，它的方法也用synchronized进行了同步，它实际上是继承于Vector类。 HashTable 1HashTable实现了Map接口，它和HashMap很相似，但是HashTable进行了同步处理，而HashMap没有。 1.2 同步容器中出现的问题同步容器都是线程安全的。但是对于复合操作，可能需要使用额外的客户端加锁进行保护。 通常对容器的复合操作包括： 迭代 导航(根据一定的顺序寻找下一个元素) 条件运算(缺少即加入……) 操作 Vector 的复合操作可能导致混乱结果： 12345678910111213141516import java.util.Vector;/** * Created by osys on 2022/08/28 21:48. */public class UnsafeVectorHelpers { public static Object getLast(Vector list) { int lastIndex = list.size() - 1; return list.get(lastIndex); } public static void deleteLast(Vector list) { int lastIndex = list.size() - 1; list.remove(lastIndex); }} 对于 list.get()、list.remove()和list.size() 其本身是线程安全的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 返回此 Vector 中指定位置的元素。 * * @param index 要返回的元素的索引 * @return 指定索引处的对象 * @throws ArrayIndexOutOfBoundsException 如果索引超出范围 * ({@code index &lt; 0 || index &gt;= size()}) * @从 1.2 开始 */public synchronized E get(int index) { if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);}/** * 移除此 Vector 中指定位置的元素。 * 将任何后续元素向左移动（从它们的元素中减去一个 * 指数）。返回从 Vector 中删除的元素。 * * @throws ArrayIndexOutOfBoundsException 如果索引超出范围 * ({@code index &lt; 0 || index &gt;= size()}) * @param index 要删除的元素的索引 * @return 被移除的元素 * @从 1.2 开始 */public synchronized E remove(int index) { modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue;}/** * 返回此向量中的组件数。 * * @return 此向量中的组件数 */public synchronized int size() { return elementCount;} 但是对于 getLast() 和 deleteLast() 则不然。 1234567891. 假如两个线程分别调用 getLast() 和 deleteLast() 方法2. 它们先后获取到的 lastIndex 都是 103. 调用 deleteLast() 的线程先按照 lastIndex=10 删除了 Vector 的最后一个元素4. 另一个调用 getLast() 的线程此时按照 lastIndex=10 获取 Vector 的一个元素(元素已经被删除了)5. 抛出异常：ArrayIndexOutOfBoundsException(index) 使用客户端加锁，对 Vector 进行复合操作： 123456789101112131415161718192021222324252627import java.util.Vector;/** * Created by osys on 2022/08/28 21:48. */public class SafeVectorHelpers { private final Vector list; public SafeVectorHelpers(Vector list) { this.list = list; } public Object getLast() { synchronized (list) { int lastIndex = list.size() - 1; return list.get(lastIndex); } } public void deleteLast() { synchronized (list) { int lastIndex = list.size() - 1; list.remove(lastIndex); } }} 迭代中可能抛出 ArrayIndexOutOfBoundsException： 123for (int i=0; i&lt;vector.size(); i++) { doSomething(vector.get(i));} 某个线程在操作 vector 的同时，并不能阻止别的线程对其进行操作，假如在迭代的过程中，其它线程操作删除了 vector 里面的一个元素，那么就会抛出 ArrayIndexOutOfBoundsException 使用客户端加锁进行迭代： 12345synchronized (vector) { for (int i=0; i&lt;vector.size(); i++) { doSomething(vector.get(i)); }} 这样会削弱并发性。在迭代的时候，其它线程并不能访问 vector 1.3 迭代器和 ConcurrentModificationException对 Collection 进行迭代的标准方式是使用 Iterator。在迭代过程中，对 Collection 进行了修改操作，会导致抛出 ConcurrentModificationException 异常。 12345List&lt;Object&gt; widgetList = Collections.synchronizedList(new ArrayList&lt;&gt;());// 可能地出 ConcurrentModificationExceptionfor (Object obj : widgetList) { doSomething(obj);} 上面说到 客户端加锁进行迭代 会影响并发性能。 在迭代期间，对容器加锁的一个替代办法是复制容器。 因为复制是线程限制的，没有其他的线程能够在迭代期间对其进行修改，这样消除了ConcurrentModificationException 发生的可能性。（**容器仍然需要在复制期间对自己加锁**）。 复制容器会有明显的性能开销：这样做是好是坏取决于许多因素，包括容器的大小、每一个元素的工作量、迭代操作相对于容器其他操作的频率，以及响应性和吞吐量的 需求。 1.4 隐藏迭代器迭代器加锁和复制容器可以防止迭代器抛出ConcurrentModificationException异常。所有对共享容器进行迭代的地方都需要此操作。 在某些情况下，迭代器是隐藏起来的。如： 123456789101112131415161718192021222324252627import java.util.HashSet;import java.util.Random;import java.util.Set;/** * Created by osys on 2022/08/28 21:48. */public class HiddenIterator { private final Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); public synchronized void add(Integer i) { set.add(i); } public synchronized void remove(Integer i) { set.remove(i); } public void addTenThings() { Random random = new Random(); for (int i=0; i &lt; 10 ; i++) { add(random.nextInt()); } System.out.println(&quot;DEBUG: 添加了十个元素 &quot; + set); }} 在如下代码中将执行迭代操作： 1System.out.println(&quot;DEBUG: 添加了十个元素 &quot; + set); 编译器将字符串的连接操作转换为StringBuilder.append(Object)，而这个方法又会调用容器的AbstractCollection.toString()方法： 12345678910111213141516171819202122232425/** * 返回此集合的字符串表示形式。字符串 * 表示由集合中的元素列表组成 * 它们由其迭代器返回的顺序，括在方括号中 * (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;)。相邻元素由字符分隔 * &lt;tt&gt;&quot;、&quot;&lt;/tt&gt;（逗号和空格）。元素被转换为字符串 * 通过 {@link String#valueOf(Object)}。 * * @return 此集合的字符串表示形式 */public String toString() { Iterator&lt;E&gt; it = iterator(); if (! it.hasNext()) return &quot;[]&quot;; StringBuilder sb = new StringBuilder(); sb.append('['); for (;;) { E e = it.next(); sb.append(e == this ? &quot;(this Collection)&quot; : e); if (! it.hasNext()) return sb.append(']').toString(); sb.append(',').append(' '); }} addTenThings()方法可能会抛出ConcurrentModificationException，因为在生成调试消息的过程中，AbstractCollection.toString()对容器进行迭代。 2. 并发容器2.1 并发容器Java5.0开始针对多线程并发访问设计，提供了并发性能较好的并发容器，引入了java.util.concurrent包。主要解决了两个问题： 根据具体场景进行设计，尽量避免synchronized，提供并发性。 定义了一些并发安全的复合操作，并且保证并发环境下的迭代操作不会出错。 2.2 ConcurrentHashMap ConcurrentHashMap为了提高本身的并发能力，在内部采用了一个叫做Segment的结构，一个Segment其实就是一个类HashTable的结构，Segment内部维护了一个链表数组 ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到**元素所在链表的头部** 该结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment ConcurrentHashMap让锁的粒度更精细一些，并发性能更好。 构造方法如下： 12345678910111213/** * initialCapacity --- 初始容量。给定指定的负载因子，实现执行内部大小调整以适应这么多元素。 * loadFactor -------– 用于建立初始表大小的负载因子（表密度） * concurrencyLevel -– 估计的并发更新线程数。实现可以使用这个值作为大小提示。 * m –---------------- Map&lt;K, V&gt; */public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {}public ConcurrentHashMap(int initialCapacity, float loadFactor) {}public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) {}public ConcurrentHashMap() {} 2.3 Map附加的原子操作因为 ConcurrentHashMap 不能够在独占访问中被加锁，我们不能使用客户端加锁来创建新的原子操作。 不过一些常见的复合操作，比如缺少即加入，相等便移除和相等便替换，都已被实现为原子操作。 并且这些操作已在 ConcurrentMap 接口中声明，如下所示： 12345678910111213public interface ConcurrentMap&lt;K,V&gt; extends Map&lt;K, V&gt; { // 只有当没有找到匹配K的值时才插入 V putIfAbsent (K key, V value); // 只有当K与V匹配时才移除 boolean remove (K key, V value); // 只有当K与 oldValue 匹配时才取代 boolean replace (K key, V oldvalue, V newValue); // 只有当K匹配某值时才取代 V replace(K key, V newValue);} 2.4 CopyOnWrite 容器CopyOnWrite 通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。 优点： CopyOnWrite容器 是一种读写分离的思想，读和写不同的容器。 这种读写分离的思想，对于并发的读更友好。 不足： CopyOnWrite容器 写时复制机制，导致在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象。 如果这些对象占用的内存比较大，那么这个时候很有可能造成频繁的Yong GC和Full GC CopyOnWrite容器 只能保证数据的最终一致性，不能保证数据的实时一致性。 3. 阻塞队列和生产者-消费者模式3.1 阻塞队列和生产者-消费者模式阻塞队列 阻寨队列(Blocking queue)提供了可阻塞的 put 和 take 方法 如果 Queue 己经满了，put 方法会被阻塞，直到有空间可用 如果 Queue是空的，那么 take 方法会被阻塞，直到有元素可用 Queue 的长度可以有限，也可以无限，无限的 Queue 永远不会充满，所以它的 put 方法永远不会阻塞 例如：A洗盘子，并把洗好的盘子放在盘子架上，B从架子上得到盘子，并把它烘干。 123451. 在这个场景中，盘子架充当了阻寨队列2. 如果架子上没有盘子，消费者会一直等待，直到有盘子需要烘干3. 如果架子被放满了，生产者会停止清洗直到架子上拥有新空间每一个工人只与盘子架产生互动。他们不需要知道究竟存在多少生产者和消费者，或者谁生产了某个给定工作条目。 3.2 常见的阻塞队列123456789public class ArrayBlockingQueue&lt;E&gt; {} // 基于数组的有界阻塞队列public class LinkedBlockingQueue&lt;E&gt; {} // 基于链表的有界阻塞队列public class PriorityBlockingQueue&lt;E&gt; {} // 优先级排序的无界阻塞队列。元素出队列的顺序按照优先级排序public class DelayQueue&lt;E extends Delayed&gt;{} // 基于优先级队列的无界阻塞队列。队列中的元素只有到达规定的延时才能从队列中取出。public class SynchronousQueue&lt;E&gt; {} // 阻塞队列，其中每个插入操作都必须等待另一个线程的相应删除操作。 3.3 阻塞队列常见的方法123456789add(E e) 将元素e插入到队列末尾，成功返回 true；失败 抛出异常remove() 移除队首元素，成功返回 true；失败 抛出异常poll() 移除并获取队首元素，若成功 返回队首元素；否则 返回nullpeek() 获取队首元素，若成功 返回队首元素；否则 返回nulltake() 获取并移除队首元素，如果队列为空则阻塞直到队列中有元素put() 向队尾添加元素，如果队列满则等待直到可以添加offer(E e) 向队尾添加元素，成功返回true；失败返回false 3.4 连续的线程限制一个线程约束的对象完全由单一线程所有，但是所有权可以通过安全的发布被转移 安全发布确保了对象状态对新的所有者是可见的，并且因为原始的所有者不会再触及它，这样使得对象完全受限于新线程中 对于可变对象，生产者-消费者设计和阻塞队列一起，为生产者和消费者之间移交对象所有权提供了连续的线程限制 桌面搜索应用程序中的生产者和消费者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import java.io.File;import java.io.FileFilter;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;/** * 文件搜索应用程序中的生产者和消费者 */public class ProducerConsumer { /** * 文件检索工具类（生产者） * 将给定的文件夹，获取里面的文件，添加到队列 * 将给定的文件，添加到队列 */ static class FileCrawler implements Runnable { /** 文件阻塞队列 */ private final BlockingQueue&lt;File&gt; fileQueue; /** 文件过滤器 */ private final FileFilter fileFilter; /** 文件 */ private final File root; public FileCrawler(BlockingQueue&lt;File&gt; fileQueue, final FileFilter fileFilter, File root) { this.fileQueue = fileQueue; this.root = root; this.fileFilter = new FileFilter() { /** * 测试指定的抽象路径名是否应包含在路径名列表中 * @param pathname 路径名 * @return true/false */ @Override public boolean accept(File pathname) { return pathname.isDirectory() || fileFilter.accept(pathname); } }; } /** * 文件是否已经加入到阻塞队列 * @param file 文件 * @return false 表示已经加入 */ private boolean alreadyIndexed(File file) { return false; } @Override public void run() { try { crawl(root); } catch (InterruptedException e) { // 中断线程 Thread.currentThread().interrupt(); } } /** * 文件检索(将文件添加到队列，文件夹忽略掉) * @param root 要被检索的文件 */ private void crawl(File root) throws InterruptedException { // 获取一个抽象路径名数组(该路径对应可能是文件，也可能是文件夹) File[] entries = root.listFiles(fileFilter); if (entries != null) { for (File entry : entries) { if (entry.isDirectory()) { // 如果是路径，继续检索 crawl(entry); } else if (!alreadyIndexed(entry)) { // 文件未加入队列。将文件加入阻塞队列 fileQueue.put(entry); } } } } } /** * 消费者，消费文件 */ static class Indexer implements Runnable { /** 文件阻塞队列 */ private final BlockingQueue&lt;File&gt; queue; public Indexer(BlockingQueue&lt;File&gt; queue) { this.queue = queue; } @Override public void run() { try { while (true) { indexFile(queue.take()); } } catch (InterruptedException e) { // 中断线程 Thread.currentThread().interrupt(); } } public void indexFile(File file) { // 消费文件 }; } /** 队列大小 */ private static final int BOUND = 10; /** Java 虚拟机可用的处理器数量 */ private static final int N_CONSUMERS = Runtime.getRuntime().availableProcessors(); /** * 开始桌面搜索 * @param roots 文件数组 */ public static void startIndexing(File[] roots) { BlockingQueue&lt;File&gt; queue = new LinkedBlockingQueue&lt;File&gt;(BOUND); FileFilter filter = new FileFilter() { /** * 测试指定的抽象路径名是否应包含在路径名列表中 * @param pathname 路径名 * @return true/false */ @Override public boolean accept(File pathname) { return true; } }; // 检索文件，添加到阻塞队列中 for (File root : roots) { new Thread(new FileCrawler(queue, filter, root)).start(); } // 消费者，消费文件 for (int i = 0; i &lt; N_CONSUMERS; i++) { new Thread(new Indexer(queue)).start(); } }} 3.5 双端队列Deque 和 BlockingDeque，它们分别扩展了 Queue 和 BlockingQueve。 Deque 是一个双端队列，允许高效地在头和尾分别进行插入和移除 实现它们的分别有 ArrayDeque 和 LinkedB1ockingDeaue。 3.6 窃取工作 双端队列使它们自身与一种叫做窃取工作的模式相关联。 在消费者生产者设计中，所有的消费者只共享一个工作队列。 在窃取工作的设计中，每一个消费者都有一个自己的双端队列。 如果一个消费者完成了自己双端队列中的全部工作，它可以偷取其他消费者的双端队列中的末尾任务。 因为工作者线程并不会竞争一个共享的任务队列，所以窃取工作模式比传统的生产者-消费者设计有更佳的可伸缩性。 大多数时候它们访问自己的双端队列，减少竞争。当一个工作者必须要访问另一个队列时，它会从尾部截取，而不是从头部，从而进一步降低对双端队列的争夺。 4. 阻塞和中断的方法线程会因为几种原因被阻塞或暂停： 等待IO操作结束 等待获得一个锁 等待从Thread.sleep中唤醒 或者是等待另一个线程的计算结果 当一个线程阻塞时，他通常被挂起，并且设置成线程阻塞的某个状态（BLOCKED -- 阻塞、WAITING -- 等待、TIMED_WAITING -- 等待），等到外部事件的发生触发将线程置回（RUNNABLE）状态重新获得调度的机会。 恢复中断状态，避免掩盖中断： 12345678910111213141516171819202122232425import java.util.concurrent.BlockingQueue;/** * Created by osys on 2022/08/28 21:48. */public class TaskRunnable implements Runnable { BlockingQueue&lt;Task&gt; queue; @Override public void run() { try { processTask(queue.take()); } catch (InterruptedException e) { // 中断线程 Thread.currentThread().interrupt(); } } void processTask(Task task) { // 处理任务 } interface Task { }} 5. Synchronizer5.1 SynchronizerSynchronizer 是一个对象，它根据本身的状态调节线程的控制流。 Synchronizer对象包含：BlockingQueue（阻塞队列），Semaphore（信号量）、Barrier（关卡）、闭锁（Latch）。 5.2 阻塞队列(BlockingQueue) 阻塞队列在容器类中，不仅作为对象的容器，而且能够协调生产者线程和消费者线程之间的控制流。 因为 take 和 put 会保持阻止状态直到队列进入了期望的状态（队列元素不为空，队列还能存放元素）。 5.3 闭锁(Latch)闭锁是一种 Synchronizer，它可以延迟线程的进度直到线程到达终止状态。 闭锁工作起来就像大门：直到闭锁达到终点状态之前，门一直是关闭的，没有线程能够通过，在终点状态到来的吋候，门开了，允许所有线程都通过。 一但闭锁到达了终点状态，它就不能够再改变状态了，所以它会永远保持敞开状态。 闭锁可以用来确保特定活动直到其他的活动完成后才发生，比如： 确保一个计算不会执行，直到它需要的资源被初始化。 确保一个服务不会开始，直到它依赖的其他服务都已经开始。 等待，直到活动的所有部分都为继续处理作好充分准备，比如在多玩家的游戏中的所有玩家是否都准备就绪。这样的闭锁会在所有玩家准备就绪时，达到终点状态。 FutureTask Futurerask 可以作为闭锁。 FutureTask 实现了 Future 接口和 Runnable 接口，它等价于一个携带结果的 Runnable，并且有三个状态：等待、运行、完成 完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。一旦 FutureTask 进入完成状态，它会永远停止在这个状态上。 在时序测试中，使用 CountDownLatch 来启动和停止线程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.concurrent.CountDownLatch;/** * 在时序测试中，使用 CountDownLatch 来启动和停止线程 * * CountDownLatch.class ---- 利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。 */public class TestHarness { /** * 使用 CountDownLatch 来启动和停止线程 * @param nThreads 要启动的线程数 * @param task 线程任务 * @return 线程等待，释放时间 * @throws InterruptedException 当线程等待、休眠或以其他方式被占用，并且线程在活动之前或期间被中断时抛出 */ public long timeTasks(int nThreads, final Runnable task) throws InterruptedException { // 在线程可以通过await()方法之前，计数值为1，需调用countDown()方法的次数为1次 final CountDownLatch startGate = new CountDownLatch(1); // 在线程可以通过await()方法之前，计数值为 nThreads，需调用countDown()方法的次数为 nThreads 次 final CountDownLatch endGate = new CountDownLatch(nThreads); // 通过await()方法需满足：锁计数器为0、线程被中断、或者超过指定的等待时间 // 每调用countDown()方法，计数器减1 for (int i = 0; i &lt; nThreads; i++) { Thread aThread = new Thread() { @Override public void run() { try { // 线程等待 startGate.await(); try { // 启动线程 task.run(); } finally { // 减少锁存器的计数，如果计数达到零，则释放所有等待线程 endGate.countDown(); } } catch (InterruptedException ignored) {} } }; aThread.start(); } long start = System.nanoTime(); // startGate 锁计数器(原本定义为1)，现在调用 countDown() 方法，减去1 // 此时，startGate 的锁计数器为0，可以通过 await() 方法了 // 因此就可以到达 task.run() startGate.countDown(); // endGate 锁计数器原本定义为nThreads，也就是线程个数。 // 程序未出现异常情况，需要调用 countDown() 方法 nThreads 次 // endGate.countDown() 方法在每个线程的 finally {...} 中 // 因此需要 nThreads 个线程都完成，才能使得 锁计数器=0，这个时候才能通过 endGate.await() 方法 endGate.await(); long end = System.nanoTime(); return end - start; }} 使用 FutureTask 顶载稍后需要的數据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * 使用 FutureTask 顶载稍后需要的數据 */public class Preloader { /** 加载产品信息 */ ProductInfo loadProductInfo() throws DataLoadException { return null; } /** 创建一个FutureTask ，它将在运行时执行给定的Callable */ private final FutureTask&lt;ProductInfo&gt; future = new FutureTask&lt;&gt;(new Callable&lt;ProductInfo&gt;() { @Override public ProductInfo call() throws DataLoadException { return loadProductInfo(); } }); private final Thread thread = new Thread(future); public void start() { thread.start(); } public ProductInfo get() throws DataLoadException, InterruptedException { try { // 为已完成的任务返回结果或抛出异常（Callable执行结果或异常） return future.get(); } catch (ExecutionException e) { Throwable cause = e.getCause(); if (cause instanceof DataLoadException) { throw (DataLoadException) cause; } else { throw LaunderThrowable.launderThrowable(cause); } } } interface ProductInfo { }}/** 数据加载异常 */class DataLoadException extends Exception { }/** Throwable 强制转换为 RuntimeException */class LaunderThrowable { /** * 将未经检查的 Throwable 抛出。 * * 如果 throwable 是 RuntimeException 则返回 Throwable。 * 如果 throwable 是 Error 则抛出 Error。 * 否者抛出 IllegalStateException。 */ public static RuntimeException launderThrowable(Throwable throwable) { if (throwable instanceof RuntimeException) { return (RuntimeException) throwable; } else if (throwable instanceof Error) { throw (Error) throwable; } else { throw new IllegalStateException(&quot;Not unchecked&quot;, throwable); } }} 5.4 信号量(Semaphore) 计数信号量 用来控制能够同时访问某特定资源的活动的数量，或者同时执行某一给定操作的数量。 计数信号量可以用来实现资源池或者给定一个容器限定边界。 Semaphore的主要方法： 1234void acquire() {} // 从这个信号量获取一个许可，如果没有许可，线程将被阻塞或者线程被中断void release() {} // 释放一个许可，将其返回给信号量int availablePermits() {} // 返回此信号量中当前可用的许可数boolean hasQueuedThreads() {} // 查询是否有线程正在等待获取 Semaphore中管理着一组虚拟的许可（permit)，许可的初始数量可通过构造函数来指定。 在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。 如果没有许可，那么 acquire() 方法将阻塞直到有许可（或者直到被中断、或者操作超时）。 计算信号量的一种简化形式是二元信号量，即初始值为1的Semaphore。 二元信号量可以用做互斥体(mutex)，并具备不可重入的加锁语义。 使用信号量来约束容器： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Collections;import java.util.HashSet;import java.util.Set;import java.util.concurrent.Semaphore;/** * 使用信号量来约束容器 */public class BoundedHashSet &lt;T&gt; { private final Set&lt;T&gt; set; /** 信号量 */ private final Semaphore semaphore; public BoundedHashSet(int bound) { this.set = Collections.synchronizedSet(new HashSet&lt;&gt;()); semaphore = new Semaphore(bound); } public boolean add(T obj) throws InterruptedException { // 从这个信号量获取一个许可 semaphore.acquire(); boolean wasAdded = false; try { wasAdded = set.add(obj); return wasAdded; } finally { if (!wasAdded) { // 释放许可 semaphore.release(); } } } public boolean remove(Object obj) { boolean wasRemoved = set.remove(obj); if (wasRemoved) { // 释放许可 semaphore.release(); } return wasRemoved; }} 5.5 关卡(Barrier)关卡类似于闭锁，它们都能够阻塞一组线程，直到某些事件发生。 关卡与闭锁关键的不同在于，所有线程必须同时到达关卡点，才能继续处理。闭锁等待的是事件；关卡等待的是其他线程。 CyclicBarrier CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（关卡点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。 当线程到达关卡点时，调用await()方法，线程会被阻塞，直到所有的线程都到达关卡点。 如果所有的线程都到达了关卡点，关卡就会被突破，这样所有的线程都被释放，关卡会重置以备下一次使用。 如果对await()的方法调用超时，或者阻塞中的线程被中断，那么关卡就被认为是失败的，所有调用await()未完成的线程，都通过BrokenBarrierException终止。 CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。 在一个细胞的自动系统中用 CyclicBarrier 协调计算： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;/** * 在一个细胞的自动系统中用 CyclicBarrier 协调计算 */public class CellularAutomata { /** 细胞 */ private final Board mainBoard; /** 关卡 */ private final CyclicBarrier barrier; /** 工作蛋白 */ private final Worker[] workers; public CellularAutomata(Board board) { // 细胞 this.mainBoard = board; // Java 虚拟机可用的处理器数量 int count = Runtime.getRuntime().availableProcessors(); // 关卡 this.barrier = new CyclicBarrier(count, new Runnable() { @Override public void run() { // 细胞提交新 value mainBoard.commitNewValues(); } }); // 工作蛋白 this.workers = new Worker[count]; for (int i = 0; i &lt; count; i++) { // 设置子细胞 workers[i] = new Worker(mainBoard.getSubBoard(count, i)); } } private class Worker implements Runnable { /** 细胞 */ private final Board board; public Worker(Board board) { this.board = board; } @Override public void run() { // 细胞还没转换好 while (!board.hasConverged()) { for (int x = 0; x &lt; board.getMaxX(); x++) { for (int y = 0; y &lt; board.getMaxY(); y++) { // 设置新的 x，y 值 board.setNewValue(x, y, computeValue(x, y)); } } try { // 关卡（细胞所有的位置都转换好了，才可继续）---- 所有线程都运行到这里才可以继续 barrier.await(); } catch (InterruptedException | BrokenBarrierException ex) { return; } } } private int computeValue(int x, int y) { // 在 (x,y) 里计算新 value return 0; } } public void start() { // 启动线程 for (Worker worker : workers) { new Thread(worker).start(); } // 等待细胞转换 mainBoard.waitForConvergence(); } /** * 细胞 */ interface Board { /** * x 坐标 * @return x */ int getMaxX(); /** * y 坐标 * @return y */ int getMaxY(); /** * x，y 对应的 value * @param x x * @param y y * @return value */ int getValue(int x, int y); /** * x，y 设置新的 value * @param x x * @param y y * @param value value * @return 新 value */ int setNewValue(int x, int y, int value); /** 提交新 value */ void commitNewValues(); /** * 是否转换好 * @return true/false */ boolean hasConverged(); /** * 等待转换 */ void waitForConvergence(); /** * 获取子细胞 * @param numPartitions 分区 * @param index 所处分区 * @return 子细胞 */ Board getSubBoard(int numPartitions, int index); }} 6. 建立高效、可伸缩的高速缓存6.1 为计算结果建立高效、可伸缩的高速缓存几乎所有的服务器应用都会使用某种形式的缓存。 重用之前的计算结果能降低延迟，提高吞吐量，但却要消耗更多内存。 看上去简单的缓存，可能会将性能瓶颈转变成伸缩性瓶颈，即使缓存是用来提高单线程性能的。 6.2 使用 HashMap 和同步 来初始化缓存12345678910111213141516171819202122232425262728293031323334353637383940414243import net.jcip.annotations.GuardedBy;import java.math.BigInteger;import java.util.HashMap;import java.util.Map;/** * 尝试使用 HashMap 和同步来初始化缓存 */public class Memoizer1&lt;A, V&gt; implements Computable&lt;A, V&gt; { @GuardedBy(&quot;this&quot;) private final Map&lt;A, V&gt; cache = new HashMap&lt;&gt;(); private final Computable&lt;A, V&gt; computer; public Memoizer1(Computable&lt;A, V&gt; computer) { this.computer = computer; } @Override public synchronized V compute(A arg) throws InterruptedException { // 从缓存中获取，查看缓存中是否存在该值 V result = cache.get(arg); if (result == null) { // 缓存中不存在该值，计算并返回 result = computer.compute(arg); // 将就算返回的值，存入 map cache.put(arg, result); } return result; }}interface Computable &lt;A, V&gt; { V compute(A arg) throws InterruptedException;}class ExpensiveFunction implements Computable&lt;String, BigInteger&gt; { @Override public BigInteger compute(String arg) { return new BigInteger(arg); }} Memorizer1 将 Computable 实现类的计算结果缓存在Map&lt;A, V&gt; cache。 因为HashMap不是线程安全的，为了保证并发性，Memorizer1用了个很保守的方法，对整个compute方法进行同步。这导致了Memorizer1会有很明显的可伸缩性问题。 当有很多线程调用compute方法，就会出现类似下图的情况（并发性能弱）： 6.3 用 ConcurrentHashMap 来初始化缓存123456789101112131415161718192021222324252627import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * 用 ConcurrentHashMap 来初始化缓存 */public class Memoizer2&lt;A, V&gt; implements Computable&lt;A, V&gt; { private final Map&lt;A, V&gt; cache = new ConcurrentHashMap&lt;&gt;(); private final Computable&lt;A, V&gt; computer; public Memoizer2(Computable&lt;A, V&gt; computer) { this.computer = computer; } @Override public V compute(A arg) throws InterruptedException { // 将就算返回的值，存入 map V result = cache.get(arg); if (result == null) { // 缓存中不存在该值，计算并返回 result = computer.compute(arg); // 将就算返回的值，存入 map cache.put(arg, result); } return result; }} ConcurrentHashMap为了提高本身的并发能力，在内部采用了一个叫做Segment的结构，一个Segment其实就是一个类HashTable的结构，Segment内部维护了一个链表数组。该结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment。ConcurrentHashMap让锁的粒度更精细一些，并发性能更好。 当两个线程同时计算同一个值，它们并不知道有其它线程在做同一的事，存在着资源被浪费的可能。如下图： 6.4 使用 ConcurrentHashMap＋FutureTask 来初始化缓存 闭锁是可以延迟线程的进度直到线程到达终止状态。Futurerask 可以作为闭锁。 闭锁工作起来就像大门：直到闭锁达到终点状态之前，门一直是关闭的，没有线程能够通过，在终点状态到来的吋候，门开了，允许所有线程都通过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Map;import java.util.concurrent.Callable;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ExecutionException;import java.util.concurrent.Future;import java.util.concurrent.FutureTask;/** * 用 FutureTask 记录包装器来初始化缓存 */public class Memoizer3&lt;A, V&gt; implements Computable&lt;A, V&gt; { private final Map&lt;A, Future&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private final Computable&lt;A, V&gt; computer; public Memoizer3(Computable&lt;A, V&gt; computer) { this.computer = computer; } @Override public V compute(final A arg) throws InterruptedException { // 从缓存中获取，查看缓存中是否存在该值 Future&lt;V&gt; cacheFuture = cache.get(arg); if (cacheFuture == null) { Callable&lt;V&gt; eval = new Callable&lt;V&gt;() { @Override public V call() throws InterruptedException { // 缓存中不存在该值，计算并返回 return computer.compute(arg); } }; // 将Future&lt;V&gt;，存入 map FutureTask&lt;V&gt; task = new FutureTask&lt;&gt;(eval); cacheFuture = task; cache.put(arg, task); // 执行 FutureTask，计算结果 task.run(); } try { // 获取结果并返回 return cacheFuture.get(); } catch (ExecutionException e) { throw LaunderThrowable.launderThrowable(e.getCause()); } }} Memorizer3 缓存的不是计算的结果，而是进行运算的 Future&lt;V&gt; cacheFuture。 因此首先检查有没有执行该任务的FutureTask 如果有执行该任务的FutureTask，则直接获得FutureTask 1cacheFuture != null 假如计算已经完成，FutureTask.get()方法可以立刻获得结果 1return cacheFuture.get(); 假如计算未完成，后进入的线程阻塞直到get()返回结果； 如果没有执行该任务的FutureTask，则创建一个FutureTask进行运算，后续进了的同样的运算可以直接拿到结果或者等待运算完成获得结果。 12if (cacheFuture == null) { ... }return cacheFuture.get(); 此程序仍然存在一个问题， 当A线程判断没有对应的cache.get(arg);缓存为空（即cache.get(arg)==null） A线程创建FutureTask，还没进行cache.put(arg, task);操作 1FutureTask&lt;V&gt; task = new FutureTask&lt;&gt;(eval); 这个时候，B线程判断缓存也是为空的（即cache.get(arg)==null），因为A线程还没进行cache.put(arg, task);操作 B线程创建的FutureTask，就会会把A创建的FutureTask覆盖掉。 如下图： 6.5 ConcurrentHashMap + FutureTask + Map原子操作 来初始化缓存12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.concurrent.Callable;import java.util.concurrent.CancellationException;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;import java.util.concurrent.ExecutionException;import java.util.concurrent.Future;import java.util.concurrent.FutureTask;/** * ConcurrentHashMap + FutureTask + Map原子操作 来初始化缓存 */public class Memoizer&lt;A, V&gt; implements Computable&lt;A, V&gt; { private final ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private final Computable&lt;A, V&gt; computer; public Memoizer(Computable&lt;A, V&gt; computer) { this.computer = computer; } @Override public V compute(final A arg) throws InterruptedException { while (true) { // 从缓存中获取，查看缓存中是否存在该值 Future&lt;V&gt; cacheFuture = cache.get(arg); if (cacheFuture == null) { Callable&lt;V&gt; eval = new Callable&lt;V&gt;() { @Override public V call() throws InterruptedException { // 缓存中不存在该值，计算并返回 return computer.compute(arg); } }; // 将就算返回的值，存入 map（如果存在，就将返回值存入map） FutureTask&lt;V&gt; task = new FutureTask&lt;&gt;(eval); cacheFuture = cache.putIfAbsent(arg, task); // 查看是否存在该 FutureTask，如果存在，那么计算结果 if (cacheFuture == null) { cacheFuture = task; task.run(); } } try { // 获取结果并返回 return cacheFuture.get(); } catch (CancellationException e) { cache.remove(arg, cacheFuture); } catch (ExecutionException e) { throw LaunderThrowable.launderThrowable(e.getCause()); } } }} 程序做了两点改进： 将 FutureTask&lt;V&gt; 存入 Map 时，使用 ConcurrentHashMap.putIfAbsent() 方法，使得原本复合的插入操作，原子化 使用了 while (true) { ... } ，当在cacheFuture.get()阻塞线程（即Map中，存在FutureTask&lt;V&gt;，等待结果，所以get()方法阻塞）， 并抛出CancellationException异常，则会再一次申请一个创建FutureTask的机会。","link":"/posts/ff33.html"},{"title":"Java并发编程实战：第6章 任务执行","text":"1. 在线程中执行任务1.1 在线程中执行任务 多数并发程序是围绕任务进行管理的，所谓任务就是抽象、离散的工作单元。 正常情况下，服务器应该兼顾良好的吞吐量和快速的响应性。 在负荷状况下，应该平缓的劣化，不应该快速失败，为了达到这些策略，应该有一个明确的任务执行策略。 1.2 顺序地执行任务顺序化地 Web Server 123456789101112131415161718192021import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * Created by osys on 2022/08/28 21:48. */public class SingleThreadWebServer { public static void main(String[] args) throws IOException { ServerSocket socket = new ServerSocket(80); // 顺序执行，接受连接，处理连接 while (true) { Socket connection = socket.accept(); handleRequest(connection); } } private static void handleRequest(Socket connection) { // 处理逻辑 }} 顺序处理并发性能低，必须等待一个请求结束才能响应下一个请求。其他线程在等待某个请求处理结束时，CPU可能较为空闲，因此导致资源利用率非常低。 1.3 显式的为任务创建线程Web Server为每个请求启动一个新的线程 123456789101112131415161718192021222324252627import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * Created by osys on 2022/08/28 21:48. */public class ThreadPerTaskWebServer { public static void main(String[] args) throws IOException { ServerSocket socket = new ServerSocket(80); // 并发处理请求 while (true) { final Socket connection = socket.accept(); Runnable task = new Runnable() { @Override public void run() { handleRequest(connection); } }; new Thread(task).start(); } } private static void handleRequest(Socket connection) { // 处理逻辑 }} 主循环为每个连接都创建一个新线程以处理请求，而不在主循环的内部处理请求。 结论： 执行任务的负载已经脱离了主线程 并行处理任务，使得可以多个请求同时得到服务 任务处理代码必须是线程安全的，因为有多个任务会并发地调用它。 1.4 无限制创建线程的缺点显式的为任务创建线程实例中，为每个任务都创建一个线程，存在一些实际的缺陷： 线程生命周期的开销。创建和关闭线程都需要借助操作系统，花费大量时间。 资源消耗高。如果可运行的线程数超过可用的处理器数，线程将会空闲。大量空闲线程会占用更多的内存。 稳定性问题。应该限制可创建线程的数目。 通常来说，在一定范围增加创建线程，可以提高系统的吞吐量，一旦超出范围，创建更多线程可能占用过多资源，导致程序出现各种问题。 2. Executor 框架2.1 Executor 框架任务是逻辑上的工作单元，线程是使任务异步执行的机制。 12345678910package java.util.concurrent;public interface Executor { /** * 在将来的某个时间执行给定的命令。该命令可以在新线程、池线程或调用线程中执行，具体取决于执行者实现。 * @param command 可运行的任务 */ void execute(Runnable command);} Executor为任务提交和任务执行提供了解耦的标准方法。 2.2 使用 Executor 实现 Web Server123456789101112131415161718192021222324252627282930313233import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.Executor;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * Created by osys on 2022/08/28 21:48. */public class TaskExecutionWebServer { private static final int THEAD_NUM = 100; private static final Executor EXEC = new ThreadPoolExecutor(THEAD_NUM, THEAD_NUM, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(100)); public static void main(String[] args) throws IOException { ServerSocket socket = new ServerSocket(80); while (true) { final Socket connection = socket.accept(); Runnable task = new Runnable() { @Override public void run() { handleRequest(connection); } }; EXEC.execute(task); } } private static void handleRequest(Socket connection) { // 处理逻辑 }} 通过Executor我们将任务提交和执行进行了解耦，代替了硬编码的创建线程。 2.3 执行策略一个执行策略明确了需要在任务执行过程关注的点： 任务在什么线程执行？ 任务以什么方式执行？ 可以有多少个任务并发执行？ 可以有多少任务进入等待队列？ 如果任务过载，需要放弃任务，怎么办？ 一个任务执行前后，应该做什么？ 执行策略是对资源管理的工具，最佳策略取决于可用的计算资源和你对服务质量的要求。 2.4 线程池 线程池管理工作者线程，帮助我们管理工作线程的创建和销毁，工作队列的处理，可用让我们更加关注任务的编写上。 工作队列：其作用是持有所有等待执行的任务。 使用线程池好处： 重用存在的线程，而不是创建新的线程，这可以在处理多请求时抵消线程创建、消亡产生的开销。 在请求到达时，工作者线程通常已经存在，用于创建线程的等待时间并不会延迟任务的执行，因此提高了响应性。 通过适当地调整线程池的大小，你可以得到足够多的线程以保持处理器忙碌，同时可以还防止过多的线程相互竞争资源，导致应用程序耗尽内存或者失败。 类库Executors提供了我们多种创建线程池的静态方法。 定长线程池 newCachedThreadPool() 1234567891011/** * 创建一个固定长度的线程池 * 每次提交一个任务，就创建一个线程，直达达到线程池最大长度 * 在需要创建线程时，使用提供的ThreadFactory创建新线程 */public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);} 使用的工作队列是new LinkedBlockingQueue()也就是工作队列是无限的，最好设置固定大小。 可缓存线程池 newCachedThreadPool() 12345678910/** * 创建一个可缓存的线程池 * 如果当前线程池的长度超过了处理的需要时，它可以灵活地回收空闲的线程 * 当需求增加时，它可以灵活地添加新的线程，而并不会对池的长度作任何限制 */public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());} 单线程化的 executor newSingleThreadExecutor() 12345678910111213/** * 创建一个单线程化的 executor * 它只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它 * executor 会保证任务，依照任务队列所规定的顺序执行。 --- (FIFO, LIFO,优先级) */public static ExecutorService newSingleThreadExecutor() { return new Executors.FinalizableDelegatedExecutorService( new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;() ) );} 定时的线程池 newScheduledThreadPool() 12345678910111213/** * 创建一个定长的线程池 * 支持定时的，以及周期性的任务执行。 */public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize);}/** * 在需要创建线程时，使用提供的ThreadFactory创建新线程 */public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) { return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);} 2.5 Executor 的生命周期Executor 本身并没有解决生命周期问题，它的子接口 ExecutorService 提供了一些接口用于解决这个问题： shudown() 方法 123456/** * 调用这个方法时，ExecutorService 停止接受任何新的任务 * 且等待已经提交的任务执行完成，当所有已经提交的任务执行完毕后将会关闭ExecutorService * (已经提交的任务会分两类：一类是已经在执行的，另一类是还没有开始执行的) */void shutdown(); shutdownNow() 方法 123456/** * 调这个方法会强制关闭 ExecutorService， * 它将取消所有运行中的任务和在工作队列中等待的任务， * 这个方法返回一个 List 列表，列表中返回的是等待在工作队列中的任务 */List&lt;Runnable&gt; shutdownNow(); isShutdown() 方法 12/** ExecutorService 关闭后返回true，否则返回false */boolean isShutdown(); isTerminated() 方法 12345/** * ExecutorService 关闭后所有任务都已完成，则返回true * 注意：除非先调用 shutdown() 或 shutdowNow()，否则 isTerminated 永远不会为 true */boolean isTerminated(); awaitTermination() 方法 1234567891011/** * 在执行 shutdown() 后，阻塞 ExecutorService 关闭， * 直到所有任务都完成，或者直到 timeout，或者当前线程被中断。 * 以先发生者为准。 * @param timeout 超时时间 * @param unit 超时参数的时间单位。 * @return 如果 ExecutorService 关闭，return true * 如果 timeout，ExecutorService 还未关闭，return false * 当前线程被中断，抛出 InterruptedException 异常 */boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; submit() 方法 1234567891011121314151617/** * 提交一个任务到 Executor 工作队列中，执行该任务，并返回 Future&lt;T&gt; 结果。 * 参为 Runnable 时，执行 Runnable 的 run()方法 * 返回值 Future.get() 的结果为 null。 * 参为 Runnable 和 result 时，执行 Runnable 的 run()方法 * 返回值 Future.get() 的结果为传入的 result。 * 参为 Callable 时，则执行 Callable 的 call() 方法， * 返回值 Future.get() 的结果为 call() 的返回值。 * @param task 两种类型的 task：Callable&lt;T&gt;、Runnable * @param result 返回的结果 * @return 执行后，返回的是 Future&lt;T&gt; 对象 */&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task); invokeAll() 方法 12345678910111213/** * 提交任务集到 ExecutorService，返回所有任务的执行结果。 * 该方法会阻塞，必须等待所有的任务执行完成后统一返回。 * * 如果全部任务在指定的时间内没有完成，则抛出异常。 * @param tasks Collection&lt;? extends Callable&lt;T&gt;&gt; * @param timeout 超时时间 * @param unit 时间单位 * @return 执行后，返回的是 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; 对象 */&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException;&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; invokeAny() 方法 12345/** 提交任务集到 ExecutorService，返回第一个执行完的任务的结果值 */&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException;/** 提交任务集到 ExecutorService，在指定时间内，返回第一个执行完的任务的结果值，否则 Exception */&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; 支持关闭操作的 Web Server 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ExecutorService;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.RejectedExecutionException;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.logging.Level;import java.util.logging.Logger;/** * Created by osys on 2022/08/28 21:48. */public class LifecycleWebServer { private int THREAD_NUM = 10; /** 创建 ExecutorService */ private final ExecutorService exec = new ThreadPoolExecutor(THREAD_NUM, THREAD_NUM, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(100)); public void start() throws IOException { // 创建 socket 连接 ServerSocket socket = new ServerSocket(80); // ExecutorService 未关闭 while (!exec.isShutdown()) { try { // 接受Socket连接 final Socket conn = socket.accept(); // 向 ExecutorService 提交任务 exec.execute(new Runnable() { @Override public void run() { handleRequest(conn); } }); } catch (RejectedExecutionException e) { if (!exec.isShutdown()) { log(&quot;任务提交被拒绝&quot;, e); } } } } public void stop() { exec.shutdown(); } private void log(String msg, Exception e) { Logger.getAnonymousLogger().log(Level.WARNING, msg, e); } /** 处理逻辑 */ void handleRequest(Socket connection) { Request req = readRequest(connection); if (isShutdownRequest(req)) { stop(); } else { dispatchRequest(req); } } interface Request { } private Request readRequest(Socket s) { return null; } private void dispatchRequest(Request r) { } private boolean isShutdownRequest(Request r) { return false; }} 该实例，利用 ExecutorService 提供的生命周期管理方法进行处理 2.6 延迟的、周期性的任务在上面的 线程池 说明中，有描述到：定时的线程池 newScheduledThreadPool() 12345678910111213/** * 创建一个定长的线程池 * 支持定时的，以及周期性的任务执行。 */public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize);}/** * 在需要创建线程时，使用提供的ThreadFactory创建新线程 */public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) { return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);} ScheduledExecutorService 接口继承了 ExecutorService 接口。其接口方法有： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 创建并执行在给定延迟后启用的单次操作。 * command - 要执行的任务 * delay - 从现在开始延迟执行的时间 * unit - 延时参数的时间单位 * * return 表示任务等待完成，并且其的 ScheduledFuture get()方法将返回 null * * Exception * RejectedExecutionException - 如果任务无法安排执行 * NullPointerException - 如果命令为空 */public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit);/** * 创建并执行在给定延迟后启用的ScheduledFuture。 * * callable - 执行的功能 * delay - 从现在开始延迟执行的时间 * unit - 延迟参数的时间单位 * * return 一个可用于提取结果或取消的ScheduledFuture * * Exception * RejectedExecutionException - 如果该任务无法安排执行 * NullPointerException - 如果可调用为空 */public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit);/** * 创建并执行在给定的初始延迟之后，随后以给定的时间段首先启用的周期性动作; * 那就是执行将在 initialDelay 之后开始，然后 initialDelay + period ，然后是initialDelay + (2 * period) ......。 * 如果任务的执行遇到异常，则后续的执行被抑制。 否则，任务将仅通过取消或终止执行人终止。 * 如果任务执行时间比其周期长，则后续执行可能会迟到，但不会同时执行。 * * command - 要执行的任务 * initialDelay - 延迟第一次执行的时间 * period - 连续执行之间的时期 * unit - initialDelay和period参数的时间单位 * * return 一个ScheduledFuture代表待完成的任务，其 get()方法将在取消时抛出异常 * * Exception * RejectedExecutionException - 如果该任务无法安排执行 * NullPointerException - 如果可调用为空 * IllegalArgumentException - 如果周期小于或等于零 */public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);/** * 创建并执行在给定的初始延迟之后，首先启用的定期动作，随后在一个执行的终止和下一个执行的开始之间给定的延迟。 * 如果任务的执行遇到异常，则后续的执行被抑制。 否则，任务将仅通过取消或终止执行人终止。 * * command - 要执行的任务 * initialDelay - 延迟第一次执行的时间 * period - 连续执行之间的时期 * unit - initialDelay 和 period 参数的时间单位 * * return 一个 ScheduledFuture 代表待完成的任务，其 get() 方法将在取消时抛出异常 * * Exception * RejectedExecutionException - 如果该任务无法安排执行 * NullPointerException - 如果可调用为空 * IllegalArgumentException - 如果周期小于或等于零 */public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit); **对于延迟、周期任务可以考虑使用 ScheduledThreadPoolExecutor ** 3. 寻找可强化的并行性3.1 寻找可强化的并行性 Executor 框架让制定一个执行策略变得简单。不过想要使用 Executor，我们还必须能够将任务描述为 Runnable。 在大多数服务端程序中，基本都存在这样一个明显的任务边界：单一的客户请求 为任务边界。 但是，很多客户端程序中，任务边界有时并非如此显而易见。 即使在服务端程序中，一个请求 任务，内部仍然会有可以进一步细化的并行性。 3.2 顺序执行的页面渲染器 顺序处理 处理 HTML 文档最简单的方法是顺序处理。 当遇到一个文本标签，就将它渲染到图像缓存里； 当遇到一个图像的引用时，先通过网络获取它，然后也将它渲染到图像缓存里。 这样的顺序，可能会让用户等待很长时间，指导呈现出所有文本、图像 预留占位符 先渲染文本元素，并为图像预留出矩形的占位符 处理文本后，程序返回到开始，并下载图像，将它们绘制到相应的占位符上。 3.3 示例：顺序的渲染页面元素12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.List;/** * Created by osys on 2022/08/28 21:48. */public abstract class SingleThreadRenderer { void renderPage(CharSequence source) { // 文本 renderText(source); // 图像 List&lt;ImageData&gt; imageData = new ArrayList&lt;&gt;(); for (ImageInfo imageInfo : scanForImageInfo(source)) { imageData.add(imageInfo.downloadImage()); } for (ImageData data : imageData) { renderImage(data); } } interface ImageData { } interface ImageInfo { ImageData downloadImage(); } abstract void renderText(CharSequence s); abstract List&lt;ImageInfo&gt; scanForImageInfo(CharSequence s); abstract void renderImage(ImageData i);} 3.4 可携带结果的任务：Callable 和 Future我们知道 Callable 接口有返回值，Runnable 接口没有返回值。 我们可以将 Runnable 或 Callable 提交给 Executor，然后得到一个 Future，用得到的 Future&lt;T&gt; 来获得任务执行的结果，或者取消任务。 1public interface ExecutorService extends Executor { } 也可以将 Runnable 实例化一个 FutureTask【如下，FutureTask 实现了 Runnable】 123public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; { }public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; { } FutureTask 既可以提交给 Executor 来执行，又可以直接调用 run() 方法运行。 Runnable 或其分支，将其提交给 Executor 执行，Future.get() 的值可以指定，无指定默认为 null 123&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task); 将 Callable 提交给 Executor 执行，Future.get() 的值为 Callable 执行的返回值 3.5 示例：使用 Future 等待图像下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * Created by osys on 2022/08/28 21:48. */public abstract class FutureRenderer { /** 创建线程池 */ private final ExecutorService executor = Executors.newCachedThreadPool(); /** 页面资源渲染 */ void renderPage(CharSequence source) { // 图片信息集合 final List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source); // 创建一个 task，该 task 返回【图片数据】集合 Callable&lt;List&lt;ImageData&gt;&gt; task = new Callable&lt;List&lt;ImageData&gt;&gt;() { @Override public List&lt;ImageData&gt; call() { List&lt;ImageData&gt; result = new ArrayList&lt;&gt;(); // 从【图片信息集】中，下载所有的【图片数据】 for (ImageInfo imageInfo : imageInfos) { result.add(imageInfo.downloadImage()); } return result; } }; // 将 Callable 提交给 Executor Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task); // 文本渲染 renderText(source); try { // 如果 Executor 已经将 task 执行完成，返回【图片数据】 // 那么将【图片数据】进行渲染 List&lt;ImageData&gt; imageData = future.get(); for (ImageData data : imageData) { renderImage(data); } } catch (InterruptedException e) { // 中断线程 Thread.currentThread().interrupt(); // 取消任务 future.cancel(true); } catch (ExecutionException e) { throw LaunderThrowable.launderThrowable(e.getCause()); } } /** 图片数据 */ interface ImageData { } /** 图片信息 */ interface ImageInfo { /** 下载图片数据 */ ImageData downloadImage(); } /** 文本渲染 */ abstract void renderText(CharSequence s); /** 扫描图片 */ abstract List&lt;ImageInfo&gt; scanForImageInfo(CharSequence s); /** 图片渲染 */ abstract void renderImage(ImageData i);}/** Throwable 强制转换为 RuntimeException */class LaunderThrowable { /** * 将未经检查的 Throwable 抛出。 * * 如果 throwable 是 RuntimeException 则返回 Throwable。 * 如果 throwable 是 Error 则抛出 Error。 * 否者抛出 IllegalStateException。 */ public static RuntimeException launderThrowable(Throwable throwable) { if (throwable instanceof RuntimeException) { return (RuntimeException) throwable; } else if (throwable instanceof Error) { throw (Error) throwable; } else { throw new IllegalStateException(&quot;Not unchecked&quot;, throwable); } }} 3.6 Executor 和 BlockingQueue 功能的整合 —- CompletionServiceCompletionService 整合了 Executor 和 BlockingQueue 的功能。下面将从 CompletionService 实现上分析其功能。 CompletionService 将新异步任务的生产与已完成任务的结果消耗相分离 1234567891011public interface CompletionService&lt;V&gt; { Future&lt;V&gt; submit(Callable&lt;V&gt; task); Future&lt;V&gt; submit(Runnable task, V result); Future&lt;V&gt; take() throws InterruptedException; Future&lt;V&gt; poll(); Future&lt;V&gt; poll(long timeout, TimeUnit unit) throws InterruptedException;} 回顾一下 BlockingQueue 12341. 阻寨队列(Blocking queue)提供了可阻塞的 put 和 take 方法2. 如果 Queue 己经满了，put 方法会被阻塞，直到有空间可用3. 如果 Queue是空的，那么 take 方法会被阻塞，直到有元素可用4. Queue 的长度可以有限，也可以无限，无限的 Queue 永远不会充满，所以它的 put 方法永远不会阻塞 ExecutorCompletionservice 是实现 CompletionService 接口的一个类，并将 计算任务 委托给一个 Executor。 1234567public class ExecutorCompletionService&lt;V&gt; implements CompletionService&lt;V&gt; { // 线程池 private final Executor executor; // 阻塞队列 private final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue; // ... ...} ExecutorCompletionservice 的构造函数中创建了一个 BlockingQueue，用来保存完成的结果。 123456789public ExecutorCompletionService(Executor executor) { // ... this.completionQueue = new LinkedBlockingQueue&lt;Future&lt;V&gt;&gt;();}public ExecutorCompletionService(Executor executor, BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) { // ... this.completionQueue = completionQueue;} 在 ExecutorCompletionservice 中有一个内部类：QueueingFuture 1234567891011private class QueueingFuture extends FutureTask&lt;Void&gt; { QueueingFuture(RunnableFuture&lt;V&gt; task) { super(task, null); this.task = task; } // 重写了 FutureTask 的 done() 方法 // completionQueue 为 ExecutorCompletionservice 的成员变量 // task 执行完成时会调用 FutureTask 中 done 方法 protected void done() { completionQueue.add(task); } private final Future&lt;V&gt; task;} 当向 ExecutorCompletionservice 提交了一个任务后，首先把这个任务包装为一个 QueueingFuture 12345678/** 其中一个 submit() 方法 */public Future&lt;V&gt; submit(Callable&lt;V&gt; task) { if (task == null) throw new NullPointerException(); RunnableFuture&lt;V&gt; f = newTaskFor(task); // 执行 QueueingFuture executor.execute(new QueueingFuture(f)); return f;} new QueueingFuture(f) —- 将 task 包装为一个 QueueingFuture。 提交一个 task： 如上，我们提交一个 task，该 task 会被包装为一个 QueueingFuture QueueingFuture 是 FutureTask 的子类，且 QueueingFuture 重写了父类的 done() 方法。 123456// completionQueue 为 ExecutorCompletionservice 的成员变量// private final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;protected void done() { completionQueue.add(task);} task 执行完成时，都会调用 FutureTask 中 done 方法 调用 done 方法，会将执行完 task 后的结果加入到阻塞队列中。 ExecutorCompletionservice 中的 take() 、poll()方法 123456789101112/** 删除并获取 */public Future&lt;V&gt; take() throws InterruptedException { return completionQueue.take();}/** 删除并获取 */public Future&lt;V&gt; poll() { return completionQueue.poll();}/** 删除并获取 */public Future&lt;V&gt; poll(long timeout, TimeUnit unit) throws InterruptedException { return completionQueue.poll(timeout, unit);} 如上 take()和poll()方法，实际上是将获取结果委托给了阻塞队列。 在阻塞队列中，如果队列满了，put 方法会被阻塞，直到有空间可用。 如果队列是空的，那么 take 方法会被阻塞，直到有元素可用。 3.7 示例：使用 CompletionService 的页面渲染器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.CompletionService;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorCompletionService;import java.util.concurrent.ExecutorService;import java.util.concurrent.Future;/** * Created by osys on 2022/08/28 21:48. */public abstract class Renderer { private final ExecutorService executor; Renderer(ExecutorService executor) { // 创建线程池 this.executor = executor; } void renderPage(CharSequence source) { // 图片信息集合 final List&lt;ImageInfo&gt; info = scanForImageInfo(source); // CompletionService 整合了 Executor 和 BlockingQueue 的功能， // 创建一个 CompletionService 对象，将新异步任务的生产与已完成任务的结果消耗相分离 CompletionService&lt;ImageData&gt; completionService = new ExecutorCompletionService&lt;&gt;(executor); for (final ImageInfo imageInfo : info) { // 提交任务 completionService.submit(new Callable&lt;ImageData&gt;() { @Override public ImageData call() { // 下载图片 return imageInfo.downloadImage(); } }); } // 文本渲染 renderText(source); try { // 图片渲染 for (int t = 0, n = info.size(); t &lt; n; t++) { // 在 CompletionService 中，task 会被其交给 Executor 进行执行 // 执行后的的 Future 会放在 BlockingQueue 中，通过 take()、poll() 方法获取 // 如果 Executor 已经将 task 执行完成，返回【图片数据】 // 那么将【图片数据】进行渲染 Future&lt;ImageData&gt; f = completionService.take(); ImageData imageData = f.get(); renderImage(imageData); } } catch (InterruptedException e) { // 中断线程 Thread.currentThread().interrupt(); } catch (ExecutionException e) { throw LaunderThrowable.launderThrowable(e.getCause()); } } /** 图片数据 */ interface ImageData { } /** 图片信息 */ interface ImageInfo { /** 下载图片数据 */ ImageData downloadImage(); } /** 文本渲染 */ abstract void renderText(CharSequence s); /** 扫描图片 */ abstract List&lt;ImageInfo&gt; scanForImageInfo(CharSequence s); /** 图片渲染 */ abstract void renderImage(ImageData i); static class LaunderThrowable { /** * 将未经检查的 Throwable 抛出。 * * 如果 throwable 是 RuntimeException 则返回 Throwable。 * 如果 throwable 是 Error 则抛出 Error。 * 否者抛出 IllegalStateException。 */ public static RuntimeException launderThrowable(Throwable throwable) { if (throwable instanceof RuntimeException) { return (RuntimeException) throwable; } else if (throwable instanceof Error) { throw (Error) throwable; } else { throw new IllegalStateException(&quot;Not unchecked&quot;, throwable); } } }} 3.8 为任务设置时限 有时候如果一个活动无法在某个确定时间内完成，那么它的结果就失效了，此时程序可以放弃该活动。 Future&lt;V&gt; 有一个 get() 方法，可以在时限内获取结果，否者就抛出 TimeoutException 异常 123456/** * 等待计算完成，然后检索其结果。如果超时，则抛出异常 * timeout - 等待的最长时间 * unit - 超时参数的时间单位 */V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; 3.9 示例：旅游预订门户网站12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.TimeoutException;import static java.util.concurrent.TimeUnit.NANOSECONDS;/** * Created by osys on 2022/08/28 21:48. */public class RenderWithTimeBudget { private static final Ad DEFAULT_AD = new Ad(); private static final long TIME_BUDGET = 1000; private static final ExecutorService exec = Executors.newCachedThreadPool(); Page renderPageWithAd() throws InterruptedException { long endNanos = System.nanoTime() + TIME_BUDGET; // 提交任务 Future&lt;Ad&gt; adFuture = exec.submit(new FetchAdTask()); // 在等待广告时，进行渲染页面 Page page = renderPageBody(); Ad ad; try { long timeLeft = endNanos - System.nanoTime(); // 在规定时间内，获取广告。否则默认没有广告 ad = adFuture.get(timeLeft, NANOSECONDS); } catch (ExecutionException e) { ad = DEFAULT_AD; } catch (TimeoutException e) { // 没有在规定时间内获取到广告，取消任务 ad = DEFAULT_AD; adFuture.cancel(true); } // 广告渲染 page.setAd(ad); return page; } Page renderPageBody() { return new Page(); } /** 广告 */ static class Ad { } /** 页面 */ static class Page { public void setAd(Ad ad) { } } /** 添加广告的 task */ static class FetchAdTask implements Callable&lt;Ad&gt; { @Override public Ad call() { return new Ad(); } }} 3.10 示例：在预订时间内请求旅游报价 ExecutorService.invokeAll() 方法 1234567891011121314/** * 执行给定的任务，返回在所有完成结果。 * 通过 Future.isDone() 判断 task 是否已经完成。 * 在规定时间内，如果在任务列表中，还有任务未被执行，那么通过 Future.cancel() 取消任务。 * * @param tasks - 收集任务 * @param timeout - 等待的最长时间 * @param unit - 超时参数的时间单位 * @return 完成结果。如果操作没有超时，每个任务都会完成。 如果超时，其中一些任务将不会完成。 */&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; Future 的 isDone() 方法和： 1234567891011121314/** 如果任务已完成（正常终止、异常或取消），返回true */boolean isDone();/** * 尝试取消执行此任务。 * 如果任务已完成、被取消、或由于某种无法取消，则此尝试将失败。 * * 如果成功，并且当 cancel 时，此任务尚未启动，则此任务不应运行。 * 如果任务已经开始，则 mayInterruptIfRunning 参数确定是否中断执行该 task 的线程，以尝试停止该 task * * @param mayInterruptIfRunning true如果执行该任务的线程应该被中断; 否则，正在进行的任务被允许完成 * @return 如果任务无法取消，返回 false，否则返回 true。 */boolean cancel(boolean mayInterruptIfRunning); 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.Iterator;import java.util.List;import java.util.Set;import java.util.concurrent.Callable;import java.util.concurrent.CancellationException;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;/** * Created by osys on 2022/08/28 21:48. */public class TimeBudget { private static ExecutorService exec = Executors.newCachedThreadPool(); /** * 获得旅游行情排名 * @param travelInfo 旅游资讯 * @param companies 公司 ---- set集合 * @param ranking 排行 * @param time 超时时间 * @param unit 时间单位 */ public List&lt;TravelQuote&gt; getRankedTravelQuotes(TravelInfo travelInfo, Set&lt;TravelCompany&gt; companies, Comparator&lt;TravelQuote&gt; ranking, long time, TimeUnit unit) throws InterruptedException { // 将【每个公司 + 旅游资讯】封装成 task List&lt;QuoteTask&gt; tasks = new ArrayList&lt;&gt;(); for (TravelCompany company : companies) { tasks.add(new QuoteTask(company, travelInfo)); } // 将所有 task 提交给 ExecutorService // 所有任务在规定时间内执行完任务 List&lt;Future&lt;TravelQuote&gt;&gt; quoteFutures = exec.invokeAll(tasks, time, unit); // 报价获取 List&lt;TravelQuote&gt; quotes = new ArrayList&lt;&gt;(tasks.size()); Iterator&lt;QuoteTask&gt; taskIter = tasks.iterator(); for (Future&lt;TravelQuote&gt; quoteFuture : quoteFutures) { QuoteTask task = taskIter.next(); try { // 获取报价成功 quotes.add(quoteFuture.get()); } catch (ExecutionException e) { // 获取报价失败 quotes.add(task.getFailureQuote(e.getCause())); } catch (CancellationException e) { // 获取报价超时 quotes.add(task.getTimeoutQuote(e)); } } Collections.sort(quotes, ranking); return quotes; }}class QuoteTask implements Callable&lt;TravelQuote&gt; { private final TravelCompany company; private final TravelInfo travelInfo; public QuoteTask(TravelCompany company, TravelInfo travelInfo) { this.company = company; this.travelInfo = travelInfo; } /** 获取报价失败 */ TravelQuote getFailureQuote(Throwable t) { return null; } /** 获取报价超时 */ TravelQuote getTimeoutQuote(CancellationException e) { return null; } @Override public TravelQuote call() throws Exception { // 获取旅游报价 return company.solicitQuote(travelInfo); }}/** 旅游公司 */interface TravelCompany { /** 获取旅游报价 */ TravelQuote solicitQuote(TravelInfo travelInfo) throws Exception;}/** 旅游报价 */interface TravelQuote {}/** 旅游资讯 */interface TravelInfo {}","link":"/posts/e39c.html"},{"title":"SpringBoot项目连接多源MySQL数据库","text":"说明(主要是实现的思路) 对于使用 SpringBoot 中使用 MySQL 的项目来说，可能会面临一个 SpringBoot 项目连接多个不同的 MySQL 数据库。这里针对普通的 SpringBoot 项目进行实现。关注点在查询前，数据库选择上进行定义。Demo 项目代码已经放到了我的 GitHub，是 SpringBoot + MyBatis 的测试项目。通过注解，选择不同的数据库。可能大家在参考的时候会出现各种奇奇怪怪的问题（细心能解决大部分问题哈） 1. 普通的 SpringBoot 项目 datasource 目录中的代码为主要实现代码。example 目录下的代码只是用作测试不同MySQL数据源的连接。 2. 实现思路 数据源连接信息实体类(getter、setter、constructer省略) 该实体类的字段信息，根据自己项目特定情况而定。不一定按照如此定义。 12345678910111213141516171819202122232425262728293031package com.osys.dynamic.datasource;import javax.sql.DataSource;import java.util.StringJoiner;public class DataSourceProperty { /** 数据库连接类型，后边使用 com.zaxxer.hikari.HikariDataSource 数据库连接池。使用别的数据库连接池思想也一样 */ private Class&lt;? extends DataSource&gt; clazzType; /** 数据库连接驱动：com.mysql.cj.jdbc.Driver、com.mysql.jdbc.Driver。不同的版本用的驱动可能是不一样的 */ private String driverClassName; /** 数据库连接用户名 */ private String userName; /** 数据库连接密码 */ private String password; /** 数据库ip */ private String host; /** 数据库端口 */ private String port; /** 数据库名 */ private String dataSourceName; /** 后边获取该连接信息对应的 key */ private String key;} 数据库连接构建类 对于上面的 DataSourceProperty 保存的是数据库连接信息，这里创建一个构建工具类，用于构建数据库连接。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.osys.dynamic.datasource;import org.springframework.beans.MutablePropertyValues;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.core.convert.ConversionService;import org.springframework.core.convert.support.DefaultConversionService;import org.springframework.validation.DataBinder;import javax.sql.DataSource;import java.util.HashMap;import java.util.Map;public class DynamicDataSourceBuilder { private DataSourceProperty property; private final ConversionService conversionService = new DefaultConversionService(); /** 默认 DataSource 类型 */ private static final Class&lt;? extends DataSource&gt; DEFAULT_DATASOURCE_TYPE = com.zaxxer.hikari.HikariDataSource.class; public static DynamicDataSourceBuilder create() { return new DynamicDataSourceBuilder(); } /** 添加数据库连接信息 */ public DynamicDataSourceBuilder setPropertyValues(DataSourceProperty dataSourceProperty) { this.property = dataSourceProperty; return this; } /** 构建数据库连接 */ public DataSource build() { DataSource dataSource = buildDataSource(this.property); return propertySet(dataSource, this.property); } /** 数据库连接 */ public DataSource buildDataSource(DataSourceProperty dataSourceProperty) { String driverClassName = dataSourceProperty.getDriverClassName(); Class&lt;? extends DataSource&gt; dataSourceType = dataSourceProperty.getClazzType(); if (dataSourceType == null) { dataSourceType = DEFAULT_DATASOURCE_TYPE; } String dataSourceName = dataSourceProperty.getDataSourceName(); String host = dataSourceProperty.getHost(); String port = dataSourceProperty.getPort(); String userName = dataSourceProperty.getUserName(); String password = dataSourceProperty.getPassword(); String url = &quot;jdbc:mysql://&quot; + host + &quot;:&quot; + port + &quot;/&quot; + dataSourceName + &quot;?&quot; + &quot;useUnicode=true&quot; + &quot;&amp;characterEncoding=utf-8&quot; + &quot;&amp;serverTimezone=Asia/Shanghai&quot;; DataSourceBuilder&lt;? extends DataSource&gt; dataSourceBuilder = DataSourceBuilder.create() .driverClassName(driverClassName) .url(url) .username(userName) .password(password) .type(dataSourceType); return dataSourceBuilder.build(); } /** 数据库连接池的一些配置，也可以不用，正常没什么影响。连接池都有默认配置的。 */ public DataSource propertySet(DataSource dataSource, DataSourceProperty dataSourceProperty) { DataBinder dataBinder = new DataBinder(dataSource); dataBinder.setConversionService(conversionService); dataBinder.setIgnoreInvalidFields(true); dataBinder.setIgnoreUnknownFields(true); // 新加连接池配置 Map&lt;String, Object&gt; values = new HashMap&lt;&gt;(); values.put(&quot;max-pool-size&quot;, 10); values.put(&quot;connection-timeout&quot;, 50000); values.put(&quot;min-idle&quot;, 5); values.put(&quot;idle-timeout&quot;, 500000); values.put(&quot;max-lifetime&quot;, 540000); dataBinder.bind(new MutablePropertyValues(values)); return dataSource; }} 多数据源连接信息实体类 上面的 DataSourceProperty 保存的时某个数据源的连接信息，由于是多数据源的，会存在多个 DataSourceProperty 对象，这里通过数据源 key 来获取对应的数据源连接信息，编写一个保存数据源信息的配置类： 12345678910111213141516171819202122232425262728package com.osys.dynamic.datasource;import org.springframework.context.annotation.Configuration;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;@Configuration(value = &quot;dynamicDataSourceConfig&quot;)public class DynamicDataSourceConfig { /** 数据源 key 和配置属性实体类的键值对 */ private final ConcurrentMap&lt;String, DataSourceProperty&gt; dataSourceProps = new ConcurrentHashMap&lt;&gt;(); /** 保存一个数据源连接信息 */ public void registerDataSource(DataSourceProperty dataSourceProperty) { dataSourceProps.put(dataSourceProperty.getKey(), dataSourceProperty); } /** 移除一个数据源连接信息 */ public void removeDataSource(String dataSourceKey) { dataSourceProps.remove(dataSourceKey); } /** 获取一个数据源连接信息 */ public DataSourceProperty getDataSourceProperty(String dataSourceKey) { return dataSourceProps.get(dataSourceKey); }} 多数据源的选择 AbstractRoutingDataSource 是 SpringBoot 基于查找 key 将 getConnection() 调用路由到各种目标 DataSource 之一的抽象 DataSource 实现。 选择数据源解决方案：编写一个类，继承 AbstractRoutingDataSource，实现它的 determineCurrentLookupKey() 方法和 determineTargetDataSource() 方法，来选择使用哪一个数据源。DynamicDataSourceConfig 中 Map 保存到创建的数据连接。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.osys.dynamic.datasource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;import javax.sql.DataSource;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;/** * &lt;p&gt;&lt;b&gt;{@link DynamicDataSourceResolver} Description&lt;/b&gt;: 在进行查询时，选择需要的 DataSource。 * 默认为主数据源。key = null 时，为主数据源。 * key != null 时，如果 dynamicDataSources 中存在对应的数据源，直接取出使用。 * 如果 dynamicDataSources 中不存在 key 对应的数据源，那么从 dynamicDataSourceConfig 中获取 key 对应的数据源配置(如果存在)， * 创建新的数据源，保存在 dynamicDataSources 中，并在查询中使用，否则使用默认数据源(主数据源)。 * &lt;/p&gt; * @author Created by osys on 2022/08/30 11:09. */public class DynamicDataSourceResolver extends AbstractRoutingDataSource { /** 保存动态数据库连接的 Map， dataSourceKey -&gt; DataSource */ private static final ConcurrentMap&lt;String, DataSource&gt; dynamicDataSources = new ConcurrentHashMap&lt;&gt;(); private DynamicDataSourceConfig dynamicDataSourceConfig; @Autowired @Qualifier(value = &quot;dynamicDataSourceConfig&quot;) public void setDynamicDataSourceConfig(DynamicDataSourceConfig dynamicDataSourceConfig) { this.dynamicDataSourceConfig = dynamicDataSourceConfig; } /** * 确定当前查找 key。这通常会被实现来检查线程绑定的事务上下文。 * 允许任意键。 * @return target dataSource key */ @Override protected Object determineCurrentLookupKey() { // 往下看【线程隔离的 key】处说明 return DynamicDataSourceContextHolder.getDataSourceKey(); } /** * 检索当前目标数据源。 * 确定 current lookup key，在 targetDataSources 映射中执行查找，必要时回退到指定的default target DataSource。 */ @Override protected DataSource determineTargetDataSource() { Object lookupKey = determineCurrentLookupKey(); if (lookupKey == null) { super.logger.info(&quot;使用默认数据源&quot;); return super.determineTargetDataSource(); } DataSource dataSource = dynamicDataSources.get(String.valueOf(lookupKey)); if (dataSource != null) { super.logger.info(&quot;使用数据源:&quot; + lookupKey); return dataSource; } DataSourceProperty dataSourceProperty = dynamicDataSourceConfig.getDataSourceProperty(String.valueOf(lookupKey)); if (dataSourceProperty == null) { super.logger.info(&quot;使用默认数据源&quot;); return super.determineTargetDataSource(); } DataSource createDataSource = DynamicDataSourceBuilder .create() .setPropertyValues(dataSourceProperty) .build(); dynamicDataSources.put(String.valueOf(lookupKey), createDataSource); super.logger.info(&quot;使用数据源:&quot; + lookupKey); return createDataSource; } public static void removeDataSource(String key) { dynamicDataSources.remove(key); } public static void addDataSource(String key, DataSource dataSource) { dynamicDataSources.put(key, dataSource); }} 线程隔离的 key 上面的 DynamicDataSourceResolver#determineTargetDataSource() 方法中，确定的是 dataSource 的 key。SpringBoot 项目中，CRUD 操作是在不同线程中进行的，不同的需求，连接的MySQL数据库可能是不一样的，因此不同线程之间的 Key 是不能够被其它线程影响到的。使用 ThreadLocal 防止任务在共享资源上产生冲突 1234567891011121314151617181920package com.osys.dynamic.datasource;/** * 使用 ThreadLocal 来指定 DataSource 的 key */public class DynamicDataSourceContextHolder { private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;(); public static void setDataSourceKey(String dataSourceKey) { contextHolder.set(dataSourceKey); } public static String getDataSourceKey() { return contextHolder.get(); } public static void clearDataSourceKey() { contextHolder.remove(); }} 将数据源注册为 bean 前面一件基本实现了不同数据源的选择，在此还有一件比较重要的事情要完成，那就是将我们项目中的数据库连接注册为 bean。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.osys.dynamic.datasource;import org.springframework.beans.MutablePropertyValues;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.GenericBeanDefinition;import org.springframework.context.EnvironmentAware;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotationMetadata;import javax.sql.DataSource;import java.util.HashMap;import java.util.Map;/** * 将主数据源、动态数据源注册为 Bean */@Configuration(value = &quot;dynamicDataSourceRegister&quot;)public class DynamicDataSourceRegister implements ImportBeanDefinitionRegistrar, EnvironmentAware { private DataSource defaultDataSource; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { // 所有数据源 Map&lt;String, Object&gt; targetDataSources = new HashMap&lt;&gt;(); // 将主数据源添加到 targetDataSources 中 targetDataSources.put(&quot;dataSource&quot;, defaultDataSource); // 创建 DynamicDataSource 路由类，并注册到容器里做数据源 GenericBeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClass(DynamicDataSourceResolver.class); beanDefinition.setSynthetic(true); MutablePropertyValues propertyValues = beanDefinition.getPropertyValues(); // 命名要求如此： // 默认(主)数据源 -&gt; defaultTargetDataSource // 目标(其它)数据源 -&gt; targetDataSources // 详情请看：AbstractRoutingDataSource.determineTargetDataSource() 方法 propertyValues.addPropertyValue(&quot;defaultTargetDataSource&quot;, defaultDataSource); propertyValues.addPropertyValue(&quot;targetDataSources&quot;, targetDataSources); registry.registerBeanDefinition(&quot;dataSources&quot;, beanDefinition); } @Override public void setEnvironment(Environment environment) { // 获取 SpringBoot 配置文件中的数据库连接信息(主数据源) String mainUrl = environment.getProperty(&quot;spring.datasource.url&quot;); String mainUser = environment.getProperty(&quot;spring.datasource.username&quot;); String mainPassword = environment.getProperty(&quot;spring.datasource.password&quot;); String mainDriverClassName = environment.getProperty(&quot;spring.datasource.driver-class-name&quot;); // 主数据源 String uri = mainUrl.split(&quot;//&quot;)[1]; String hostPort = uri.split(&quot;/&quot;)[0]; String[] dsNameParma = uri.split(&quot;/&quot;)[1].split(&quot;\\\\?&quot;); String[] parma = dsNameParma[1].split(&quot;&amp;&quot;); DataSourceProperty defaultDataSourceProperty = new DataSourceProperty( mainDriverClassName, mainUser, mainPassword, hostPort.split(&quot;:&quot;)[0], hostPort.split(&quot;:&quot;)[1], dsNameParma[0], &quot;defaultDataSource&quot;); this.defaultDataSource = DynamicDataSourceBuilder.create() .setPropertyValues(defaultDataSourceProperty).build(); }} 对于不同的 SpringBoot 项目，数据库连接的方式大概率是不一样的，如果采用本思想实现连接不同MySQL的数据库，应该将主数据源的连接方式改为如此。 数据源连接信息 项目中会用到的多源MySQL数据库连接，在项目启动的时候需要将这些数据库的连接信息保存到前边创建的 DynamicDataSourceConfig 中，以便后续使用。在 SpringBoot 中可以通过继承 CommandLineRunner 接口，实现 run() 方法，在项目启动的时候，将多个数据库连接信息加载到程序中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.osys.dynamic.datasource.runner;import com.osys.dynamic.datasource.DataSourceProperty;import com.osys.dynamic.datasource.DynamicDataSourceConfig;import com.osys.dynamic.datasource.service.RegisterConnectService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.CommandLineRunner;import org.springframework.stereotype.Component;import java.util.List;/** * 将所有的数据源连接信息，从数据库中读取出来，并保存在 {@link DynamicDataSourceConfig} 中 */@Component(value = &quot;initializeRunner&quot;)public class InitializeRunner implements CommandLineRunner { /** 假设数据库连接信息保存在项目主数据库的表中 */ private RegisterConnectService registerConnectService; private DynamicDataSourceConfig dynamicDataSourceConfig; @Autowired @Qualifier(value = &quot;registerConnectService&quot;) public void setRegisterConnectService(RegisterConnectService registerConnectService) { this.registerConnectService = registerConnectService; } @Autowired @Qualifier(value = &quot;dynamicDataSourceConfig&quot;) public void setDynamicDataSourceConfig(DynamicDataSourceConfig dynamicDataSourceConfig) { this.dynamicDataSourceConfig = dynamicDataSourceConfig; } @Override public void run(String... args) { registerDataSource(); } private void registerDataSource() { // 从主数据库的表中获取多源数据库连接信息（可能你的项目的数据库连接信息不是保存在主数据库中，而是保存在别的数据库中、保存在文件中.......，只需要将信息加载进来即可） List&lt;DataSourceProperty&gt; dataSourcePropertyList = registerConnectService.selectProperty(); for (DataSourceProperty dataSourceProperty : dataSourcePropertyList) { // 默认使用 com.zaxxer.hikari.HikariDataSource dataSourceProperty.setClazzType(com.zaxxer.hikari.HikariDataSource.class); dynamicDataSourceConfig.registerDataSource(dataSourceProperty); } }} 例如：这里的数据库连接信息是保存在主数据源中的，那么 RegisterConnectService 的实现： 12345678910111213141516171819202122232425262728package com.osys.dynamic.datasource.service;import com.osys.dynamic.datasource.DataSourceProperty;import com.osys.dynamic.datasource.mapper.RegisterConnectMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;import java.util.List;/** * 多数据源连接信息 service */@Service(value = &quot;registerConnectService&quot;)public class RegisterConnectService { private RegisterConnectMapper registerConnectMapper; @Autowired @Qualifier(value = &quot;registerConnectMapper&quot;) public void setRegisterConnectMapper(RegisterConnectMapper registerConnectMapper) { this.registerConnectMapper = registerConnectMapper; } public List&lt;DataSourceProperty&gt; selectProperty() { return registerConnectMapper.selectProperty(); }} 123456789101112131415161718192021222324252627282930package com.osys.dynamic.datasource.mapper;import com.osys.dynamic.datasource.DataSourceProperty;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Result;import org.apache.ibatis.annotations.Results;import org.apache.ibatis.annotations.Select;import org.springframework.stereotype.Repository;import java.util.List;/** * 多数据源连接信息 mapper */@Repository(value = &quot;registerConnectMapper&quot;)@Mapperpublic interface RegisterConnectMapper { @Select(&quot;SELECT * FROM connect_property&quot;) @Results(value = { @Result(column = &quot;key&quot;, property = &quot;key&quot;, javaType = java.lang.String.class), @Result(column = &quot;data_source_name&quot;, property = &quot;dataSourceName&quot;, javaType = java.lang.String.class), @Result(column = &quot;port&quot;, property = &quot;port&quot;, javaType = java.lang.String.class), @Result(column = &quot;host&quot;, property = &quot;host&quot;, javaType = java.lang.String.class), @Result(column = &quot;password&quot;, property = &quot;password&quot;, javaType = java.lang.String.class), @Result(column = &quot;user_name&quot;, property = &quot;userName&quot;, javaType = java.lang.String.class), @Result(column = &quot;driver_class_name&quot;, property = &quot;driverClassName&quot;, javaType = java.lang.String.class) }) List&lt;DataSourceProperty&gt; selectProperty();} 在前面多数据源的加载并创建功能已经基本实现，需要在 SpringApplication 中导入 DynamicDataSourceRegister 类。 12345678910111213141516171819package com.osys.dynamic;import com.osys.dynamic.datasource.DynamicDataSourceRegister;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Import;@Import(DynamicDataSourceRegister.class)@SpringBootApplicationpublic class DataSourcePointApplication { public static ConfigurableApplicationContext context; public static void main(String[] args) { context = SpringApplication.run(DataSourcePointApplication.class, args); }} 到这里，项目连接不同数据源的数据库代码主体已经基本是实现了。下面需要实现数据源使用。 3. 项目连接不同数据源MySQL 创建注解 1234567891011121314151617181920212223package com.osys.dynamic.datasource.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 动态使用数据源注解。 * 作用在方法上，以方法的首个参数为 DataSource 的key，来进行选择 DataSource， * 如果首个参数不符合，那么将选择项目默认的(主)数据库 */@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DynamicDataSource { String name() default MASTER; public static final String MASTER = &quot;master&quot;;} 12345678910111213141516171819package com.osys.dynamic.datasource.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 动态使用数据源注解。 * 作用在方法上，以注解传入的参数 name 为 key，来进行选择 DataSource， 如果参数 name 不符合，那么将选择项目默认的(主)数据库 */@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface TargetDataSource { String name();} 编写切面 虽然注解已经写好，不过对于这两个注解，还没关联到选择不同的数据源。 1234567891011121314151617181920212223242526272829303132package com.osys.dynamic.datasource.aspect;import com.osys.dynamic.datasource.DynamicDataSourceContextHolder;import com.osys.dynamic.datasource.annotation.DynamicDataSource;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;/** * 在查询前，在查询前，根据注解 DynamicDataSource 的 name 设置为 DataSource 的 key，查询时获取到对应的 DataSource */@Aspect@Component(value = &quot;dynamicDataSourceAspect&quot;)public class DynamicDataSourceAspect { @Pointcut(&quot;@annotation(dataSource) &amp;&amp; args(dataSourceKey,..)&quot;) public void datasource(DynamicDataSource dataSource, String dataSourceKey) { } @Around(&quot;datasource(dataSource, dataSourceKey)&quot;) public Object selectDataSource(ProceedingJoinPoint pjp, DynamicDataSource dataSource, String dataSourceKey) { try { DynamicDataSourceContextHolder.setDataSourceKey(dataSourceKey); return pjp.proceed(); } catch (Throwable e) { throw new RuntimeException(e); } finally { DynamicDataSourceContextHolder.clearDataSourceKey(); } }} 1234567891011121314151617181920212223242526package com.osys.dynamic.datasource.aspect;import com.osys.dynamic.datasource.DynamicDataSourceContextHolder;import com.osys.dynamic.datasource.annotation.TargetDataSource;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;/** * 在查询前，根据注解 TargetDataSource 的 name 设置为 DataSource 的 key，查询时获取到对应的 DataSource */@Aspect@Componentpublic class TargetDataSourceAspect { @Before(&quot;@annotation(ds)&quot;) public void changeDataSource(JoinPoint point, TargetDataSource ds) throws Throwable { DynamicDataSourceContextHolder.setDataSourceKey(ds.name()); } @After(&quot;@annotation(ds)&quot;) public void restoreDataSource(JoinPoint point, TargetDataSource ds) { DynamicDataSourceContextHolder.clearDataSourceKey(); }} SpringApplication 添加切面代理支持 123456789101112131415161718192021package com.osys.dynamic;import com.osys.dynamic.datasource.DynamicDataSourceRegister;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.EnableAspectJAutoProxy;import org.springframework.context.annotation.Import;@Import(DynamicDataSourceRegister.class)@SpringBootApplication@EnableAspectJAutoProxypublic class DataSourcePointApplication { public static ConfigurableApplicationContext context; public static void main(String[] args) { context = SpringApplication.run(DataSourcePointApplication.class, args); }} 这里，对于项目使用多源数据库的实现思路已经基本定型（完成），下面编写几个测试接口，获取不同数据源下的信息。 4. 不同数据源连接测试上面定义的 TargetDataSource 和 DynamicDataSource 注解，在 Repository 层/Service 层 的方法中使用即可。这里测试例子是在 Repository 中使用的。 创建实体类：getter、setter、constuctor等省略 12345678910111213package com.osys.dynamic.example.dto;public class User { private Integer id; private String username; private String sex; private Long birthday; private String address;} 1234567package com.osys.dynamic.example.dto;public class UserLoveGame { private int userId; private String gameName;} 12345678910111213package com.osys.dynamic.example.dto;public class UserQq { private int userId; private String account; private String password; private String createTime; private String updateTime;} 12345678910111213package com.osys.dynamic.example.dto;public class UserSchool { private Integer userId; private Integer schoolId; private String name; private String className; private String course;} 12345678910111213package com.osys.dynamic.example.dto;public class UserShopping { private int userId; private String platform; private String shopName; private String productName; private float price;} Repository 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.osys.dynamic.example.mapper;import com.osys.dynamic.datasource.annotation.DynamicDataSource;import com.osys.dynamic.datasource.annotation.TargetDataSource;import com.osys.dynamic.example.dto.User;import com.osys.dynamic.example.dto.UserLoveGame;import com.osys.dynamic.example.dto.UserQq;import com.osys.dynamic.example.dto.UserSchool;import com.osys.dynamic.example.dto.UserShopping;import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Result;import org.apache.ibatis.annotations.Results;import org.apache.ibatis.annotations.Select;import org.springframework.stereotype.Repository;import java.util.List;/** * 使用不同数据源查询的 mapper */@Repository(value = &quot;userMapper&quot;)@Mapperpublic interface UserMapper { /** 默认数据源 */ @Select(&quot;SELECT * FROM user&quot;) List&lt;User&gt; selectUsers(); /** dbKey 参数对应的数据源 */ @Select(&quot;SELECT user_id, platform, shop_name, product_name, price FROM user_shopping&quot;) @Results(value = { @Result(column = &quot;user_id&quot;, property = &quot;userId&quot;, javaType = java.lang.Integer.class), @Result(column = &quot;platform&quot;, property = &quot;platform&quot;, javaType = java.lang.String.class), @Result(column = &quot;shop_name&quot;, property = &quot;shopName&quot;, javaType = java.lang.String.class), @Result(column = &quot;product_name&quot;, property = &quot;productName&quot;, javaType = java.lang.String.class), @Result(column = &quot;price&quot;, property = &quot;price&quot;, javaType = java.lang.Float.class) }) @DynamicDataSource List&lt;UserShopping&gt; selectAllUserShopping(String dbKey); /** dbKey 参数对应的数据源 */ @Select(&quot;SELECT user_id, account, password, create_time, update_time FROM user_qq&quot;) @Results(value = { @Result(column = &quot;user_id&quot;, property = &quot;userId&quot;, javaType = java.lang.Integer.class), @Result(column = &quot;account&quot;, property = &quot;account&quot;, javaType = java.lang.String.class), @Result(column = &quot;password&quot;, property = &quot;password&quot;, javaType = java.lang.String.class), @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;, javaType = java.lang.String.class), @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;, javaType = java.lang.String.class) }) @DynamicDataSource List&lt;UserQq&gt; selectAllUserQq(String dbKey); /** dbKey 参数对应的数据源 */ @Select(&quot;SELECT user_id, game_name FROM user_love_game&quot;) @Results(value = { @Result(column = &quot;user_id&quot;, property = &quot;userId&quot;, javaType = java.lang.Integer.class), @Result(column = &quot;game_name&quot;, property = &quot;gameName&quot;, javaType = java.lang.String.class) }) @DynamicDataSource List&lt;UserLoveGame&gt; selectAllUserLoveGame(String dbKey); /** db_four 数据源 */ @Select(&quot;SELECT name, school_id, user_id, class_name, course FROM school&quot;) @Results(value = { @Result(column = &quot;user_id&quot;, property = &quot;userId&quot;, javaType = java.lang.Integer.class), @Result(column = &quot;name&quot;, property = &quot;name&quot;, javaType = java.lang.String.class), @Result(column = &quot;school_id&quot;, property = &quot;schoolId&quot;, javaType = java.lang.Integer.class), @Result(column = &quot;class_name&quot;, property = &quot;className&quot;, javaType = java.lang.String.class), @Result(column = &quot;course&quot;, property = &quot;course&quot;, javaType = java.lang.String.class) }) @TargetDataSource(name = &quot;db_four&quot;) List&lt;UserSchool&gt; selectAllUserSchool();} Service 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.osys.dynamic.example.service;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import com.osys.dynamic.example.dto.User;import com.osys.dynamic.example.dto.UserLoveGame;import com.osys.dynamic.example.dto.UserQq;import com.osys.dynamic.example.dto.UserSchool;import com.osys.dynamic.example.dto.UserShopping;import com.osys.dynamic.example.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;import java.text.SimpleDateFormat;import java.util.Date;import java.util.List;/** * 使用不同数据源查询的 service */@Service(value = &quot;userService&quot;)public class UserService { private UserMapper userMapper; @Autowired @Qualifier(value = &quot;userMapper&quot;) public void setUserMapper(UserMapper userMapper) { this.userMapper = userMapper; } public JSONArray selectUsers() { List&lt;User&gt; users = userMapper.selectUsers(); JSONArray jsonArray = new JSONArray(); for (User user : users) { JSONObject jsonObj = JSONObject.parseObject(JSONObject.toJSONString(user)); long birthday = Long.parseLong(String.valueOf(jsonObj.get(&quot;birthday&quot;))) * 1000; jsonObj.put(&quot;birthday&quot;, new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date(birthday))); jsonArray.add(jsonObj); } return jsonArray; } public JSON selectAllUserShopping(String dbKey) { List&lt;UserShopping&gt; userShoppingList = userMapper.selectAllUserShopping(dbKey); String toJSONString = JSONObject.toJSONString(userShoppingList); return (JSON) JSON.parse(toJSONString); } public JSON selectAllUserQq(String dbKey) { List&lt;UserQq&gt; userQqs = userMapper.selectAllUserQq(dbKey); String toJSONString = JSONObject.toJSONString(userQqs); return (JSON) JSON.parse(toJSONString); } public JSONArray selectAllUserLoveGame(String dbKey) { List&lt;UserLoveGame&gt; userLoveGameList = userMapper.selectAllUserLoveGame(dbKey); JSONArray jsonArr = new JSONArray(); for (UserLoveGame userLoveGame : userLoveGameList) { JSONObject jsonObj = new JSONObject(); jsonObj.put(&quot;userId&quot;, userLoveGame.getUserId()); jsonObj.put(&quot;loveGame&quot;, JSONObject.parseObject(userLoveGame.getGameName())); jsonArr.add(jsonObj); } return jsonArr; } public JSONArray selectAllUserSchool() { List&lt;UserSchool&gt; userSchoolList = userMapper.selectAllUserSchool(); JSONArray jsonArr = new JSONArray(); for (UserSchool userSchool : userSchoolList) { JSONObject jsonObj = new JSONObject(); jsonObj.put(&quot;userId&quot;, userSchool.getUserId()); jsonObj.put(&quot;schoolId&quot;, userSchool.getSchoolId()); jsonObj.put(&quot;name&quot;, userSchool.getName()); jsonObj.put(&quot;className&quot;, userSchool.getClassName()); List&lt;String&gt; courseArr = JSON.parseArray(userSchool.getCourse(), String.class); jsonObj.put(&quot;course&quot;, JSONArray.toJSON(courseArr)); jsonArr.add(jsonObj); } return jsonArr; }} Controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.osys.dynamic.example.controller;import com.osys.dynamic.example.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * &lt;p&gt;&lt;b&gt;{@link UserController} Description&lt;/b&gt;: 测试查询 * * &lt;ul&gt;接口与数据源： * &lt;li&gt;/user/select ----&gt; 主数据源&lt;/li&gt; * &lt;li&gt;/user/shopping ----&gt; db_one 数据源&lt;/li&gt; * &lt;li&gt;/user/qq ----&gt; db_two 数据源&lt;/li&gt; * &lt;li&gt;/user/game ----&gt; db_three 数据源&lt;/li&gt; * &lt;li&gt;/user/school ----&gt; db_four 数据源&lt;/li&gt; * &lt;/ul&gt; * &lt;/p&gt; * @author Created by osys on 2022/08/29 16:59. */@RestController@RequestMapping(path = &quot;/user&quot;)public class UserController { private UserService userService; @Autowired @Qualifier(value = &quot;userService&quot;) public void setUserService(UserService userService) { this.userService = userService; } @RequestMapping(method = RequestMethod.POST, path = &quot;/select&quot;) @ResponseBody public String selectUser(HttpServletRequest request, HttpServletResponse response) { // 默认数据库 return userService.selectUsers().toString(); } @RequestMapping(method = RequestMethod.POST, path = &quot;/shopping&quot;) @ResponseBody public String selectAllUserShopping(HttpServletRequest request, HttpServletResponse response) { // 数据库 key：db_one return userService.selectAllUserShopping(&quot;db_one&quot;).toString(); } @RequestMapping(method = RequestMethod.POST, path = &quot;/qq&quot;) @ResponseBody public String selectAllUserQq(HttpServletRequest request, HttpServletResponse response) { // 数据库 key：db_two return userService.selectAllUserQq(&quot;db_two&quot;).toString(); } @RequestMapping(method = RequestMethod.POST, path = &quot;/game&quot;) @ResponseBody public String selectAllUserLoveGame(HttpServletRequest request, HttpServletResponse response) { // 数据库 key：db_three return userService.selectAllUserLoveGame(&quot;db_three&quot;).toString(); } @RequestMapping(method = RequestMethod.POST, path = &quot;/school&quot;) @ResponseBody public String selectAllUserSchool(HttpServletRequest request, HttpServletResponse response) { // 数据库 key：db_four return userService.selectAllUserSchool().toString(); }} 测试 项目启动成功： 先后调用接口： http://localhost:8888/user/select http://localhost:8888/user/shopping http://localhost:8888/user/qq http://localhost:8888/user/game http://localhost:8888/user/school 控制台查看使用的数据源： 使用的数据源都是不一样的。去不同的MySQL数据库查询数据。 附数据库信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105USE mysql;-- 主数据源CREATE SCHEMA IF NOT EXISTS point_connect_demo COLLATE utf8_general_ci;-- 其它数据源 ...CREATE SCHEMA IF NOT EXISTS dynamic_one_db COLLATE utf8_general_ci;CREATE SCHEMA IF NOT EXISTS dynamic_two_db COLLATE utf8_general_ci;CREATE SCHEMA IF NOT EXISTS dynamic_three_db COLLATE utf8_general_ci;CREATE SCHEMA IF NOT EXISTS dynamic_four_db COLLATE utf8_general_ci;USE point_connect_demo;CREATE TABLE IF NOT EXISTS user( `id` INT, `user_name` VARCHAR(25), `sex` VARCHAR(5), `birthday` BIGINT, `address` VARCHAR(255));INSERT INTO user(`id`, `user_name`, `sex`, `birthday`, `address`)VALUES (1, 'name1', '男', 974698564, '中国*****1'), (2, 'name2', '女', 989658124, '中国*****2'), (3, 'name3', '男', 984088979, '中国*****3'), (4, 'name4', '女', 1031007815, '中国*****4'), (5, 'name5', '男', 936551363, '中国*****5');-- 数据库连接信息CREATE TABLE IF NOT EXISTS connect_property( `key` VARCHAR(50) PRIMARY KEY, `data_source_name` VARCHAR(100), `port` VARCHAR(20), `host` VARCHAR(50), `password` VARCHAR(255), `user_name` VARCHAR(100), `driver_class_name` VARCHAR(100));INSERT INTO connect_property(`key`, `data_source_name`, `port`, `host`, `password`, `user_name`, `driver_class_name`)VALUES ('db_one', 'dynamic_one_db', '3306', '127.0.0.1', '123456', 'root', 'com.mysql.cj.jdbc.Driver'), ('db_two', 'dynamic_two_db', '3306', '127.0.0.1', '123456', 'root', 'com.mysql.cj.jdbc.Driver'), ('db_three', 'dynamic_three_db', '3306', '127.0.0.1', '123456', 'root', 'com.mysql.cj.jdbc.Driver'), ('db_four', 'dynamic_four_db', '3306', '127.0.0.1', '123456', 'root', 'com.mysql.cj.jdbc.Driver');USE dynamic_one_db;CREATE TABLE IF NOT EXISTS user_shopping( `user_id` INT, `platform` VARCHAR(255), `shop_name` VARCHAR(255), `product_name` VARCHAR(255), `price` FLOAT);INSERT INTO user_shopping(`user_id`, `platform`, `shop_name`, `product_name`, `price`)VALUES (1, '淘宝', '**玩具店', '奥特曼', 20.99), (2, '京东', '**书店', '钢铁是怎么练废的', 19.49), (3, '拼多多', '**手机店', '华为 mate plus max 50', 6666.66), (4, '天猫', '**时装店', '旺仔套装', 199.9), (5, '闲鱼', '', '闲置男朋友', 99.99);USE dynamic_two_db;CREATE TABLE IF NOT EXISTS user_qq( `user_id` INT, `account` VARCHAR(255), `password` VARCHAR(255), `create_time` VARCHAR(50), `update_time` VARCHAR(50));INSERT INTO user_qq(`user_id`, `account`, `password`, `create_time`, `update_time`)VALUES (1, '1***1', 'password1', '2021-02-20 20:30:45', '2022-08-16 17:58:11'), (2, '1***2', 'password2', '2021-10-23 05:30:01', '2022-09-01 19:26:35'), (3, '1***3', 'password3', '2021-05-28 14:17:05', '2022-08-31 14:19:59'), (4, '1***4', 'password4', '2020-09-06 18:45:45', '2022-07-01 12:42:33'), (5, '1***5', 'password5', '2018-06-08 19:30:00', '2022-09-02 15:37:27');USE dynamic_three_db;CREATE TABLE IF NOT EXISTS user_love_game( `user_id` INT, `game_name` JSON);INSERT INTO user_love_game(`user_id`, `game_name`)VALUES (1, '{&quot;game1:&quot;: &quot;lol&quot;, &quot;game2&quot;: &quot;dnf&quot;}'), (2, '{&quot;game1:&quot;: &quot;cf&quot;, &quot;game2&quot;: &quot;dnf&quot;}'), (3, '{&quot;game1:&quot;: &quot;lol&quot;, &quot;game2&quot;: &quot;cs&quot;}'), (4, '{&quot;game1:&quot;: &quot;cs&quot;, &quot;game2&quot;: &quot;dnf&quot;}'), (5, '{&quot;game1:&quot;: &quot;cs&quot;, &quot;game2&quot;: &quot;cf&quot;}');USE dynamic_four_db;CREATE TABLE IF NOT EXISTS school( `name` VARCHAR(64) NOT NULL, `school_id` INT NOT NULL, `user_id` INT NOT NULL, `class_name` VARCHAR(64) NOT NULL, `course` TEXT NULL);INSERT INTO school(`name`, `school_id`, `user_id`, `class_name`, `course`)VALUES ('第一中学', 10001, 1, '高一(1)班', '[&quot;Java&quot;,&quot;Python&quot;]'), ('第一中学', 10001, 2, '高二(3)班', '[&quot;C&quot;,&quot;C++&quot;]'), ('第二中学', 10001, 3, '高一(5)班', '[&quot;Linux&quot;,&quot;Scala&quot;]'), ('第二中学', 10001, 4, '高二(7)班', '[&quot;语数英&quot;,&quot;数理化&quot;,&quot;德智体美劳&quot;]'), ('第二中学', 10001, 5, '高三(9)班', '[&quot;大数据&quot;,&quot;人工智能&quot;]');","link":"/posts/b56a.html"},{"title":"Java并发编程实战：第7章 取消和关闭","text":"1. 任务取消1.1 任务取消外部代码，能够将某个操作正常完成之前，将其置入完成状态，那么这个操作就称为可取消的（Cancellable）。 取消操作的原因有很多： 用户请求取消。 有时间限制的操作，如超时设定。 应用程序事件。 错误。 关闭。 1.2 示例：使用 volatile 域，保存取消状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import net.jcip.annotations.GuardedBy;import net.jcip.annotations.ThreadSafe;import java.math.BigInteger;import java.util.ArrayList;import java.util.List;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import static java.util.concurrent.TimeUnit.SECONDS;/** * 生成素数 */@ThreadSafepublic class PrimeGenerator implements Runnable { private static ExecutorService exec = Executors.newCachedThreadPool(); @GuardedBy(&quot;this&quot;) private final List&lt;BigInteger&gt; primes = new ArrayList&lt;&gt;(); private volatile boolean cancelled; @Override public void run() { BigInteger prime = BigInteger.ONE; while (!cancelled) { // 返回大于此 prime 且可能是素数的第一个整数 prime = prime.nextProbablePrime(); synchronized (this) { primes.add(prime); } } } public void cancel() { cancelled = true; } public synchronized List&lt;BigInteger&gt; get() { return new ArrayList&lt;BigInteger&gt;(primes); } /** * 生成【素数】的程序运行一秒钟 * @return 素数 */ static List&lt;BigInteger&gt; aSecondOfPrimes() throws InterruptedException { PrimeGenerator generator = new PrimeGenerator(); exec.execute(generator); try { // 主线程sleep1秒 SECONDS.sleep(1); } finally { // 暂停生成素数的线程 generator.cancel(); } return generator.get(); }} Primecenerator 使用了简单的取消策略：客户端代码通过调用 cancel 请求取消，Primecenerator 每次搜索素数前检查是否有取消请求，当发现取消请求时就退出。 1.3 中断 线程中断 是一种协作机制，线程可以通过这种机制来通知另一个线程，告诉它在某些情况下停止当前工作，并转而执行其他的工作。 每个线程都有一个 boolean 类型的中断状态。当中断线程时，这个线程的中断状态将被设置为 true。 线程的中断方法： 123456789public class Thread { /** 中断这个线程 */ public void interrupt() { ... } /** 获取此线程是否已被中断。线程的中断状态不受此方法的影响。 */ public boolean isInterrupted() { ... } /** 获取当前线程是否被中断。通过该方法清除线程的中断状态。换句话说，如果这个方法被连续调用两次，第二次调用将返回 false */ public static boolean interrupted(){ ... } ......} 调用 interrupt 并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。 中断操作，并不会真正的中断一个正在运行的线程，只是发出了中断请求，线程会在一个合适的时刻中断自己。 1.4 中断策略 中断策略 规定线程如何解释某个 中断请求 取消操作：中断策略 规定 线程级取消操作 或者 服务级取消操作 121. 尽快退出，必要时进行清理2. 通知线程所有者，该线程已经退出 此外还可以建立其他的中断策略，如 暂停 服务、重新开始 服务。 1.5 响应中断在调用可中断的阻塞函数时，有两种实用策略可以处理 InterruptedException 中断异常: 传递异常，使方法成为可中断的阻塞方法。如： 123456789101112public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; { // 将指定元素插入此队列。队列满了，则等待有位置再插入 void put(E e) throws InterruptedException;}public class Thread implements Runnable { // 使当前执行的线程在指定的毫秒数内休眠 public static native void sleep(long millis) throws InterruptedException;}// BlockingQueue.put() 方法和 Thread.sleep() 方法，都传递了异常 ---- InterruptedException// 如果任何线程中断了当前线程。抛出此异常时清除当前线程的中断状态 保存中断状态，上层调用栈中的代码，能够对线程的中断状态进行处理。如： 1234567891011121314public class Thread implements Runnable { // 中断线程，只是将线程状态标记为中断状态，但不会终止线程，线程还会继续执行 public void interrupt() { // ... } // 测试当前线程是否被中断。通过该方法清除线程的中断状态。 public static boolean interrupted() { return currentThread().isInterrupted(true); } // 测试某个线程是否已被中断。根据传递的 ClearInterrupted 的值，是否重置中断状态。 private native boolean isInterrupted(boolean ClearInterrupted);} 1.6 示例：计时运行123456789101112131415public class TimeRun { private static final Integer CORE_POOL_SIZE = 100; private static final ThreadFactory THREAD_FACTORY = Executors.defaultThreadFactory(); private static final ScheduledExecutorService EXEC = new ScheduledThreadPoolExecutor(CORE_POOL_SIZE, THREAD_FACTORY); /** 外部线程中，安排中断 */ public static void timedRun(Runnable runnable, long timeout, TimeUnit unit) { // 获取调用者线程 final Thread task = Thread.currentThread(); // 在一定时间后，将【调用者线程】标记为中断状态 ScheduledFuture&lt;?&gt; schedule = EXEC.schedule(task::interrupt, timeout, unit); // 执行传入的 runnable 线程 EXEC.execute(runnable); }} 在中断线程之前，应该了解它的中断策略。 由于 timedRun 可以从任意一个线程中调用，因此它无法知道这个调用线程的中断策略。例如： 123456789101112131415161718192021222324252627282930import java.util.concurrent.ExecutionException;import java.util.concurrent.Executors;import java.util.concurrent.FutureTask;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.ThreadFactory;import java.util.concurrent.TimeUnit;public class TimedRun0 { public static void main(String[] args) throws InterruptedException { // 创建一个新的 task FutureTask&lt;String&gt; runImpl = new FutureTask&lt;&gt;(new RunImpl(), &quot;runImpl&quot;); // 一定时间后，中断主线程，即 将main线程设为中断状态 TimeRun.timedRun(runImpl, 1, TimeUnit.MILLISECONDS); // 调用者执行自己的逻辑 if (Thread.currentThread().isInterrupted()) { System.out.println(&quot;【main】线程执行了一些逻辑。 ------------------【main】计算结果 = 123&quot;); } else { System.out.println(&quot;【main】线程执行了一些逻辑。 ==================【main】计算结果 = abc&quot;); } }}/** 测试 runnable */class RunImpl implements Runnable { @Override public void run() {}} 结果可能是： 1【main】线程执行了一些逻辑。 ------------------【main】计算结果 = 123 1【main】线程执行了一些逻辑。 ==================【main】计算结果 = abc 1.7 通过 Future 取消任务Future&lt;V&gt; 可以用来和已经提交的任务进行交互。Future&lt;V&gt; 接口定义了如下几个方法： 123456789101112131415161718public interface Future&lt;V&gt; { // 尝试取消执行此任务 boolean cancel(boolean mayInterruptIfRunning); // 如果此任务在正常完成之前被取消，则返回 true boolean isCancelled(); // 如果任务已完成返回 true。 boolean isDone(); // 等待计算完成，然后检索其结果。 V get() throws InterruptedException, ExecutionException; // 如果需要等待最多在给定的时间计算完成，然后检索其结果 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * Created by osys on 2022/08/28 21:48. */public class FutureTest01 { public static void main(String[] args) throws Exception { ExecutorService threadPool = Executors.newSingleThreadExecutor(); // task 需要运行 3 秒 SimpleTask task = new SimpleTask(3_000); Future&lt;Double&gt; future = threadPool.submit(task); threadPool.shutdown(); // 发送关闭线程池的指令 double time = future.get(); System.out.format(&quot;任务运行时间: %.3f s\\n&quot;, time); } private static final class SimpleTask implements Callable&lt;Double&gt; { private final int sleepTime; // ms public SimpleTask(int sleepTime) { this.sleepTime = sleepTime; } @Override public Double call() throws Exception { double begin = System.nanoTime(); Thread.sleep(sleepTime); double end = System.nanoTime(); double time = (end - begin) / 1E9; return time; // 返回任务运行的时间，以 秒 计 } }} 如上，创建了一个 SimpleTask，该 task 运行时会休眠 3000ms，运行总时间会大于3000ms。 测试结果： 1任务运行时间: 3.002 s 在上例基础上，通过 Future.cancel() 取消任务： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.concurrent.Callable;import java.util.concurrent.CancellationException;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * Created by osys on 2022/08/28 21:48. */public class FutureTest02 { public static void main(String[] args) { ExecutorService threadPool = Executors.newSingleThreadExecutor(); // task 需要运行 3 秒 SimpleTask task = new SimpleTask(3_000); Future&lt;Double&gt; future = threadPool.submit(task); // 发送关闭线程池的指令 threadPool.shutdown(); // 在 2 秒之后取消该任务 cancelTask(future, 2_000); try { double time = future.get(); System.out.format(&quot;任务运行时间: %.3f s\\n&quot;, time); } catch (CancellationException ex) { System.err.println(&quot;任务被取消&quot;); } catch (InterruptedException ex) { System.err.println(&quot;当前线程被中断&quot;); } catch (ExecutionException ex) { System.err.println(&quot;任务执行出错&quot;); } } private static void cancelTask(final Future&lt;?&gt; future, final int delay) { Runnable cancellation = () -&gt; { try { Thread.sleep(delay); // 取消与 future 关联的正在运行的任务 future.cancel(true); } catch (InterruptedException ex) { ex.printStackTrace(System.err); } }; new Thread(cancellation).start(); } private static final class SimpleTask implements Callable&lt;Double&gt; { // ms private final int sleepTime; public SimpleTask(int sleepTime) { this.sleepTime = sleepTime; } @Override public Double call() throws Exception { double begin = System.nanoTime(); Thread.sleep(sleepTime); double end = System.nanoTime(); double time = (end - begin) / 1E9; // 返回任务运行的时间，以 秒 计 return time; } }} 这里 task 的运行总时间会大于3000ms的，不过在 2 秒之后取消该任务。运行结果： 1任务被取消 1.8 调用 Future 的 cancel(true) 不一定能取消正在运行的任务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * 判断一个数是否为素数 */public class FutureTest03 { public static void main(String[] args) throws Exception { ExecutorService threadPool = Executors.newSingleThreadExecutor(); long num = 1000000033L; PrimerTask task = new PrimerTask(num); Future&lt;Boolean&gt; future = threadPool.submit(task); threadPool.shutdown(); // get result boolean result = future.get(); System.out.format(&quot;%d 是否为素数？ %b\\n&quot;, num, result); } // 判断一个数是否为素数 private static final class PrimerTask implements Callable&lt;Boolean&gt; { private final long num; public PrimerTask(long num) { this.num = num; } @Override public Boolean call() { double begin = System.nanoTime(); // i &lt; num 让任务有足够的运行时间 for (long i = 2; i &lt; num; i++) { if (num % i == 0) { return false; } } double end = System.nanoTime(); double time = (end - begin) / 1E9; System.out.format(&quot;任务运行时间: %.3f s\\n&quot;, time); return true; } }} Output: 12任务运行时间: 15.033 s1000000033 是否为素数？ true 任务的运行时间，大约是15.033 s 在任务运行到 2 秒的时候调用 Future 的 cancel(true) ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.concurrent.Callable;import java.util.concurrent.CancellationException;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;/** * 判断一个数是否为素数 */public class FutureTest04 { public static void main(String[] args) throws Exception { ExecutorService threadPool = Executors.newSingleThreadExecutor(); long num = 1000000033L; PrimerTask task = new PrimerTask(num); Future&lt;Boolean&gt; future = threadPool.submit(task); // 发送关闭线程池的指令 threadPool.shutdown(); // 在 2 秒之后取消该任务 cancelTask(future, 2_000); try { boolean result = future.get(); System.out.format(&quot;%d 是否为素数？ %b\\n&quot;, num, result); } catch (CancellationException ex) { System.err.println(&quot;任务被取消&quot;); } catch (InterruptedException ex) { System.err.println(&quot;当前线程被中断&quot;); } catch (ExecutionException ex) { System.err.println(&quot;任务执行出错&quot;); } } // 判断一个数是否为素数 private static final class PrimerTask implements Callable&lt;Boolean&gt; { private final long num; public PrimerTask(long num) { this.num = num; } @Override public Boolean call() { double begin = System.nanoTime(); // i &lt; num 让任务有足够的运行时间 for (long i = 2; i &lt; num; i++) { if (num % i == 0) { return false; } } double end = System.nanoTime(); double time = (end - begin) / 1E9; System.out.format(&quot;任务运行时间: %.3f s\\n&quot;, time); return true; } } // 在 delay ms 后取消 task private static void cancelTask(final Future&lt;?&gt; future, final int delay) { Runnable cancellation = () -&gt; { try { Thread.sleep(delay); // 取消与 future 关联的正在运行的任务 future.cancel(true); } catch (InterruptedException ex) { ex.printStackTrace(System.err); } }; new Thread(cancellation).start(); }} Output: 12任务被取消任务运行时间: 18.395 s 可以发现，虽然我们取消了任务，Future 的 get 方法也对我们的取消做出了响应（即抛出 CancellationException 异常），但是任务并没有停止，而是直到任务运行完毕了，程序才结束。 原因： 如上代码 Future 的 get 方法对我们的取消做出了响应： 123catch (CancellationException ex) { System.err.println(&quot;任务被取消&quot;);} 但是任务并没有停止，而是直到任务运行完毕了，程序才结束。 查看一下 FutureTask.cancel() 方法源码： 12345678910111213141516171819202122232425public boolean cancel(boolean mayInterruptIfRunning) { // 任务的运行状态，NEW // 查看当前任务，在内存中偏移量为 stateOffset 位置的值，是否等于 NEW // 如果偏移量为 stateOffset 位置的值等于 NEW，那么将其设置为 INTERRUPTING 或者 CANCELLED if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) // 任务偏移量为stateOffset位置的值 != NEW，且任务状态 != NEW return false; try { if (mayInterruptIfRunning) { try { Thread t = runner; if (t != null) t.interrupt(); } finally { // 查看当前任务在内存中偏移量为 stateOffset 位置的值，将其值设置为 INTERRUPTED UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); } } } finally { finishCompletion(); } return true;} Unsafe.class 中的 compareAndSwapInt()方法和 putOrderedInt()方法： 1234567891011121314public final class Unsafe { /** * 读取传入对象 var1 在内存中偏移量为 var2 位置的值与期望值 var4 作比较。 * 相等就把 var5 值赋值给 var2 位置的值，方法返回true * 不相等，就取消赋值，方法返回false。 */ public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); /**= * 读取传入对象 var1 在内存中偏移量为 var2 位置的值，将其设置为 var4 */ public native void putOrderedInt(Object var1, long var2, int var4);} 从 FutureTask.cancel() 源码可以知道，在运行状态下的任务，如果我们调用 cancel() 方法，传入 true 为参数，那么接下来会调用 interrupt() 方法将线程状态标记为中断状态。 ​ 将线程状态标记为中断状态，但不会终止线程，线程还会继续执行。 1.9 对线程中断做出响应 的任务如上 FutureTest04 ，这里对线程中断作出响应操作 1234567891011121314151617181920212223242526272829private static final class PrimerTask implements Callable&lt;Boolean&gt; { private final long num; public PrimerTask(long num) { this.num = num; } @Override public Boolean call() { double begin = System.nanoTime(); // i &lt; num 让任务有足够的运行时间 for (long i = 2; i &lt; num; i++) { // 在每次进入循环时，进行判断，任务是否被取消 if (Thread.currentThread().isInterrupted()) { System.out.println(&quot;PrimerTask.call() task 被取消 ------- i = &quot; + i); double end = System.nanoTime(); double time = (end - begin) / 1E9; System.out.format(&quot;任务运行时间: %.3f s\\n&quot;, time); return false; } if (num % i == 0) { return false; } } double end = System.nanoTime(); double time = (end - begin) / 1E9; System.out.format(&quot;任务运行时间: %.3f s\\n&quot;, time); return true; }} Output: 123PrimerTask.call() task 被取消 ------- i = 154513461任务运行时间: 2.151 s任务被取消 通过 Thread.currentThread().isInterrupted() 方法，我们可以判断任务是否被取消，从而做出相应的取消任务的响应。 1.10 处理不可中断阻塞 并非所有的可阻塞方法或者阻塞机制都能响应中断。如果一个线程由于 执行同步的Socket I/O 或者 等待获得内置锁 而阻塞，那么中断请求只能设置线程的中断状态，除此之外没有其他任何作用。 由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止这些线程，但这要求我们必须知道线程阻塞的原因： java.io 包中的同步Socket I/O。 InputStream.read() 和 OutputStream.write() 等方法都不会响应中断，通过关闭底层的套接字，可以使得由于执行这些方法的线程被阻塞，抛出一个SocketException。 java.nio 包中的同步I/O。 当中断一个正在 InterruptibleChannel 上等待的线程时，将抛出 ClosedByInterruptException 并关闭链路。 当关闭一个 InterruptibleChannel 时，将导致所有在链路操作上阻塞的线程都抛出 AsynchronousCloseException。 大多数的 Channel 都实现了 InterruptibleChannel。 Selector 的异步I/O。 如果一个线程在调用 Selector.select() 方法时阻塞了，那么调用 close() 或 wakeup() 方法会使线程抛出ClosedSelectorException 并提前返回。 获得锁。 如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断。在 Lock 类中提供了 lockInterruptibly() 方法，该方法允许在等待一个锁的同时仍能响应中断。 1.11 如何封装非标准的取消操作1.11.1 覆写 interrupt 来封裝非标准取消在 Thread 中，通过覆写 interrupt 来封裝非标准取消 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.IOException;import java.io.InputStream;import java.net.Socket;/** * Created by osys on 2022/08/28 21:48. */public class ReaderThread extends Thread { private static final int BUFSZ = 512; private final Socket socket; private final InputStream in; public ReaderThread(Socket socket) throws IOException { this.socket = socket; this.in = socket.getInputStream(); } public void interrupt() { try { socket.close(); } catch (IOException ignored) { } finally { super.interrupt(); } } public void run() { try { byte[] buf = new byte[BUFSZ]; while (true) { int count = in.read(buf); if (count &lt; 0) { break; } else if (count &gt; 0) { processBuffer(buf, count); } } } catch (IOException e) { // 允许线程退出 } } public void processBuffer(byte[] buf, int count) { }} 1.11.2 用 newTaskFor 封装非标准的取消 newTaskFor 是一个工厂方法，它将创建 Future 来代表任务。 newTaskFor 还能返回一个 RunnableFuture 接口，该接口拓展了 Future 和 Runnable (并由FutureTask实现)。 当把一个 Callable 提交给 ExecutorService 时，submit 方法会返回一个 Future，我们可以通过这个 Future 来取消任务。 通过定制表示任务的 Future 可以改变 Future.cancel 的行为。 使用 newTaskFor 封装非标准的取消： 创建一个 Callable Interface 123456789/** * CancellableTask * @param &lt;T&gt; result obj */interface CancellableTask &lt;T&gt; extends Callable&lt;T&gt; { void cancel(); RunnableFuture&lt;T&gt; newTask();} 编写 CancellableTask 实现类 12345678910111213141516171819202122232425262728293031323334public abstract class SocketUsingTask &lt;T&gt; implements CancellableTask&lt;T&gt; { @GuardedBy(&quot;this&quot;) private Socket socket; protected synchronized void setSocket(Socket s) { socket = s; } public synchronized void cancel() { try { if (socket != null) socket.close(); } catch (IOException ignored) { } } /** * 创建一个 RunnableFuture，重写了 FutureTask.cancel() 方法 * @return RunnableFuture */ public RunnableFuture&lt;T&gt; newTask() { return new FutureTask&lt;T&gt;(this) { // 重写 FutureTask 的 cancel() 方法 public boolean cancel(boolean mayInterruptIfRunning) { try { // cancel this SocketUsingTask SocketUsingTask.this.cancel(); } finally { return super.cancel(mayInterruptIfRunning); } } }; }} 该实现类的 RunnableFuture.cancel() 方法，首先关闭当前对象套接字，随后关闭 RunnableFuture 复写一个 Executor，其 newTaskFor() 方法针对 obj 类型进行 return，RunnableFuture 类型返回 SocketUsingTask.newTask() 1234567891011121314151617181920212223242526@ThreadSafeclass CancellingExecutor extends ThreadPoolExecutor { public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue); } public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory); } public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler); } public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); } protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) { if (callable instanceof CancellableTask) { return ((CancellableTask&lt;T&gt;) callable).newTask(); } else { return super.newTaskFor(callable); } }} 2. 停止基于线程的服务2.1 停止基于线程的服务 应用程序通常会创建拥有线程的服务，比如线程池，这些服务的存在时间通常比创建它们的方法存在的时间更长。 线程通过一个 Thread 对象表示，像其它对象一样，线程可以被自由的共享。线程API中并没有关于线程所属权正规的概念。 如果应用程序优雅地退出，这些服务的线程也需要结束。因为没有退出线程惯用的优先方法，它们需要自行结束。 通常我们使用线程池来创建线程和关闭线程。线程池即为线程的拥有者，操作线程、改变优先级等都由线程池来负责。 服务应该提供生命周期方法来关闭自己，并关闭它所拥有的线程。当我们关闭应用程序这个服务时，服务就可以关闭所有的线程了。 ExecutorService 提供了 shutdown()、shutdownNow() 方法，其它持有线程的服务，也应该提供类似的关闭机制。 对于持有线程的服务，主要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。 2.2 示例：日志服务 不支持关闭的生产者-消费者日志服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.PrintWriter;import java.io.Writer;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;/** * Created by osys on 2022/08/28 21:48. */public class LogWriter { private final BlockingQueue&lt;String&gt; queue; private final LoggerThread logger; private static final int CAPACITY = 1000; public LogWriter(Writer writer) { this.queue = new LinkedBlockingQueue&lt;String&gt;(CAPACITY); this.logger = new LoggerThread(writer); } public void start() { logger.start(); } public void log(String msg) throws InterruptedException { queue.put(msg); } /** * 日记线程 class */ private class LoggerThread extends Thread { private final PrintWriter writer; public LoggerThread(Writer writer) { this.writer = new PrintWriter(writer, true); } public void run() { try { while (true) { writer.println(queue.take()); } } catch (InterruptedException ignored) { } finally { writer.close(); } } }} 如上 LogWriter 为一个生产者-消费者模型，日志活动被分离到一个单独的日志线程中。产生消息的线程不会将消息直接写入输出流，而是由 LogWriter 通过 BlockingQueue 把这个任务提交给日志线程，并由日志线程写入。 在正常情况下，如何关闭日志线程？ 取消一个生产者-消费者活动，既要取消生产者，又要取消消费者。 中断日志线程，应着手处理消费者，但是如果消费者和生产者不在同一个线程（如上LogWriter），生产者线程实现一个“检查在运行” 生产者观察是否被关闭服务， 如若关闭服务了，停止消息入队 否则继续消息入队 消费者正常消费消息，如若队列已空(被阻塞)，检查是否关闭了服务。 如果关闭了服务，关闭消费者进程，然后关闭生产者进程 如果未关闭服务，继续等待，直到有消息入队 对于生产者而已，可能会存在，队列已满，消息被阻塞，无法入队。 向日志服务添加不可靠的关闭支持 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.PrintWriter;import java.io.Writer;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;/** * Created by osys on 2022/08/28 21:48. */public class LogWriter2 { private final BlockingQueue&lt;String&gt; queue; private final LoggerThread2 logger; private static final int CAPACITY = 1000; private boolean isShutdownRequested = false; public LogWriter2(Writer writer) { this.queue = new LinkedBlockingQueue&lt;String&gt;(CAPACITY); this.logger = new LoggerThread2(writer); } public void start() { logger.start(); } public void log(String msg) throws InterruptedException { queue.put(msg); if (!isShutdownRequested) { queue.put(msg); } else { throw new IllegalStateException(&quot;logger is shut down&quot;); } } public void setShutdownStatus(boolean status) { this.isShutdownRequested = status; } /** * 日记线程 class */ private class LoggerThread2 extends Thread { private final PrintWriter writer; public LoggerThread2(Writer writer) { this.writer = new PrintWriter(writer, true); } public void run() { try { while (true) { writer.println(queue.take()); } } catch (InterruptedException ignored) { } finally { writer.close(); } } }} 这些不能解决最基本的问题，可能会导致失败，创建新日志消息的各个子任务都必须是原子操作。 向 LogWriter 中添加可靠的取消 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import net.jcip.annotations.GuardedBy;import java.io.PrintWriter;import java.io.Writer;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;/** * Created by osys on 2022/08/28 21:48. */public class LogService { private final BlockingQueue&lt;String&gt; queue; private final LoggerThread loggerThread; private final PrintWriter writer; @GuardedBy(&quot;this&quot;) private boolean isShutdown; @GuardedBy(&quot;this&quot;) private int reservations; public LogService(Writer writer) { this.queue = new LinkedBlockingQueue&lt;String&gt;(); this.loggerThread = new LoggerThread(); this.writer = new PrintWriter(writer); } public void start() { loggerThread.start(); } public void stop() { synchronized (this) { isShutdown = true; } loggerThread.interrupt(); } /** 生产 */ public void log(String msg) throws InterruptedException { synchronized (this) { if (isShutdown) { throw new IllegalStateException(&quot;LogService Is Shut Down&quot;); } ++ reservations; } queue.put(msg); } /** 消费 */ private class LoggerThread extends Thread { public void run() { try { while (true) { try { synchronized (LogService.this) { if (!isShutdown || reservations != 0) { // 队列中存在消息，LogService 未关闭 } else { break; } } // 消费 String msg = queue.take(); synchronized (LogService.this) { --reservations; } writer.println(msg); } catch (InterruptedException e) { } } } finally { writer.close(); } } }} 2.3 关闭 ExecutorService在 ExecutorService 中提供了 shutdown()、shutdownNow() 方法对其进行关闭： 12345678910111213/** * 调用这个方法时，ExecutorService 停止接受任何新的任务 * 且等待已经提交的任务执行完成，当所有已经提交的任务执行完毕后将会关闭ExecutorService * (已经提交的任务会分两类：一类是已经在执行的，另一类是还没有开始执行的) */void shutdown();/** * 调这个方法会强制关闭 ExecutorService， * 它将取消所有运行中的任务和在工作队列中等待的任务， * 这个方法返回一个 List 列表，列表中返回的是等待在工作队列中的任务 */List&lt;Runnable&gt; shutdownNow(); 使用 ExcutorService 的日志服务 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.PrintWriter;import java.io.Writer;import java.util.concurrent.BlockingQueue;import java.util.concurrent.ExecutorService;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.RejectedExecutionException;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class LogService2 { private int THREAD_NUM = 10; private final ExecutorService exec = new ThreadPoolExecutor(THREAD_NUM, THREAD_NUM, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(CAPACITY)); private final long TIMEOUT = 10000; private final TimeUnit UNIT = TimeUnit.MILLISECONDS; private final WriteTask writer; private final BlockingQueue&lt;String&gt; queue; private static final int CAPACITY = 1000; public LogService2(Writer writer) { this.writer = new WriteTask(writer); this.queue = new LinkedBlockingQueue&lt;String&gt;(CAPACITY); } public void start() {} public void stop() throws InterruptedException { try{ exec.shutdown(); exec.awaitTermination(TIMEOUT, UNIT); } finally { writer.close(); } } public void log(String msg) { try{ queue.put(msg); exec.execute(writer); } catch (RejectedExecutionException ignored) { } catch (InterruptedException e) { throw new RuntimeException(e); } } private class WriteTask implements Runnable { private final PrintWriter writer; public WriteTask(Writer writer) { this.writer = (PrintWriter) writer; } public void close() { this.writer.close(); } @Override public void run() { try { while (true) { writer.println(LogService2.this.queue.take()); } } catch (InterruptedException ignored) { } finally { writer.close(); } } }} 2.4 致命药丸致命药丸：一个置于队列中，可识别的对象。 我们可以使用 致命药丸 来关闭生产者-消费者服务。 使用致命药丸来关闭 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import java.io.File;import java.io.FileFilter;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;/** * Created by osys on 2022/08/28 21:48. */public class IndexingService { private static final int CAPACITY = 1000; private static final File POISON = new File(&quot;&quot;); private final IndexerThread consumer = new IndexerThread(); private final CrawlerThread producer = new CrawlerThread(); private final BlockingQueue&lt;File&gt; queue; private final FileFilter fileFilter; private final File root; public IndexingService(File root, final FileFilter fileFilter) { this.root = root; this.queue = new LinkedBlockingQueue&lt;File&gt;(CAPACITY); // 创建一个文件过滤器对象，该 root 下的所有文件，会被生产者以这过滤器为条件，将所有文件使用【文件爬虫】添加到队列中 this.fileFilter = new FileFilter() { /** * 测试指定的抽象路径名是否应包含在路径名列表中 * @param pathname 路径名 * @return true/false */ public boolean accept(File pathname) { return pathname.isDirectory() || fileFilter.accept(pathname); } }; } /** 文件是否已经加入到队列中，false表示未加入 */ private boolean alreadyIndexed(File f) { return false; } public void start() { producer.start(); consumer.start(); } public void stop() { producer.interrupt(); } public void awaitTermination() throws InterruptedException { consumer.join(); } /** * 生产者：文件爬虫 */ class CrawlerThread extends Thread { public void run() { try { // 检索文件 crawl(root); } catch (InterruptedException e) { } finally { while (true) { try { // 将药丸添加到队列中 queue.put(POISON); break; } catch (InterruptedException e1) {} } } } /** * 检索文件 * @param root 文件/目录 */ private void crawl(File root) throws InterruptedException { // 【文件集合 + 文件夹集合】 的 path File[] entries = root.listFiles(fileFilter); // 检索文件 path，并添加到队列中 if (entries != null) { for (File entry : entries) { if (entry.isDirectory()) { crawl(entry); } else if (!alreadyIndexed(entry)) { queue.put(entry); } } } } } /** * 消费者：对检索出来的文件进行处理 */ class IndexerThread extends Thread { /** 对检索出来的文件进行处理，知道遇到【药丸】文件 */ public void run() { try { while (true) { File file = queue.take(); if (file == POISON) break; else indexFile(file); } } catch (InterruptedException consumed) { } } /** 处理文件 */ public void indexFile(File file) { }; }} 2.5 示例：只执行一次的服务如果一个方法需要处理一批任务，并在所有任务结束前不会返回，那么它可以通过使用私有的 Executor 来简化服务的生命周期管理，其中 Executor 的寿命限定在该方法中 (在这种情况下，通常会用到 invokeAll 和 invokeAny 方法）。 invokeAll() 方法 12345678910111213/** * 提交任务集到 ExecutorService，返回所有任务的执行结果。 * 该方法会阻塞，必须等待所有的任务执行完成后统一返回。 * * 如果全部任务在指定的时间内没有完成，则抛出异常。 * @param tasks Collection&lt;? extends Callable&lt;T&gt;&gt; * @param timeout 超时时间 * @param unit 时间单位 * @return 执行后，返回的是 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; 对象 */&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException;&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; invokeAny() 方法 12345/** 提交任务集到 ExecutorService，返回第一个执行完的任务的结果值 */&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException;/** 提交任务集到 ExecutorService，在指定时间内，返回第一个执行完的任务的结果值，否则 Exception */&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; 在多台主机上并行的检查新邮件 使用私有 Executor，将它的寿命限定于一次方法调用中 1234567891011121314151617181920212223242526272829303132333435import java.util.Set;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicBoolean;/** * Created by osys on 2022/08/28 21:48. */public class CheckForMail { public boolean checkMail(Set&lt;String&gt; hosts, long timeout, TimeUnit unit) throws InterruptedException { ExecutorService exec = Executors.newCachedThreadPool(); final AtomicBoolean hasNewMail = new AtomicBoolean(false); try { for (final String host : hosts) { exec.execute(new Runnable() { public void run() { if (checkMail(host)) { hasNewMail.set(true); } } }); } } finally { exec.shutdown(); exec.awaitTermination(timeout, unit); } return hasNewMail.get(); } /** 检查邮件 */ private boolean checkMail(String host) { return false; }} 2.6 shutdownNow() 的局限性123456/** * 调这个方法会强制关闭 ExecutorService， * 它将取消所有运行中的任务和在工作队列中等待的任务， * 这个方法返回一个 List 列表，列表中返回的是等待在工作队列中的任务 */List&lt;Runnable&gt; shutdownNow(); 当通过 shutdownNow 来强行关闭 ExecutorService 时，它会尝试取消正在运行的任务并返回所有已提交但尚未开始的任务。 我们无法通过常规方法来找出哪些任务已经开始但尚未结束。这意味着我们无法在关闭过程中知道正在执行的任务的状态，除非任务本身会执行某种检查。 关闭之后，ExecutorService 获取被取消的任务 TrackingExecutor 中给出了如何在关闭过程中判断正在执行的任务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.ArrayList;import java.util.Collections;import java.util.HashSet;import java.util.List;import java.util.Set;import java.util.concurrent.AbstractExecutorService;import java.util.concurrent.ExecutorService;import java.util.concurrent.TimeUnit;/** * Created by osys on 2022/08/28 21:48. */public class TrackingExecutor extends AbstractExecutorService { private final ExecutorService exec; /** 正在执行，且为完成的 runnable */ private final Set&lt;Runnable&gt; tasksCancelledAtShutdown = Collections.synchronizedSet(new HashSet&lt;Runnable&gt;()); public TrackingExecutor(ExecutorService exec) { this.exec = exec; } public void shutdown() { exec.shutdown(); } public List&lt;Runnable&gt; shutdownNow() { return exec.shutdownNow(); } public boolean isShutdown() { return exec.isShutdown(); } public boolean isTerminated() { return exec.isTerminated(); } public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException { return exec.awaitTermination(timeout, unit); } public List&lt;Runnable&gt; getCancelledTasks() { if (!exec.isTerminated()) { throw new IllegalStateException(&quot;线程池未关闭&quot;); } return new ArrayList&lt;Runnable&gt;(tasksCancelledAtShutdown); } public void execute(final Runnable runnable) { exec.execute(new Runnable() { public void run() { try { runnable.run(); } finally { // 线程池关闭，且当前线程被标志为中断状态，那么将当前线程添加到 set 集合中 if (isShutdown() &amp;&amp; Thread.currentThread().isInterrupted()) { tasksCancelledAtShutdown.add(runnable); } } } }); }} 使用 TrackingExecutorService 为后续执行来保存未完成的任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import net.jcip.annotations.GuardedBy;import java.net.URL;import java.util.ArrayList;import java.util.Collections;import java.util.HashSet;import java.util.List;import java.util.Set;import java.util.concurrent.AbstractExecutorService;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import static java.util.concurrent.TimeUnit.MILLISECONDS;/** * 网络爬虫 */public abstract class WebCrawler { /** 线程池：关闭该线程池，能获得正在执行的线程任务 */ private volatile TrackingExecutor exec; /** 要爬取的 url */ @GuardedBy(&quot;this&quot;) private final Set&lt;URL&gt; urlsToCrawl = new HashSet&lt;URL&gt;(); /** 已经爬取的 */ private final ConcurrentMap&lt;URL, Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;(); private static final long TIMEOUT = 500; private static final TimeUnit UNIT = MILLISECONDS; public WebCrawler(URL startUrl) { urlsToCrawl.add(startUrl); } public synchronized void start() { exec = new TrackingExecutor(Executors.newCachedThreadPool()); for (URL url : urlsToCrawl) { submitCrawlTask(url); } urlsToCrawl.clear(); } /** 关闭线程池，将正在执行的爬虫程序对应的 url 保存起来到【urlsToCrawl】对象中 */ public synchronized void stop() throws InterruptedException { try { saveUnCrawled(exec.shutdownNow()); if (exec.awaitTermination(TIMEOUT, UNIT)) { saveUnCrawled(exec.getCancelledTasks()); } } finally { exec = null; } } private void saveUnCrawled(List&lt;Runnable&gt; unCrawled) { for (Runnable task : unCrawled) { urlsToCrawl.add(((CrawlTask) task).getPage()); } } /** 启动爬虫task，爬取url */ private void submitCrawlTask(URL u) { exec.execute(new CrawlTask(u)); } /** 爬虫 */ private class CrawlTask implements Runnable { private final URL url; CrawlTask(URL url) { this.url = url; } private int count = 1; /** 已经爬取的 url */ boolean alreadyCrawled() { return seen.putIfAbsent(url, true) != null; } void markUnCrawled() { seen.remove(url); System.out.printf(&quot;marking %s unCrawled%n&quot;, url); } /** 爬取 */ public void run() { for (URL link : processPage(url)) { if (Thread.currentThread().isInterrupted()) { return; } submitCrawlTask(link); } } public URL getPage() { return url; } } protected abstract List&lt;URL&gt; processPage(URL url); private class TrackingExecutor extends AbstractExecutorService { private final ExecutorService exec; /** 正在执行，且为完成的 runnable */ private final Set&lt;Runnable&gt; tasksCancelledAtShutdown = Collections.synchronizedSet(new HashSet&lt;Runnable&gt;()); public TrackingExecutor(ExecutorService exec) { this.exec = exec; } public void shutdown() { exec.shutdown(); } public List&lt;Runnable&gt; shutdownNow() { return exec.shutdownNow(); } public boolean isShutdown() { return exec.isShutdown(); } public boolean isTerminated() { return exec.isTerminated(); } public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException { return exec.awaitTermination(timeout, unit); } public List&lt;Runnable&gt; getCancelledTasks() { if (!exec.isTerminated()) { throw new IllegalStateException(&quot;线程池未关闭&quot;); } return new ArrayList&lt;Runnable&gt;(tasksCancelledAtShutdown); } public void execute(final Runnable runnable) { exec.execute(new Runnable() { public void run() { try { runnable.run(); } finally { // 线程池关闭，且当前线程被标志为中断状态，那么将当前线程添加到 set 集合中 if (isShutdown() &amp;&amp; Thread.currentThread().isInterrupted()) { tasksCancelledAtShutdown.add(runnable); } } } }); } }} 3. 处理反常的线程终止3.1 处理反常的线程终止 当并发程序中的某个线程发生故障使控制台中可能会输出栈追踪信息，但是没有人会观察控制台。 此外，当线程发生故障时，应用程序可能看起来仍然在工作，所以这个失败很可能被忽略。 幸运的是，我们有可以监测并防止程序中“遗漏”线程的方法。 导致线程死亡的最主要原因就是RuntimeException。这是 unchecked 异常，程序默认会在控制台输出栈追踪信息，并终止线程。 典型的线程池工作者线程结构： 123456789101112131415public void run(){ Throwable thrown = null; try{ // 线程未中断，运行线程 while(!isInterrupted()) { runTask(getTaskFromWorkueue()); } } catch (Throwable e) { // 捕获异常 thrown = e; } finally { // 终止线程 threadExited(this, throw); }} 3.2 未捕获异常的处理Thread api 中同样提供了 UncaughtExceptionHandler ，它能检测出某个线程由于未捕获的异常而终结的情况。 12345678910/** * 当线程由于未捕获的异常，而突然终止时，调用的处理程序接口。 */@FunctionalInterfacepublic interface UncaughtExceptionHandler { /** * 由于给定的线程，未捕获异常而终止时调用的方法。 */ void uncaughtException(Thread t, Throwable e);} 当一个线程由于未捕获异常而退出时，JVM 会把这个事件报告给应用程序提供的 UncaughtExceptionHandler 异常处理器。如果没有提供任何异常处理器，那么默认的行为是将栈追踪信息输出到 System.err。 异常处理器如何处理未捕获异常，取决于对服务质量的需求。最常见的响应方式是将一个错误信息以及相应的栈追踪信息写入应用程序日志中。 123456789101112import java.util.logging.Level;import java.util.logging.Logger;/** * Created by osys on 2022/08/28 21:48. */public class UEHLogger implements Thread.UncaughtExceptionHandler { public void uncaughtException(Thread thread, Throwable throwable) { Logger logger = Logger.getAnonymousLogger(); logger.log(Level.SEVERE, &quot;线程异常终止: &quot; + thread.getName(), throwable); }} 在运行时间较长的应用程序中，通常会为所有线程的未捕获异常指定同一个异常处理器，并且该处理器至少会将异常信息记录到日志中。 要为线程池中的所有线程设置一个 UncaughtExceptionHandler，需要为 ThreadPoolExecutor 的构造函数提供一个 ThreadFactory。 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {} 标准线程池允许当发生未捕获异常时结束线程，但由于使用了一个 try-finally 代码来接收通知，因此当线程结束时，将有新的线程来代替它。 ​ 如果没有提供捕获异常处理器或者其他的故障通知机制，那么任务会悄悄失败，从而导致极大的混乱。 如果你希望在任务由于发送异常而失败时获得通知并且执行一些特定于任务的恢复操作，那么可以将任务封装在能捕获异常的 Runnable 或 Callable 中，或者改写 ThreadPoolExecutor.afterExecute() 方法。 1protected void afterExecute(Runnable r, Throwable t) { } 只有通过 execute() 提交的任务，才能将它抛出的异常交给未捕获异常处理器，而通过 submit() 提交的任务，会被封装成ExecutionException 抛出。 123456/** * 在未来的某个时间执行给定的任务。 * 该任务可以在新线程或现有池线程中执行。 * 如果任务无法提交执行，要么是因为这个执行器已经关闭，要么是因为它的容量已经达到，任务由当前的RejectedExecutionHandler处理。 */public void execute(Runnable command) {} ThreadPoolExecutor 重写了父接口 Executor 的 execute() 方法。而 submit() 方法是父接口 AbstractExecutorService 的，且 ThreadPoolExecutor 未将其重写并交予RejectedExecutionHandler处理。 4. JVM关闭4.1 JVM 关闭 JVM既可以正常关闭也可以强行关闭。 正常关闭的触发方式有多种，包括：当最后一个“非守护“线程结束时，或者调用System.exit时，或者通过其他特定平台的方法关闭时(如：Crtl+C、发送signet信号 等) 4.2 关闭钩子关闭钩子：是指通过 Runtime.addShutdownHook 注册的但尚未开始的线程。 在正常关闭中，JVM首先调用所有已注册的关闭钩子(Shutdown hook)。 JVM并不能保证关闭钩子的调用顺序。 在关闭应用程序线程中，如果线程仍然在运行，那么这些线程接下来和关闭进程并发执行。 如果 runFinalizerOnExit 为 true。那么JVM将运行终结器，然后再停止。 JVM并不会停止或中断任何在关闭时仍然运行的应用程序线程。当JVM最终结束时，这些线程将被强行结束。 如果关闭钩子或终结器没有执行完成，那么正常关闭进程“挂起”并且JVM必须被强行关闭。 当强行关闭时，只是关闭JVM，而不会运行关闭钩子。 关闭钩子应该是线程安全的： 它们在访问共享数据时必须使用同步机制，并且小心的避免死锁，这和其他并发代码的要求相同。 而且，关闭钩子不应该对应用程序的状态或者JVM的关闭原因作出任何假设。 最后，关闭钩子应该尽快退出，因为它们会延迟JVM的结束时间，而用户可能希望JVM尽快终止。 关闭钩子可以用于实现服务或应用程序的清理工作，例如清理临时文件。 由于关闭钩子将并发执行，因此在关闭日志文件时可能导致其他需要日志服务的关闭钩子产生问题。实现这种功能的一种方式是对所有服务使用同一个关闭钩子，并且在关闭钩子中执行一系列的关闭操作。 注册关闭钩子来停止日志服务 1234567891011public void start(){ Runtime.getRuntime().addShutdownHook(new Thread(){ public void run(){ try{ LogService.this.stop(); } catch(InterruptedException ignored){ } } }} 4.3 守护线程 线程分为两种：普通线程 和 守护线程。 在JVM启动时创建的所有线程中，除了主线程，其他都是守护线程(例如GC等)。 普通线程和守护线程的差异仅仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，JVM会正常退出操作，当JVM停止时，所有仍然存在的守护线程都将被抛弃 —- 既不会执行 finally 代码块，也不会执行回卷栈，而JVM只是直接退出。 此外，守护线程通常不能用来代替应用程序管理程序中各个服务的生命周期。 4.4 终结器 Finalize 当不再需要内存资源时，可以通过GC来回收他们，但对于其他一些资源，例如文件句柄或套接字句柄，必须显式的还给操作系统。 为了实现这个功能，垃圾回收器对那些定义了 finalize() 方法的对象会进行特殊处理：在回收器释放它们后，调用它们的 finalize 方法，从而保证一些持久化资源被释放。 123public class Object { protected void finalize() throws Throwable { }} 由于 终结器 可以在某个由JVM管理的线程中运行因此终结器访问的任何状态都可能被多个线程访问，这样就必须对其访问操作进行同步。 在大多数情况下，通过 finally 代码块 和 显式的 close() 方法，能够比使用终结器更好的管理资源。唯一的例外是：当需要管理对象，并且该对象持有的资源是通过本地方法获得的。 避免使用终结器。","link":"/posts/3df5.html"}],"tags":[{"name":"Java并发编程","slug":"Java并发编程","link":"/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"项目案例","slug":"项目案例","link":"/categories/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/"}]}