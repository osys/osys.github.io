<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java并发编程实战：第14章 构建自定义的同步工具 - LeeHua&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="LeeHua&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/osys/cloud@master/img/basic/favicon512.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LeeHua&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="1. 管理状态依赖性1.1 管理状态依赖性 状态依赖性指某种操作必须依赖于指定的状态才可以执行。比如一个阻塞队列的take方法依赖于这个阻塞队列中有至少一个元素这个状态。 如果一个状态依赖性操作所依赖的状态不满足，通常有几种处理办法： 抛出异常 使用某种约定的错误返回值"><meta property="og:type" content="blog"><meta property="og:title" content="Java并发编程实战：第14章 构建自定义的同步工具"><meta property="og:url" content="https://osys.github.io/"><meta property="og:site_name" content="Osys&#039;s Blog"><meta property="og:description" content="1. 管理状态依赖性1.1 管理状态依赖性 状态依赖性指某种操作必须依赖于指定的状态才可以执行。比如一个阻塞队列的take方法依赖于这个阻塞队列中有至少一个元素这个状态。 如果一个状态依赖性操作所依赖的状态不满足，通常有几种处理办法： 抛出异常 使用某种约定的错误返回值"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://osys.github.io/img/og_image.png"><meta property="article:published_time" content="2022-08-29T14:21:07.000Z"><meta property="article:modified_time" content="2022-08-29T14:40:44.000Z"><meta property="article:author" content="Osys"><meta property="article:tag" content="Java并发编程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://osys.github.io/"},"headline":"LeeHua's Blog","image":["https://osys.github.io/img/og_image.png"],"datePublished":"2022-08-29T14:21:07.000Z","dateModified":"2022-08-29T14:40:44.000Z","author":{"@type":"Person","name":"Osys"},"publisher":{"@type":"Organization","name":"Osys","logo":{"@type":"ImageObject","url":"https://cdn.jsdelivr.net/gh/osys/cloud@master/img/basic/favicon512.png"}},"description":"一路生花"}</script><link rel="canonical" href="https://osys.github.io/posts/d3e0.html"><link rel="alternate" href="/path/to/atom.xml" title="LeeHua&#039;s Blog" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/osys/cloud@master/img/basic/favicon512.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?44cd31785e14a1fdaad0921651759e0f";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.0.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/osys/cloud@master/img/basic/favicon512.png" alt="LeeHua&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-08-29T14:21:07.000Z" title="8/29/2022, 2:21:07 PM">2022年08月29日</time>发表</span><span class="level-item"><time dateTime="2022-08-29T14:40:44.000Z" title="8/29/2022, 2:40:44 PM">2022年08月29日</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">39 分钟读完 (大约5784个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Java并发编程实战：第14章 构建自定义的同步工具</h1><div class="content"><h1 id="1-管理状态依赖性"><a href="#1-管理状态依赖性" class="headerlink" title="1. 管理状态依赖性"></a>1. 管理状态依赖性</h1><h2 id="1-1-管理状态依赖性"><a href="#1-1-管理状态依赖性" class="headerlink" title="1.1 管理状态依赖性"></a>1.1 管理状态依赖性</h2><ul>
<li>状态依赖性指某种操作必须依赖于指定的状态才可以执行。比如一个阻塞队列的<code>take</code>方法依赖于这个阻塞队列中有至少一个元素这个状态。</li>
<li>如果一个状态依赖性操作所依赖的状态不满足，通常有几种处理办法：<ol>
<li>抛出异常</li>
<li>使用某种约定的错误返回值<span id="more"></span></li>
<li>阻塞，直到依赖的状态被满足</li>
</ol>
</li>
</ul>
<blockquote>
<p>状态依赖的可阻塞行为结构</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">blockingAction</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 请求 依赖的状态 锁</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依赖条件不成立</span></span><br><span class="line">    <span class="keyword">while</span> (不成立的条件) &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 直到依赖条件成立。如果中断或超时过期，则可选失败</span></span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 请求锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者-消费者的设计经常会使用 ArrayBlockingQueue 这种有限缓存。一个有限缓存提供的 put 和 take 操作，每一个都有先验条件：不能从空缓存中获取元素，也不能把元素置入已满的緩存中。如果依赖于状态的操作在处理先验条件时失败，可以抛出异常或者返回错误状态（把问题留给调用者)，也可以保持阻塞直到对象转入正确的状态。</p>
<blockquote>
<p>示例：有限缓存的实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jcip.annotations.GuardedBy;</span><br><span class="line"><span class="keyword">import</span> net.jcip.annotations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseBoundedBuffer</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V[] buf;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">BaseBoundedBuffer</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.buf = (V[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doPut</span><span class="params">(V v)</span> &#123;</span><br><span class="line">        buf[tail] = v;</span><br><span class="line">        <span class="keyword">if</span> (++tail == buf.length) &#123;</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> V <span class="title function_">doTake</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> buf[head];</span><br><span class="line">        buf[head] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++head == buf.length) &#123;</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= buf.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-将先验条件失败传给调用者"><a href="#1-2-将先验条件失败传给调用者" class="headerlink" title="1.2 将先验条件失败传给调用者"></a>1.2 将先验条件失败传给调用者</h2><blockquote>
<p>如果有缓存不满足先验条件，会停滞不前</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jcip.annotations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrumpyBoundedBuffer</span> &lt;V&gt; <span class="keyword">extends</span> <span class="title class_">BaseBoundedBuffer</span>&lt;V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GrumpyBoundedBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GrumpyBoundedBuffer</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> BufferFullException &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferFullException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        doPut(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> BufferEmptyException &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BufferEmptyException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doTake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferFullException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferEmptyException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果向 GrumpyBoundedBuffer 中添加、拿取元素，GrumpyBoundedBuffer 已经满了、没有元素，那么将抛出 RuntimeException。</p>
<blockquote>
<p>调用 GrumpyBoundedBuffer</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrumpyBoundedBufferDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> GrumpyBoundedBuffer&lt;String&gt; buffer;</span><br><span class="line">    <span class="type">int</span> <span class="variable">SLEEP_GRANULARITY</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useBuffer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> buffer.take();</span><br><span class="line">                <span class="comment">// ... ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BufferEmptyException e) &#123;</span><br><span class="line">                Thread.sleep(SLEEP_GRANULARITY);</span><br><span class="line">                <span class="comment">// 建议使用：Thread.yield() 向调度程序提示当前线程愿意放弃其当前对处理器的使用。而不占用CPU</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 GrumpyBoundedBuffer 中没有元素，那么 sleep，循环等待有元素可用。</p>
<h2 id="1-3-利用-“轮询加休眠”-实现拙劣的阻塞"><a href="#1-3-利用-“轮询加休眠”-实现拙劣的阻塞" class="headerlink" title="1.3 利用 “轮询加休眠” 实现拙劣的阻塞"></a>1.3 利用 “轮询加休眠” 实现拙劣的阻塞</h2><blockquote>
<p>有限缓存使用了拙劣的阻塞</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jcip.annotations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepyBoundedBuffer</span> &lt;V&gt; <span class="keyword">extends</span> <span class="title class_">BaseBoundedBuffer</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">SLEEP_GRANULARITY</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SleepyBoundedBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SleepyBoundedBuffer</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isFull()) &#123;</span><br><span class="line">                    doPut(v);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(SLEEP_GRANULARITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> doTake();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(SLEEP_GRANULARITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SleepyBoundedBuffer 与 GrumpyBoundedBuffer 不同的是，在 put 和 take 操作时，使用轮询+休眠的方式，直到满足条件。</p>
<p>像大多数行为良好的阻塞库的方法一样，SleepyBoundedBuffer 通过中断支持取消，如果被中断，它会提前返回，并抛出 InterruptedException。</p>
<h2 id="1-4-使用条件队列解决拙劣的阻塞"><a href="#1-4-使用条件队列解决拙劣的阻塞" class="headerlink" title="1.4 使用条件队列解决拙劣的阻塞"></a>1.4 使用条件队列解决拙劣的阻塞</h2><p>条件队列可以让一组线程(等特集)，以某种方式等待相关条件变成真。不同于传统的队列，它们的元素是数据项：条件队列的元素是等待相关条件的线程。</p>
<blockquote>
<p>有限缓存使用条件队列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jcip.annotations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedBuffer</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">BaseBoundedBuffer</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BoundedBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BoundedBuffer</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        doPut(v);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (isEmpty()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> doTake();</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">alternatePut</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull()) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasEmpty</span> <span class="operator">=</span> isEmpty();</span><br><span class="line">        doPut(v);</span><br><span class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了超类 Object 中的 wait()、notify()、notifyAll()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使当前线程等待，直到另一个线程为此对象调用notify()方法或notifyAll()方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒正在此对象的监视器上等待的单个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒正在此对象的监视器上等待的所有线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h1 id="2-使用条件队列"><a href="#2-使用条件队列" class="headerlink" title="2. 使用条件队列"></a>2. 使用条件队列</h1><p>条件队列让构建有效且响应的状态依赖类变得更容易，但是使用时比较容易出错。应该尽量构建在像 LinkedBlockingQueue、Latch、Semaphore 和 FutureTask 基础之上。</p>
<h2 id="2-1-条件谓词"><a href="#2-1-条件谓词" class="headerlink" title="2.1 条件谓词"></a>2.1 条件谓词</h2><ul>
<li><p>条件调词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系。</p>
</li>
<li><p>在有限缓存中，只有缓存不为空时 take 才能执行，否则它必须等待。就 take 而言，它的条件谓词是“绶存不空”，take 执行前必须先测试。类似地，put 的条件谓词是“缓存不满”。</p>
</li>
<li><p>在条件等待中存在一种重要的三元关系，包括：加锁、wait() 方法、条件谓词</p>
</li>
</ul>
<p>每次调用 wait 都会您式地与特定的永什调调相关联。当调用特定条件谓词的 wait 时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量。</p>
<h2 id="2-2-过早地唤醒"><a href="#2-2-过早地唤醒" class="headerlink" title="2.2 过早地唤醒"></a>2.2 过早地唤醒</h2><p>当线程A调用到 wait() 代码后，其它线程在此期间插足了 —- 获取了锁，并且修改了数据。那么线程A获取锁后，需要重新检查条件谓词。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 条件谓词：isFull()</span></span><br><span class="line">    <span class="keyword">while</span> (isFull()) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    doPut(v);</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 条件谓词：isEmpty()</span></span><br><span class="line">    <span class="keyword">while</span> (isEmpty()) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> doTake();</span><br><span class="line">    notifyAll();</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【线程A】调用空缓存中的 take()，不满足条件（绶存不空），于是调用 wait() 使当前线程等待。</p>
<p>【线程B】调用该空缓存中的 put()，满足条件（缓存不满），于是将一个元素放入缓存，并且调用 notifyAll()，唤醒【线程A】。</p>
<p>【线程A】此时需要再次检查条件谓词是否满足。</p>
<p>不过有的时候，我们可能根本不知道哪个方法调用了 notify() 或 notifyAll()，唤醒正在 wait() 的线程。如果被唤醒的线程去检查条件谓词，还不能满足条件，就又要继续等待。</p>
<blockquote>
<p>状态依赖方法的规范式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">stateDependentMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 条件谓词必须被锁守护</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;  </span><br><span class="line">        <span class="keyword">while</span> (!conditionPredicate()) &#123;</span><br><span class="line">            lock.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 现在，对象处于期望的状态中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p>当使用条件等待时(Object.wait 或者 Condition.await)</p>
<ul>
<li>永远设置一个条件谓词 —- 一些对象状态的测试，线程执行前必须满足它；</li>
<li>永远在调用 wait 前测试条件谓词，并且从 wait 中返回后再次测试；</li>
<li>永远在循环中调用 wait；</li>
<li>确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的；</li>
<li>当调用 wait、 notify 或者 notifyAll 时，要持有与条件队列相关联的锁；并且在检查条件谓词之后、开始执行被保护的逻辑之前，不要释放锁。</li>
</ul>
<h2 id="2-3-丢失的信号"><a href="#2-3-丢失的信号" class="headerlink" title="2.3 丢失的信号"></a>2.3 丢失的信号</h2><p>保证 <code>notify()</code> 一定在 <code>wait()</code> 之后。</p>
<h2 id="2-4-通知"><a href="#2-4-通知" class="headerlink" title="2.4 通知"></a>2.4 通知</h2><ul>
<li><p>在有限缓存中，在绶存变为非空时，为了能够让 take 解除阻塞，我们必须确保每一条能够让缓存变为非空的代码路径都执行一个通知。</p>
<p>  例如：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">alternatePut</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">while</span> (isFull()) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasEmpty</span> <span class="operator">=</span> isEmpty();</span><br><span class="line">    doPut(v);</span><br><span class="line">    <span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  向有限缓存中添加一个元素，在最后调用 notifyAll() 通知正在 wait() 的线程。</p>
</li>
<li><p>对于 notify() 和 notifyAll() 无论调用哪一个，都必须持有与条件队列对象相关联的锁。</p>
<ul>
<li>调用 notify() 的结果是：JVM 会从在这个条件队列中等待的众多线程中挑选出一个，并把它唤醒。</li>
<li>而调用 notifyAll() 会唤醒所有正在这个条件队列中等待的线程。</li>
<li>由于调用 notify() 和 notifyAll() 时必须持有条件队列对象的锁，这导致等待线程此时不能重新获得锁，无法从 wait() 返回，因此该通知线程应该尽快释放锁，以确保等待线程尽可能快地解除阻塞。</li>
</ul>
</li>
<li><p>推荐使用 notifyAll()，因为多个线程可能会由于不同的原因在同一个条件队列中等待，调用 notifyAll() 会唤醒所有，而调用 notify() 只会由 JVM 挑选一个唤醒。</p>
</li>
</ul>
<h2 id="2-5-阀门类"><a href="#2-5-阀门类" class="headerlink" title="2.5 阀门类"></a>2.5 阀门类</h2><blockquote>
<p>开始阀门闭锁(starting gate latch)</p>
</blockquote>
<p>二元闭锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在时序测试中，使用 CountDownLatch 来启动和停止线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CountDownLatch.class ---- 利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHarness</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 CountDownLatch 来启动和停止线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nThreads 要启动的线程数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task 线程任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 线程等待，释放时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException 当线程等待、休眠或以其他方式被占用，并且线程在活动之前或期间被中断时抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">timeTasks</span><span class="params">(<span class="type">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 在线程可以通过await()方法之前，计数值为1，需调用countDown()方法的次数为1次</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">startGate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 在线程可以通过await()方法之前，计数值为 nThreads，需调用countDown()方法的次数为 nThreads 次</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">endGate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(nThreads);</span><br><span class="line">        <span class="comment">// 通过await()方法需满足：锁计数器为0、线程被中断、或者超过指定的等待时间</span></span><br><span class="line">        <span class="comment">// 每调用countDown()方法，计数器减1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">aThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 线程等待</span></span><br><span class="line">                        startGate.await();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 启动线程</span></span><br><span class="line">                            task.run();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// 减少锁存器的计数，如果计数达到零，则释放所有等待线程</span></span><br><span class="line">                            endGate.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            aThread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">// startGate 锁计数器(原本定义为1)，现在调用 countDown() 方法，减去1</span></span><br><span class="line">        <span class="comment">// 此时，startGate 的锁计数器为0，可以通过 await() 方法了</span></span><br><span class="line">        <span class="comment">// 因此就可以到达 task.run()</span></span><br><span class="line">        startGate.countDown();</span><br><span class="line">        <span class="comment">// endGate 锁计数器原本定义为nThreads，也就是线程个数。</span></span><br><span class="line">        <span class="comment">// 程序未出现异常情况，需要调用 countDown() 方法 nThreads 次</span></span><br><span class="line">        <span class="comment">// endGate.countDown() 方法在每个线程的 finally &#123;...&#125; 中</span></span><br><span class="line">        <span class="comment">// 因此需要 nThreads 个线程都完成，才能使得 锁计数器=0，这个时候才能通过 endGate.await() 方法</span></span><br><span class="line">        endGate.await();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过将计数器初始化为1，创建了一个二元闭锁：它只有两种状态，初始状态和终止状态。闭锁会阻止线程通过开始阀门，直到阀门被打开，此时所有的线程都可以通过。</p>
<blockquote>
<p>使用 wait 和 notifyAll 实现可重关闭的阀门</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jcip.annotations.GuardedBy;</span><br><span class="line"><span class="keyword">import</span> net.jcip.annotations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadGate</span> &#123;</span><br><span class="line">    <span class="comment">// 条件谓词: opened-since(n) (isOpen || generation&gt;n)</span></span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isOpen;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;this&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> generation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        isOpen = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        ++generation;</span><br><span class="line">        isOpen = <span class="literal">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，直到: opened-since(generation on entry)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrivalGeneration</span> <span class="operator">=</span> generation;</span><br><span class="line">        <span class="keyword">while</span> (!isOpen &amp;&amp; arrivalGeneration == generation) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-6-显式的-Condition-对象"><a href="#2-6-显式的-Condition-对象" class="headerlink" title="2.6 显式的 Condition 对象"></a>2.6 显式的 Condition 对象</h2><p>Lock 是一个广义的内置锁，而 Condition 也是一种广义的 <strong>内置条件队列</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">  	<span class="comment">/** 使当前线程等待，直到它发出信号或被中断。 */</span></span><br><span class="line">  	<span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 使当前线程一直等待，直到它发出信号或中断，或者指定的等待时间过去。 */</span></span><br><span class="line">  	<span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 使当前线程一直等待，直到它发出信号或中断，或者指定的等待时间过去。 */</span></span><br><span class="line">  	<span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 导致当前线程等待，直到它发出信号。 */</span></span><br><span class="line">  	<span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 使当前线程等待，直到它发出信号或中断，或指定的截止日期过去。 */</span></span><br><span class="line">  	<span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**  唤醒一个等待线程。*/</span></span><br><span class="line">  	<span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 唤醒所有等待的线程。 */</span></span><br><span class="line">  	<span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>内部条件队列有一些缺陷。每个内部锁只能有一个与之相关联的条件队列，多个线程可能为了不同的条件谓词在同一个条件队列中等待，而且大多数常见的锁模式都会暴露条件队列对象。这些因素都导致不可能为了使用notifyAll()，而强迫等待线程统一。</li>
<li>如果想编写一个带有多个条件谓词的并发对象，或者想获得除了条件队列可见性之外的更多的控制权，可以使用Lock和Condition，而不是内置锁和内置条件队列。</li>
<li>一个 Conaition 和一个单独的 Lock 相关联，就像条件队列和单独的内部锁相关联一样；调用与 Condition 相关联的 Lock 的 Lock.newConaition() 方法，可以创建一个 Conaition。如同 Lock 提供了比内部加锁要丰富得多的特征集一样，Condition 也提供了比内部条件队列要丰富得多的特征集：每个锁可以有多个等待集、可中断&#x2F;不可中断的条件等待、基于时限的等待以及公平&#x2F;非公平队列之间的选择。</li>
<li>不同于内部条件队列，你可以让每个 Lock 都有任意数量的 Condition 对象。</li>
</ul>
<blockquote>
<p>警告: Object 的 wait()、notify() 和notifyAll()方法在 Conaition 中的对等体是 await()、 signal() 和 BignalAll()。</p>
<p>但是 Condition 继承自 Object，这意味着它也有 wait() 和 notify() 方法。</p>
<p>一定要确保使用了正确的版本 —- await() 和 signal()</p>
</blockquote>
<p>有限缓存使用显式的条件变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jcip.annotations.GuardedBy;</span><br><span class="line"><span class="keyword">import</span> net.jcip.annotations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionBoundedBuffer</span> &lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条件谓词: notFull (count &lt; items.length)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 条件谓词: notEmpty (count &gt; 0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;lock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[BUFFER_SIZE];</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;lock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> tail, head, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，直到: notFull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            items[tail] = x;</span><br><span class="line">            <span class="keyword">if</span> (++tail == items.length) &#123;</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞直到: notEmpty</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">T</span> <span class="variable">x</span> <span class="operator">=</span> items[head];</span><br><span class="line">            items[head] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (++head == items.length) &#123;</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Condition 简化了使用单一通知的条件。使用更有效的 signal()，而不是 signalAll()，这就会减少相当数量的上下文转换，而且每次缓存操作都会触发对锁的请求。</p>
<h1 id="3-剖析-Synchronizer"><a href="#3-剖析-Synchronizer" class="headerlink" title="3. 剖析 Synchronizer"></a>3. 剖析 Synchronizer</h1><ul>
<li><p>ReentrantLock 和 Semaphore 有很多共同点。这些类都扮演了“阀门”的角色，每次只允许有限数目的线程通过它。</p>
</li>
<li><p>线程到达阀门后</p>
<ul>
<li>可以允许通过：ReentrantLock.lock()、Semaphore.acquire()</li>
<li>可以等待：lock()方法 或 acquire() 方法阻塞</li>
<li>可以取消：ReentrantLock.tryLock()、Semaphore.tayAcquire() 返回 false，指明在允许的时间内，【锁】或者【许可】不可用</li>
</ul>
</li>
<li><p>它们都允许可中断的、不可中断的、可限时的请求尝试，它们也都允许选择公平、非公平的等待线程队列。</p>
</li>
<li><p>其实，ReentrantLock 和 Semaphore 都用到了同一个共同的基类：AbstractQueuedSynchronizer</p>
</li>
<li><p>AbstractQueuedSynchronizer(AQS) 和其它很多的 Synchronizer 一样，AQS 是一个用来构建锁和 Synchronizer 的框架。</p>
</li>
<li><p>CountDownLatch、ReentrantReadWriteLock 和 FutureTask 都是基于 AQS 构建的。</p>
</li>
</ul>
<blockquote>
<p>使用 Lock 实现的计数信号量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jcip.annotations.GuardedBy;</span><br><span class="line"><span class="keyword">import</span> net.jcip.annotations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreOnLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条件谓词: permitsAvailable (permits &gt; 0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">permitsAvailable</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="meta">@GuardedBy(&quot;lock&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> permits;</span><br><span class="line"></span><br><span class="line">    SemaphoreOnLock(<span class="type">int</span> initialPermits) &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            permits = initialPermits;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，直到: permitsAvailable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (permits &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                permitsAvailable.await();</span><br><span class="line">            &#125;</span><br><span class="line">            --permits;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ++permits;</span><br><span class="line">            permitsAvailable.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 SemaphoreonLock 中，请求许可的操作在两个地方可能会阻塞</p>
<ul>
<li>信号量的状态正在被锁保护着</li>
<li>许可不可用</li>
</ul>
<p>AQS 解决了实现一个 Synchronizer 的大量细节，比如等待线程的 FIFO(First Input, First Output) 队列。单独的 Synchronizer 可以定义一个灵活的标准，用来描述线程是否应该允许通过，还是需要等待。</p>
<p>使用 AQS 构建的 Synchronizer 只可能在一个点上发生阻塞，这样降低了上下文切换的开销，并提高了吞吐量。</p>
<h1 id="4-AbstractQueuedSynchronizer"><a href="#4-AbstractQueuedSynchronizer" class="headerlink" title="4. AbstractQueuedSynchronizer"></a>4. AbstractQueuedSynchronizer</h1><h2 id="4-1-AbstractQueuedSynchronizer"><a href="#4-1-AbstractQueuedSynchronizer" class="headerlink" title="4.1 AbstractQueuedSynchronizer"></a>4.1 AbstractQueuedSynchronizer</h2><ul>
<li><p>一个基于 AQS 的 synchronizer 所执行的基本操作，是一些不同形式的获取(acquire） 和释放（release）。</p>
</li>
<li><p>AQS 管理着一个广域状态信息的单一整数，状态信息可以通过 getState()、setState()、compareAndSetState()等方法进行操作</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回同步状态的当前值。此操作具有volatile读取的内存语义</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置同步状态的值。此操作具有volatile写入的内存语义</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值。此操作具有volatile读写的内存语义</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ReentrantLock 用它来表现拥有它的线程已经请求了多少次锁</li>
<li>Semaphore 用它来表现剩余的许可数</li>
<li>Futurerask 用它来表现任务的状态（尚未开始、运行、完成和取消）</li>
</ul>
</li>
<li><p>AQS中获取和释放操作的规范式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">while</span> (状态不允许获取) &#123;</span><br><span class="line">        <span class="keyword">if</span> (阻止获取请求) &#123;</span><br><span class="line">            如果尚未排队阻塞当前线程，</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            否则则将当前线程入队</span><br><span class="line">      		<span class="keyword">return</span> failure</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	可能更新同步状态</span><br><span class="line">	如果线程已排队，则使线程出队</span><br><span class="line">  	<span class="keyword">return</span> success</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">  	更新同步状态</span><br><span class="line">  	<span class="keyword">if</span> (新状态可能允许被阻塞的线程获取) &#123;</span><br><span class="line">        解除阻塞一个或多个排队线程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  一个获取操作分为两步。第一步，Synchronizer 判断当前状态是否允许被获得：如果是，就让线程执行，如果不是，获取操作阻塞或失败。第二步包括了可能需要更新的状态；一个想获取 synchronizer 的线程会影响到其他线程是否能够获取它。</p>
</li>
<li><p>一个简单的闭锁</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.jcip.annotations.ThreadSafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneShotLatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> ignored)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果闭锁打开(state == 1)则成功，否则失败</span></span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">1</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> ignored)</span> &#123;</span><br><span class="line">            setState(<span class="number">1</span>); <span class="comment">// 闭锁现已打开</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 其他线程现在可能能够获取</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-2-ReentrantLock"><a href="#4-2-ReentrantLock" class="headerlink" title="4.2 ReentrantLock"></a>4.2 ReentrantLock</h2><p>ReentrantLock 只支持独占的获取操作，因此它实现了 tryAcquire()、 tryRelease() 和 isHeldExclusively()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="comment">// 执行不公平的 tryLock</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试设置状态以反映独占模式下的发布</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果同步仅针对当前（调用）线程进行，则返回true </span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>非公平的 ReentrantLock 中 tryAcquire 的实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 同步状态的当前值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 设置当前拥有独占访问权限的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最后由setExclusiveOwnerThread设置的线程，如果从未设置，则返回null </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置同步状态的值</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3-Semaphore-和-CountDownLatch"><a href="#4-3-Semaphore-和-CountDownLatch" class="headerlink" title="4.3 Semaphore 和 CountDownLatch"></a>4.3 Semaphore 和 CountDownLatch</h2><blockquote>
<p>Semaphore</p>
</blockquote>
<p>Semaphore 使用 AQS 类型的同步状态持有当前可用许可的数量。Semaphore 的 tryAcquireShared 和 tryAcquire Shared 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Semaphore</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 同步状态的当前值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">                <span class="comment">// 剩余状态量小于零</span></span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    <span class="comment">// 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值</span></span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 同步状态的当前值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>nonfairTryAcquireShared() 方法：首先计算剩余许可的数量，如果没有足够的许可，会返回一个值，表明获取操作失败。如果还有充足的许可剩余，nonfairTryAcquireShared 会使用 compareAndsetState()，尝试原子地递减许可的计数。</li>
<li>类似地，tryReleaseShared() 会递增许可计数，这会潜在地解除等待中的线程的阻塞，不断地重试直到成功地更新。tryReleaseShared 的返回值表明，释放操作是否可以解除其他线程的阻塞。</li>
</ul>
<blockquote>
<p>CountDownLatch</p>
</blockquote>
<p>CountDownLatch 使用 AQS 的方式与 Semaphore 相似，同步状态持有当前的计数：</p>
<ul>
<li><p>countDown 方法调用 release，后者会导致计数器递减，并且在计数器已经到达零的时候，解除所有等待线程的阻塞</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 递减计数；转换为零时的信号</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 同步状态的当前值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果当前状态值等于预期值，则自动将同步状态设置为给定的更新值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="type">return</span> <span class="variable">nextc</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>await 调用 acquire，如果计数器己经到达零，acquire 会立即返回，否则它会被阻塞。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-4-ReentrantReadWriteLock"><a href="#4-4-ReentrantReadWriteLock" class="headerlink" title="4.4 ReentrantReadWriteLock"></a>4.4 ReentrantReadWriteLock</h2><blockquote>
<p>ReentrantReadWriteLock</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReadwriteLock 的接口要求了两个锁，一个读者锁和一个写者锁。在基于 AQS 的 ReentrantReadMriteLock 实现中，一个单独的 AQS 子类管理了读和写的加锁。</p>
<p>ReentrantReadwriteLock 使用一个 16 位的状态为写锁（write-lock）计数，使用另一个 16 位的状态为读锁(read-lock）计数。</p>
<p>对读锁的操作使用共享的获取与释放的方法：对写锁的操作使用独占的获取与释放的方法。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java并发编程实战：第14章 构建自定义的同步工具</p><p><a href="https://osys.github.io/posts/d3e0.html">https://osys.github.io/posts/d3e0.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Osys</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022年08月29日</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022年08月29日</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/483b.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java并发编程实战：第14章 总结</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/3c21.html"><span class="level-item">Java并发编程实战：第13章 总结</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "7740b280b46450a5c7858944a76b0c73",
            repo: "osys.github.io",
            owner: "osys",
            clientID: "e0f10cf0c934d445e79f",
            clientSecret: "3dad6d25224fe45db31a3a912756bd5175e3a70f",
            admin: ["osys"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-8-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-管理状态依赖性"><span class="level-left"><span class="level-item">1. 管理状态依赖性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-管理状态依赖性"><span class="level-left"><span class="level-item">1.1 管理状态依赖性</span></span></a></li><li><a class="level is-mobile" href="#1-2-将先验条件失败传给调用者"><span class="level-left"><span class="level-item">1.2 将先验条件失败传给调用者</span></span></a></li><li><a class="level is-mobile" href="#1-3-利用-“轮询加休眠”-实现拙劣的阻塞"><span class="level-left"><span class="level-item">1.3 利用 “轮询加休眠” 实现拙劣的阻塞</span></span></a></li><li><a class="level is-mobile" href="#1-4-使用条件队列解决拙劣的阻塞"><span class="level-left"><span class="level-item">1.4 使用条件队列解决拙劣的阻塞</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-使用条件队列"><span class="level-left"><span class="level-item">2. 使用条件队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-条件谓词"><span class="level-left"><span class="level-item">2.1 条件谓词</span></span></a></li><li><a class="level is-mobile" href="#2-2-过早地唤醒"><span class="level-left"><span class="level-item">2.2 过早地唤醒</span></span></a></li><li><a class="level is-mobile" href="#2-3-丢失的信号"><span class="level-left"><span class="level-item">2.3 丢失的信号</span></span></a></li><li><a class="level is-mobile" href="#2-4-通知"><span class="level-left"><span class="level-item">2.4 通知</span></span></a></li><li><a class="level is-mobile" href="#2-5-阀门类"><span class="level-left"><span class="level-item">2.5 阀门类</span></span></a></li><li><a class="level is-mobile" href="#2-6-显式的-Condition-对象"><span class="level-left"><span class="level-item">2.6 显式的 Condition 对象</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-剖析-Synchronizer"><span class="level-left"><span class="level-item">3. 剖析 Synchronizer</span></span></a></li><li><a class="level is-mobile" href="#4-AbstractQueuedSynchronizer"><span class="level-left"><span class="level-item">4. AbstractQueuedSynchronizer</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-AbstractQueuedSynchronizer"><span class="level-left"><span class="level-item">4.1 AbstractQueuedSynchronizer</span></span></a></li><li><a class="level is-mobile" href="#4-2-ReentrantLock"><span class="level-left"><span class="level-item">4.2 ReentrantLock</span></span></a></li><li><a class="level is-mobile" href="#4-3-Semaphore-和-CountDownLatch"><span class="level-left"><span class="level-item">4.3 Semaphore 和 CountDownLatch</span></span></a></li><li><a class="level is-mobile" href="#4-4-ReentrantReadWriteLock"><span class="level-left"><span class="level-item">4.4 ReentrantReadWriteLock</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://cdn.jsdelivr.net/gh/osys/oss@master/blog/img/basic/avatar.png" alt="Osys"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Osys</p><p class="is-size-6 is-block">追寻美好生活，书写人生精彩篇章。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>GuangZhou</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">5</p></a></div></div></nav></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/categories/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/"><span class="level-start"><span class="level-item">项目案例</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">Java并发编程</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SpringBoot/"><span class="tag">SpringBoot</span><span class="tag">2</span></a></div></div></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li></ul></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.cnblogs.com/liyihua/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">我的博客园</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/qq_44830823?type=blog" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">我的CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><p><img src="https://cdn.jsdelivr.net/gh/osys/cloud@master/img/basic/favicon512.png" alt="LeeHua&#039;s Blog" height="28"><href src="https://osyss.com"> 数据开发猿</href>  ~~~~~~~~~~~~~~~~~~~~~~~~~  @世间美好与大家环环相扣@  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>---------------------------------------------------------------------------------------------------------------------------------------------------------------------------<p><a href="https://beian.miit.gov.cn/" target="_blank">备案号: 粤ICP备2022104988号</a>【<a href="https://github.com/" target="_blank">网站: 挂载于 github + 腾讯云</a>】 【<a href="https://github.com/" target="_blank">图片: 挂载于 github</a>】 【<a href="https://www.jsdelivr.com/github" target="_blank">CDN: jsDelivr</a>】</p></a><p class="is-size-7"><script src="https://sdk.51.la/perf/js-sdk-pro.min.js" crossorigin="anonymous"></script><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js?id=JoDQdGZeB7Cy04AN&amp;ck=JoDQdGZeB7Cy04AN"></script><a target=" blank" title="网站统计" href="https://v6.51.la/land/JoDQdGZeB7Cy04AN"></a><script id="LA-DATA-WIDGET" crossorigin="anonymous" charset="UTF-8" src="https://v6-widget.51.la/v6/JoDQdGZeB7Cy04AN/quote.js?theme=0&amp;f=12&amp;display=0,1,1,1,1,1,0,1"></script></p>---------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="粤ICP备2022104988号-1" href="https://beian.miit.gov.cn/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Blog on GitHub" href="https://github.com/osys/osys.github.io/"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container" id="algolia-input"></div><div id="algolia-poweredby" style="display:flex;margin:0 .5em 0 1em;align-items:center;line-height:0"></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div><div class="searchbox-footer"></div></div></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.0.3/dist/algoliasearch-lite.umd.js" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.3.1/dist/instantsearch.production.min.js" crossorigin="anonymous" defer></script><script src="/js/algolia.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadAlgolia({"applicationId":"8FPI8CDLJR","apiKey":"702cfc5bf8397419842065704ec39904","indexName":"github_pages_hexo_blog"}, {"hint":"想要查找什么...","no_result":"未找到搜索结果","untitled":"(无标题)","empty_preview":"(无内容预览)"});
        });</script></body></html>